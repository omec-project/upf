From fde6a6ab22aed25bfbd3f6c410f1b40258928fed Mon Sep 17 00:00:00 2001
From: Muhammad Asim Jamshed <muhammad.jamshed@intel.com>
Date: Wed, 29 Apr 2020 16:00:38 -0700
Subject: [PATCH] Augment IPChecksum and L4Checksum modules to support
 verification.

Signed-off-by: Muhammad Asim Jamshed <muhammad.jamshed@intel.com>
---
 core/modules/ip_checksum.cc | 23 ++++++++++++++++++-----
 core/modules/ip_checksum.h  |  7 +++++++
 core/modules/l4_checksum.cc | 32 ++++++++++++++++++++++++--------
 core/modules/l4_checksum.h  |  7 +++++++
 4 files changed, 56 insertions(+), 13 deletions(-)

diff --git a/core/modules/ip_checksum.cc b/core/modules/ip_checksum.cc
index ab7014f4..c0c03364 100644
--- a/core/modules/ip_checksum.cc
+++ b/core/modules/ip_checksum.cc
@@ -34,6 +34,8 @@
 #include "../utils/ether.h"
 #include "../utils/ip.h"
 
+enum { DEFAULT_GATE = 0, _DROP_GATE };
+
 void IPChecksum::ProcessBatch(Context *ctx, bess::PacketBatch *batch) {
   using bess::utils::be16_t;
   using bess::utils::Ethernet;
@@ -54,7 +56,8 @@ void IPChecksum::ProcessBatch(Context *ctx, bess::PacketBatch *batch) {
       data = qinq + 1;
       ether_type = qinq->ether_type;
       if (ether_type != be16_t(Ethernet::Type::kVlan)) {
-        continue;
+	EmitPacket(ctx, batch->pkts()[i], DEFAULT_GATE);
+	continue;
       }
     }
 
@@ -67,13 +70,23 @@ void IPChecksum::ProcessBatch(Context *ctx, bess::PacketBatch *batch) {
     if (ether_type == be16_t(Ethernet::Type::kIpv4)) {
       ip = reinterpret_cast<Ipv4 *>(data);
     } else {
+      EmitPacket(ctx, batch->pkts()[i], DEFAULT_GATE);
       continue;
     }
 
-    ip->checksum = CalculateIpv4Checksum(*ip);
+    if (verify)
+      EmitPacket(ctx, batch->pkts()[i], (VerifyIpv4Checksum(*ip)) ? DEFAULT_GATE : _DROP_GATE);
+    else {
+      ip->checksum = CalculateIpv4Checksum(*ip);
+      EmitPacket(ctx, batch->pkts()[i], DEFAULT_GATE);
+    }
   }
-
-  RunNextModule(ctx, batch);
 }
-
+/*----------------------------------------------------------------------------------*/
+CommandResponse IPChecksum::Init(const bess::pb::IPChecksumArg &arg) {
+  if (arg.verify())
+    verify = true;
+  return CommandSuccess();
+}
+/*----------------------------------------------------------------------------------*/
 ADD_MODULE(IPChecksum, "ip_checksum", "recomputes the IPv4 checksum")
diff --git a/core/modules/ip_checksum.h b/core/modules/ip_checksum.h
index b17de616..eef92109 100644
--- a/core/modules/ip_checksum.h
+++ b/core/modules/ip_checksum.h
@@ -39,7 +39,14 @@ class IPChecksum final : public Module {
  public:
   IPChecksum() : Module() { max_allowed_workers_ = Worker::kMaxWorkers; }
 
+  /* Gates: (0) Default, (1) Drop */
+  static const gate_idx_t kNumOGates = 2;
+  CommandResponse Init(const bess::pb::IPChecksumArg &arg);
   void ProcessBatch(Context *ctx, bess::PacketBatch *batch) override;
+
+ private:
+  /* enable checksum verification */
+  bool verify = false;
 };
 
 #endif  // BESS_MODULES_IP_CHECKSUM_H_
diff --git a/core/modules/l4_checksum.cc b/core/modules/l4_checksum.cc
index d971dced..41950a47 100644
--- a/core/modules/l4_checksum.cc
+++ b/core/modules/l4_checksum.cc
@@ -36,6 +36,8 @@
 #include "../utils/tcp.h"
 #include "../utils/udp.h"
 
+enum { DEFAULT_GATE = 0, _DROP_GATE };
+
 void L4Checksum::ProcessBatch(Context *ctx, bess::PacketBatch *batch) {
   using bess::utils::be16_t;
   using bess::utils::Ethernet;
@@ -49,8 +51,10 @@ void L4Checksum::ProcessBatch(Context *ctx, bess::PacketBatch *batch) {
     Ethernet *eth = batch->pkts()[i]->head_data<Ethernet *>();
 
     // Calculate checksum only for IPv4 packets
-    if (eth->ether_type != be16_t(Ethernet::Type::kIpv4))
+    if (eth->ether_type != be16_t(Ethernet::Type::kIpv4)) {
+      EmitPacket(ctx, batch->pkts()[i], DEFAULT_GATE);
       continue;
+    }
 
     Ipv4 *ip = reinterpret_cast<Ipv4 *>(eth + 1);
 
@@ -58,19 +62,31 @@ void L4Checksum::ProcessBatch(Context *ctx, bess::PacketBatch *batch) {
       size_t ip_bytes = (ip->header_length) << 2;
       Udp *udp =
           reinterpret_cast<Udp *>(reinterpret_cast<uint8_t *>(ip) + ip_bytes);
-      udp->checksum = CalculateIpv4UdpChecksum(*ip, *udp);
+      if (verify)
+	 EmitPacket(ctx, batch->pkts()[i],
+		    (VerifyIpv4UdpChecksum(*ip, *udp)) ? DEFAULT_GATE : _DROP_GATE);
+      else {
+	 udp->checksum = CalculateIpv4UdpChecksum(*ip, *udp);
+	 EmitPacket(ctx, batch->pkts()[i], DEFAULT_GATE);
+      }
     } else if (ip->protocol == Ipv4::Proto::kTcp) {
       size_t ip_bytes = (ip->header_length) << 2;
       Tcp *tcp =
           reinterpret_cast<Tcp *>(reinterpret_cast<uint8_t *>(ip) + ip_bytes);
-      tcp->checksum = CalculateIpv4TcpChecksum(*ip, *tcp);
+      if (verify)
+	 EmitPacket(ctx, batch->pkts()[i],
+		    (VerifyIpv4TcpChecksum(*ip, *tcp)) ? DEFAULT_GATE : _DROP_GATE);
+      else
+	 tcp->checksum = CalculateIpv4TcpChecksum(*ip, *tcp);
     }
-
-    continue;
   }
-
-  RunNextModule(ctx, batch);
 }
-
+/*----------------------------------------------------------------------------------*/
+CommandResponse L4Checksum::Init(const bess::pb::L4ChecksumArg &arg) {
+  if (arg.verify())
+    verify = arg.verify();
+  return CommandSuccess();
+}
+/*----------------------------------------------------------------------------------*/
 ADD_MODULE(L4Checksum, "l4_checksum",
            "recomputes the TCP/Ipv4 and UDP/IPv4 checksum")
diff --git a/core/modules/l4_checksum.h b/core/modules/l4_checksum.h
index 89388bab..5c761707 100644
--- a/core/modules/l4_checksum.h
+++ b/core/modules/l4_checksum.h
@@ -38,7 +38,14 @@ class L4Checksum final : public Module {
  public:
   L4Checksum() : Module() { max_allowed_workers_ = Worker::kMaxWorkers; }
 
+  /* Gates: (0) Default, (1) Drop */
+  static const gate_idx_t kNumOGates = 2;
+  static const gate_idx_t kNumIGates = MAX_GATES;
+  CommandResponse Init(const bess::pb::L4ChecksumArg &arg);
   void ProcessBatch(Context *ctx, bess::PacketBatch *batch) override;
+
+ private:
+  bool verify = false;
 };
 
 #endif  // BESS_MODULES_L4_CHECKSUM_H_
-- 
2.25.1

