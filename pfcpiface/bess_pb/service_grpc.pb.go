// Copyright (c) 2016-2017, Nefeli Networks, Inc.
// All rights reserved.
//
// SPDX-License-Identifier: BSD-3-Clause
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
// list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// * Neither the names of the copyright holders nor the names of their
// contributors may be used to endorse or promote products derived from this
// software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: service.proto

package bess_pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BESSControl_GetVersion_FullMethodName                 = "/bess.pb.BESSControl/GetVersion"
	BESSControl_ResetAll_FullMethodName                   = "/bess.pb.BESSControl/ResetAll"
	BESSControl_KillBess_FullMethodName                   = "/bess.pb.BESSControl/KillBess"
	BESSControl_ImportPlugin_FullMethodName               = "/bess.pb.BESSControl/ImportPlugin"
	BESSControl_UnloadPlugin_FullMethodName               = "/bess.pb.BESSControl/UnloadPlugin"
	BESSControl_ListPlugins_FullMethodName                = "/bess.pb.BESSControl/ListPlugins"
	BESSControl_PauseAll_FullMethodName                   = "/bess.pb.BESSControl/PauseAll"
	BESSControl_PauseWorker_FullMethodName                = "/bess.pb.BESSControl/PauseWorker"
	BESSControl_ResumeWorker_FullMethodName               = "/bess.pb.BESSControl/ResumeWorker"
	BESSControl_ResumeAll_FullMethodName                  = "/bess.pb.BESSControl/ResumeAll"
	BESSControl_ResetWorkers_FullMethodName               = "/bess.pb.BESSControl/ResetWorkers"
	BESSControl_ListWorkers_FullMethodName                = "/bess.pb.BESSControl/ListWorkers"
	BESSControl_AddWorker_FullMethodName                  = "/bess.pb.BESSControl/AddWorker"
	BESSControl_DestroyWorker_FullMethodName              = "/bess.pb.BESSControl/DestroyWorker"
	BESSControl_ResetTcs_FullMethodName                   = "/bess.pb.BESSControl/ResetTcs"
	BESSControl_ListTcs_FullMethodName                    = "/bess.pb.BESSControl/ListTcs"
	BESSControl_CheckSchedulingConstraints_FullMethodName = "/bess.pb.BESSControl/CheckSchedulingConstraints"
	BESSControl_AddTc_FullMethodName                      = "/bess.pb.BESSControl/AddTc"
	BESSControl_UpdateTcParams_FullMethodName             = "/bess.pb.BESSControl/UpdateTcParams"
	BESSControl_UpdateTcParent_FullMethodName             = "/bess.pb.BESSControl/UpdateTcParent"
	BESSControl_GetTcStats_FullMethodName                 = "/bess.pb.BESSControl/GetTcStats"
	BESSControl_ListDrivers_FullMethodName                = "/bess.pb.BESSControl/ListDrivers"
	BESSControl_GetDriverInfo_FullMethodName              = "/bess.pb.BESSControl/GetDriverInfo"
	BESSControl_ResetPorts_FullMethodName                 = "/bess.pb.BESSControl/ResetPorts"
	BESSControl_ListPorts_FullMethodName                  = "/bess.pb.BESSControl/ListPorts"
	BESSControl_CreatePort_FullMethodName                 = "/bess.pb.BESSControl/CreatePort"
	BESSControl_DestroyPort_FullMethodName                = "/bess.pb.BESSControl/DestroyPort"
	BESSControl_SetPortConf_FullMethodName                = "/bess.pb.BESSControl/SetPortConf"
	BESSControl_GetPortConf_FullMethodName                = "/bess.pb.BESSControl/GetPortConf"
	BESSControl_GetPortStats_FullMethodName               = "/bess.pb.BESSControl/GetPortStats"
	BESSControl_GetLinkStatus_FullMethodName              = "/bess.pb.BESSControl/GetLinkStatus"
	BESSControl_ListMclass_FullMethodName                 = "/bess.pb.BESSControl/ListMclass"
	BESSControl_GetMclassInfo_FullMethodName              = "/bess.pb.BESSControl/GetMclassInfo"
	BESSControl_ResetModules_FullMethodName               = "/bess.pb.BESSControl/ResetModules"
	BESSControl_ListModules_FullMethodName                = "/bess.pb.BESSControl/ListModules"
	BESSControl_CreateModule_FullMethodName               = "/bess.pb.BESSControl/CreateModule"
	BESSControl_DestroyModule_FullMethodName              = "/bess.pb.BESSControl/DestroyModule"
	BESSControl_GetModuleInfo_FullMethodName              = "/bess.pb.BESSControl/GetModuleInfo"
	BESSControl_ConnectModules_FullMethodName             = "/bess.pb.BESSControl/ConnectModules"
	BESSControl_DisconnectModules_FullMethodName          = "/bess.pb.BESSControl/DisconnectModules"
	BESSControl_DumpMempool_FullMethodName                = "/bess.pb.BESSControl/DumpMempool"
	BESSControl_ModuleCommand_FullMethodName              = "/bess.pb.BESSControl/ModuleCommand"
	BESSControl_ListGateHookClass_FullMethodName          = "/bess.pb.BESSControl/ListGateHookClass"
	BESSControl_GetGateHookClassInfo_FullMethodName       = "/bess.pb.BESSControl/GetGateHookClassInfo"
	BESSControl_ConfigureGateHook_FullMethodName          = "/bess.pb.BESSControl/ConfigureGateHook"
	BESSControl_ListGateHooks_FullMethodName              = "/bess.pb.BESSControl/ListGateHooks"
	BESSControl_GateHookCommand_FullMethodName            = "/bess.pb.BESSControl/GateHookCommand"
	BESSControl_ConfigureResumeHook_FullMethodName        = "/bess.pb.BESSControl/ConfigureResumeHook"
)

// BESSControlClient is the client API for BESSControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BESSControlClient interface {
	// / Query version of bessd
	GetVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	// / Reset the current packet processing datapath to the initial state.
	// /
	// / This command is identical to the following sequence:
	// /   ResetModules()
	// /   ResetPorts()
	// /   ResetTcs()
	// /   ResetWorkers()
	// / As it clears everything, BESS should appear as if the daemon has freshly
	// / started (if not, it is a bug; please report).
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Terminate the BESS daemon.
	// /
	// / BESS daemon shuts off in a graceful manner. Note that this command is
	// / "asynchronous": this command doesn't block until the BESS daemon has
	// / shut off.
	// /
	// / NOTE: There should be no running worker to run this command.
	// / FIXME: rename (e.g., Terminate)
	KillBess(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Import a plugin
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	ImportPlugin(ctx context.Context, in *ImportPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Unload a plugin
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	UnloadPlugin(ctx context.Context, in *UnloadPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / List imported plugins
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	ListPlugins(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error)
	// / Pause all running workers temporarily
	// /
	// / Some RPC commands to BESS or individual modules/ports require that
	// / threads must be inactive, to avoid race conditions.
	// / For such commands, use PauseALl at the beginning and ResumeAll at the end.
	// /  PauseAll()
	// /   SomeCommand1()
	// /   SomeCommand2()
	// /   ...
	// /  ResumeAll()
	// / Keep the duration as short as possible, to avoid packet drops.
	PauseAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Pause the specified worker temporarily
	// /
	// / Some RPC commands to BESS or individual modules/ports require that
	// / threads must be inactive, to avoid race conditions.
	// / For such commands, use PauseWorker at the beginning and ResumeWorker at
	// / the end.
	// /  PauseWorker(0)
	// /   SomeCommand1()
	// /   SomeCommand2()
	// /   ...
	// /  ResumeWorker(0)
	// / Keep the duration as short as possible, to avoid packet drops.
	PauseWorker(ctx context.Context, in *PauseWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Resume the specified worker
	ResumeWorker(ctx context.Context, in *ResumeWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Resume all paused workers
	ResumeAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Remove all existing workers
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Enumerate all existing workers
	ListWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error)
	// / Create a new worker
	// /
	// / NOTE: There should be no running worker to run this command.
	AddWorker(ctx context.Context, in *AddWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Remove a single worker
	// /
	// / NOTE: There should be no running worker to run this command.
	DestroyWorker(ctx context.Context, in *DestroyWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Remove all existing traffic classes
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetTcs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Enumerate all existing workers
	ListTcs(ctx context.Context, in *ListTcsRequest, opts ...grpc.CallOption) (*ListTcsResponse, error)
	// / Check scheduling contraints
	CheckSchedulingConstraints(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*CheckSchedulingConstraintsResponse, error)
	// / Create a new traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	AddTc(ctx context.Context, in *AddTcRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Update parameters of an existing traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	UpdateTcParams(ctx context.Context, in *UpdateTcParamsRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Change parent (and child arguments) of an existing traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	UpdateTcParent(ctx context.Context, in *UpdateTcParentRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Collect statistics of a traffic class
	GetTcStats(ctx context.Context, in *GetTcStatsRequest, opts ...grpc.CallOption) (*GetTcStatsResponse, error)
	// / Enumerate all port drivers available
	ListDrivers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListDriversResponse, error)
	// / Query detailed information of a port driver
	GetDriverInfo(ctx context.Context, in *GetDriverInfoRequest, opts ...grpc.CallOption) (*GetDriverInfoResponse, error)
	// / Remove all initialized ports
	// /
	// / Will fail if there are modules that are still using ports.
	// / (e.g., PortInc, PortOut, QueueInc, QueueOut)
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Enumerate all initialized ports
	ListPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPortsResponse, error)
	// / Create a new port from the specified driver
	CreatePort(ctx context.Context, in *CreatePortRequest, opts ...grpc.CallOption) (*CreatePortResponse, error)
	// / Remove a port
	// /
	// / The port should not be being used by a port-related module.
	// / (e.g., PortInc, PortOut, QueueInc, QueueOut)
	DestroyPort(ctx context.Context, in *DestroyPortRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Runtime-updatable configuration
	SetPortConf(ctx context.Context, in *SetPortConfRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	GetPortConf(ctx context.Context, in *GetPortConfRequest, opts ...grpc.CallOption) (*GetPortConfResponse, error)
	// / Collect port statistics
	// /
	// / At the moment, per-queue stats are not supported.
	GetPortStats(ctx context.Context, in *GetPortStatsRequest, opts ...grpc.CallOption) (*GetPortStatsResponse, error)
	// / Query link status
	GetLinkStatus(ctx context.Context, in *GetLinkStatusRequest, opts ...grpc.CallOption) (*GetLinkStatusResponse, error)
	// / Enumerate all module types available
	ListMclass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListMclassResponse, error)
	// / Query detailed information of a module type
	GetMclassInfo(ctx context.Context, in *GetMclassInfoRequest, opts ...grpc.CallOption) (*GetMclassInfoResponse, error)
	// / Remove all modules.
	// /
	// / This RPC will always succeed (unless there is a running worker)
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Enumerate all initialized modules
	ListModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListModulesResponse, error)
	// / Create a new module instance from the given module type
	// /
	// / NOTE: There should be no running worker to run this command.
	CreateModule(ctx context.Context, in *CreateModuleRequest, opts ...grpc.CallOption) (*CreateModuleResponse, error)
	// / Destroy an existing module
	// /
	// / If the module is connected to other modules' input/output gate, they are
	// / disconnected first. All tasks created by the module will also be destroyed.
	// /
	// / NOTE: There should be no running worker to run this command.
	DestroyModule(ctx context.Context, in *DestroyModuleRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Fetch detailed information of an module instance
	GetModuleInfo(ctx context.Context, in *GetModuleInfoRequest, opts ...grpc.CallOption) (*GetModuleInfoResponse, error)
	// / Connect two modules.
	// /
	// / Connect between m1's ogate and n2's igate (i.e., packets sent to m1's ogate
	// / will be fed to m2's igate). The ogate can be connected to only one igate,
	// / while the igate can be connected to multiple output gates.
	// /
	// / NOTE: There should be no running worker to run this command.
	ConnectModules(ctx context.Context, in *ConnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Disconnect two modules.
	// /
	// / It removes a connection between two modules (you specify the previous one
	// / and its output gate). All packets coming out from the ogate will be
	// / dropped. Once disconnected, the ogate can be connected
	// / to any input gate.
	// /
	// / NOTE: There should be no running worker to run this command.
	DisconnectModules(ctx context.Context, in *DisconnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// / Dump various stats about BESS's packet pools
	DumpMempool(ctx context.Context, in *DumpMempoolRequest, opts ...grpc.CallOption) (*DumpMempoolResponse, error)
	// / Send a command to the specified module instance.
	// /
	// / Each module type defines a list of module-specific commands, which
	// / allow external programs to communicate with the module at runtime.
	// / See module_msg.proto for details.
	// /
	// / NOTE: Some commands cannot be used if there are running workers.
	// /       For those commands you must pause all workers first.
	ModuleCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	// / Enumerate all gatehook types available
	ListGateHookClass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHookClassResponse, error)
	// / Query detailed information of a gatehook type
	GetGateHookClassInfo(ctx context.Context, in *GetGateHookClassInfoRequest, opts ...grpc.CallOption) (*GetGateHookClassInfoResponse, error)
	// / Enable/Disable a gate hook.
	ConfigureGateHook(ctx context.Context, in *ConfigureGateHookRequest, opts ...grpc.CallOption) (*ConfigureGateHookResponse, error)
	// / Enumerate all gatehook installed
	ListGateHooks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHooksResponse, error)
	// / Send command to gate hook instance.
	GateHookCommand(ctx context.Context, in *GateHookCommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	// / Enable/Disable a resume hook.
	ConfigureResumeHook(ctx context.Context, in *ConfigureResumeHookRequest, opts ...grpc.CallOption) (*CommandResponse, error)
}

type bESSControlClient struct {
	cc grpc.ClientConnInterface
}

func NewBESSControlClient(cc grpc.ClientConnInterface) BESSControlClient {
	return &bESSControlClient{cc}
}

func (c *bESSControlClient) GetVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ResetAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) KillBess(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_KillBess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ImportPlugin(ctx context.Context, in *ImportPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ImportPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UnloadPlugin(ctx context.Context, in *UnloadPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_UnloadPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListPlugins(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPluginsResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListPlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) PauseAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_PauseAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) PauseWorker(ctx context.Context, in *PauseWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_PauseWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResumeWorker(ctx context.Context, in *ResumeWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ResumeWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResumeAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ResumeAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ResetWorkers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkersResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListWorkers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) AddWorker(ctx context.Context, in *AddWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_AddWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyWorker(ctx context.Context, in *DestroyWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_DestroyWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetTcs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ResetTcs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListTcs(ctx context.Context, in *ListTcsRequest, opts ...grpc.CallOption) (*ListTcsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTcsResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListTcs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CheckSchedulingConstraints(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*CheckSchedulingConstraintsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckSchedulingConstraintsResponse)
	err := c.cc.Invoke(ctx, BESSControl_CheckSchedulingConstraints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) AddTc(ctx context.Context, in *AddTcRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_AddTc_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UpdateTcParams(ctx context.Context, in *UpdateTcParamsRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_UpdateTcParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UpdateTcParent(ctx context.Context, in *UpdateTcParentRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_UpdateTcParent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetTcStats(ctx context.Context, in *GetTcStatsRequest, opts ...grpc.CallOption) (*GetTcStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTcStatsResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetTcStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListDrivers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListDriversResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriversResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListDrivers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetDriverInfo(ctx context.Context, in *GetDriverInfoRequest, opts ...grpc.CallOption) (*GetDriverInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDriverInfoResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetDriverInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ResetPorts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPortsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPortsResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListPorts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CreatePort(ctx context.Context, in *CreatePortRequest, opts ...grpc.CallOption) (*CreatePortResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePortResponse)
	err := c.cc.Invoke(ctx, BESSControl_CreatePort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyPort(ctx context.Context, in *DestroyPortRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_DestroyPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) SetPortConf(ctx context.Context, in *SetPortConfRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, BESSControl_SetPortConf_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetPortConf(ctx context.Context, in *GetPortConfRequest, opts ...grpc.CallOption) (*GetPortConfResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPortConfResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetPortConf_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetPortStats(ctx context.Context, in *GetPortStatsRequest, opts ...grpc.CallOption) (*GetPortStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPortStatsResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetPortStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetLinkStatus(ctx context.Context, in *GetLinkStatusRequest, opts ...grpc.CallOption) (*GetLinkStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinkStatusResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetLinkStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListMclass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListMclassResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMclassResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListMclass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetMclassInfo(ctx context.Context, in *GetMclassInfoRequest, opts ...grpc.CallOption) (*GetMclassInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMclassInfoResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetMclassInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ResetModules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListModulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModulesResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListModules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CreateModule(ctx context.Context, in *CreateModuleRequest, opts ...grpc.CallOption) (*CreateModuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateModuleResponse)
	err := c.cc.Invoke(ctx, BESSControl_CreateModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyModule(ctx context.Context, in *DestroyModuleRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_DestroyModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetModuleInfo(ctx context.Context, in *GetModuleInfoRequest, opts ...grpc.CallOption) (*GetModuleInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModuleInfoResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetModuleInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConnectModules(ctx context.Context, in *ConnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_ConnectModules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DisconnectModules(ctx context.Context, in *DisconnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, BESSControl_DisconnectModules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DumpMempool(ctx context.Context, in *DumpMempoolRequest, opts ...grpc.CallOption) (*DumpMempoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DumpMempoolResponse)
	err := c.cc.Invoke(ctx, BESSControl_DumpMempool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ModuleCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, BESSControl_ModuleCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListGateHookClass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHookClassResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGateHookClassResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListGateHookClass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetGateHookClassInfo(ctx context.Context, in *GetGateHookClassInfoRequest, opts ...grpc.CallOption) (*GetGateHookClassInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGateHookClassInfoResponse)
	err := c.cc.Invoke(ctx, BESSControl_GetGateHookClassInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConfigureGateHook(ctx context.Context, in *ConfigureGateHookRequest, opts ...grpc.CallOption) (*ConfigureGateHookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigureGateHookResponse)
	err := c.cc.Invoke(ctx, BESSControl_ConfigureGateHook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListGateHooks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHooksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGateHooksResponse)
	err := c.cc.Invoke(ctx, BESSControl_ListGateHooks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GateHookCommand(ctx context.Context, in *GateHookCommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, BESSControl_GateHookCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConfigureResumeHook(ctx context.Context, in *ConfigureResumeHookRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, BESSControl_ConfigureResumeHook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BESSControlServer is the server API for BESSControl service.
// All implementations must embed UnimplementedBESSControlServer
// for forward compatibility.
type BESSControlServer interface {
	// / Query version of bessd
	GetVersion(context.Context, *EmptyRequest) (*VersionResponse, error)
	// / Reset the current packet processing datapath to the initial state.
	// /
	// / This command is identical to the following sequence:
	// /   ResetModules()
	// /   ResetPorts()
	// /   ResetTcs()
	// /   ResetWorkers()
	// / As it clears everything, BESS should appear as if the daemon has freshly
	// / started (if not, it is a bug; please report).
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Terminate the BESS daemon.
	// /
	// / BESS daemon shuts off in a graceful manner. Note that this command is
	// / "asynchronous": this command doesn't block until the BESS daemon has
	// / shut off.
	// /
	// / NOTE: There should be no running worker to run this command.
	// / FIXME: rename (e.g., Terminate)
	KillBess(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Import a plugin
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	ImportPlugin(context.Context, *ImportPluginRequest) (*EmptyResponse, error)
	// / Unload a plugin
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	UnloadPlugin(context.Context, *UnloadPluginRequest) (*EmptyResponse, error)
	// / List imported plugins
	// /
	// / At the moment plugins can only contain module types,
	// / but might also support drivers/hooks/schedulers in the future.
	ListPlugins(context.Context, *EmptyRequest) (*ListPluginsResponse, error)
	// / Pause all running workers temporarily
	// /
	// / Some RPC commands to BESS or individual modules/ports require that
	// / threads must be inactive, to avoid race conditions.
	// / For such commands, use PauseALl at the beginning and ResumeAll at the end.
	// /  PauseAll()
	// /   SomeCommand1()
	// /   SomeCommand2()
	// /   ...
	// /  ResumeAll()
	// / Keep the duration as short as possible, to avoid packet drops.
	PauseAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Pause the specified worker temporarily
	// /
	// / Some RPC commands to BESS or individual modules/ports require that
	// / threads must be inactive, to avoid race conditions.
	// / For such commands, use PauseWorker at the beginning and ResumeWorker at
	// / the end.
	// /  PauseWorker(0)
	// /   SomeCommand1()
	// /   SomeCommand2()
	// /   ...
	// /  ResumeWorker(0)
	// / Keep the duration as short as possible, to avoid packet drops.
	PauseWorker(context.Context, *PauseWorkerRequest) (*EmptyResponse, error)
	// / Resume the specified worker
	ResumeWorker(context.Context, *ResumeWorkerRequest) (*EmptyResponse, error)
	// / Resume all paused workers
	ResumeAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Remove all existing workers
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetWorkers(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Enumerate all existing workers
	ListWorkers(context.Context, *EmptyRequest) (*ListWorkersResponse, error)
	// / Create a new worker
	// /
	// / NOTE: There should be no running worker to run this command.
	AddWorker(context.Context, *AddWorkerRequest) (*EmptyResponse, error)
	// / Remove a single worker
	// /
	// / NOTE: There should be no running worker to run this command.
	DestroyWorker(context.Context, *DestroyWorkerRequest) (*EmptyResponse, error)
	// / Remove all existing traffic classes
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetTcs(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Enumerate all existing workers
	ListTcs(context.Context, *ListTcsRequest) (*ListTcsResponse, error)
	// / Check scheduling contraints
	CheckSchedulingConstraints(context.Context, *EmptyRequest) (*CheckSchedulingConstraintsResponse, error)
	// / Create a new traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	AddTc(context.Context, *AddTcRequest) (*EmptyResponse, error)
	// / Update parameters of an existing traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	UpdateTcParams(context.Context, *UpdateTcParamsRequest) (*EmptyResponse, error)
	// / Change parent (and child arguments) of an existing traffic class
	// /
	// / NOTE: There should be no running worker to run this command.
	UpdateTcParent(context.Context, *UpdateTcParentRequest) (*EmptyResponse, error)
	// / Collect statistics of a traffic class
	GetTcStats(context.Context, *GetTcStatsRequest) (*GetTcStatsResponse, error)
	// / Enumerate all port drivers available
	ListDrivers(context.Context, *EmptyRequest) (*ListDriversResponse, error)
	// / Query detailed information of a port driver
	GetDriverInfo(context.Context, *GetDriverInfoRequest) (*GetDriverInfoResponse, error)
	// / Remove all initialized ports
	// /
	// / Will fail if there are modules that are still using ports.
	// / (e.g., PortInc, PortOut, QueueInc, QueueOut)
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetPorts(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Enumerate all initialized ports
	ListPorts(context.Context, *EmptyRequest) (*ListPortsResponse, error)
	// / Create a new port from the specified driver
	CreatePort(context.Context, *CreatePortRequest) (*CreatePortResponse, error)
	// / Remove a port
	// /
	// / The port should not be being used by a port-related module.
	// / (e.g., PortInc, PortOut, QueueInc, QueueOut)
	DestroyPort(context.Context, *DestroyPortRequest) (*EmptyResponse, error)
	// / Runtime-updatable configuration
	SetPortConf(context.Context, *SetPortConfRequest) (*CommandResponse, error)
	GetPortConf(context.Context, *GetPortConfRequest) (*GetPortConfResponse, error)
	// / Collect port statistics
	// /
	// / At the moment, per-queue stats are not supported.
	GetPortStats(context.Context, *GetPortStatsRequest) (*GetPortStatsResponse, error)
	// / Query link status
	GetLinkStatus(context.Context, *GetLinkStatusRequest) (*GetLinkStatusResponse, error)
	// / Enumerate all module types available
	ListMclass(context.Context, *EmptyRequest) (*ListMclassResponse, error)
	// / Query detailed information of a module type
	GetMclassInfo(context.Context, *GetMclassInfoRequest) (*GetMclassInfoResponse, error)
	// / Remove all modules.
	// /
	// / This RPC will always succeed (unless there is a running worker)
	// /
	// / NOTE: There should be no running worker to run this command.
	ResetModules(context.Context, *EmptyRequest) (*EmptyResponse, error)
	// / Enumerate all initialized modules
	ListModules(context.Context, *EmptyRequest) (*ListModulesResponse, error)
	// / Create a new module instance from the given module type
	// /
	// / NOTE: There should be no running worker to run this command.
	CreateModule(context.Context, *CreateModuleRequest) (*CreateModuleResponse, error)
	// / Destroy an existing module
	// /
	// / If the module is connected to other modules' input/output gate, they are
	// / disconnected first. All tasks created by the module will also be destroyed.
	// /
	// / NOTE: There should be no running worker to run this command.
	DestroyModule(context.Context, *DestroyModuleRequest) (*EmptyResponse, error)
	// / Fetch detailed information of an module instance
	GetModuleInfo(context.Context, *GetModuleInfoRequest) (*GetModuleInfoResponse, error)
	// / Connect two modules.
	// /
	// / Connect between m1's ogate and n2's igate (i.e., packets sent to m1's ogate
	// / will be fed to m2's igate). The ogate can be connected to only one igate,
	// / while the igate can be connected to multiple output gates.
	// /
	// / NOTE: There should be no running worker to run this command.
	ConnectModules(context.Context, *ConnectModulesRequest) (*EmptyResponse, error)
	// / Disconnect two modules.
	// /
	// / It removes a connection between two modules (you specify the previous one
	// / and its output gate). All packets coming out from the ogate will be
	// / dropped. Once disconnected, the ogate can be connected
	// / to any input gate.
	// /
	// / NOTE: There should be no running worker to run this command.
	DisconnectModules(context.Context, *DisconnectModulesRequest) (*EmptyResponse, error)
	// / Dump various stats about BESS's packet pools
	DumpMempool(context.Context, *DumpMempoolRequest) (*DumpMempoolResponse, error)
	// / Send a command to the specified module instance.
	// /
	// / Each module type defines a list of module-specific commands, which
	// / allow external programs to communicate with the module at runtime.
	// / See module_msg.proto for details.
	// /
	// / NOTE: Some commands cannot be used if there are running workers.
	// /       For those commands you must pause all workers first.
	ModuleCommand(context.Context, *CommandRequest) (*CommandResponse, error)
	// / Enumerate all gatehook types available
	ListGateHookClass(context.Context, *EmptyRequest) (*ListGateHookClassResponse, error)
	// / Query detailed information of a gatehook type
	GetGateHookClassInfo(context.Context, *GetGateHookClassInfoRequest) (*GetGateHookClassInfoResponse, error)
	// / Enable/Disable a gate hook.
	ConfigureGateHook(context.Context, *ConfigureGateHookRequest) (*ConfigureGateHookResponse, error)
	// / Enumerate all gatehook installed
	ListGateHooks(context.Context, *EmptyRequest) (*ListGateHooksResponse, error)
	// / Send command to gate hook instance.
	GateHookCommand(context.Context, *GateHookCommandRequest) (*CommandResponse, error)
	// / Enable/Disable a resume hook.
	ConfigureResumeHook(context.Context, *ConfigureResumeHookRequest) (*CommandResponse, error)
	mustEmbedUnimplementedBESSControlServer()
}

// UnimplementedBESSControlServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBESSControlServer struct{}

func (UnimplementedBESSControlServer) GetVersion(context.Context, *EmptyRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedBESSControlServer) ResetAll(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetAll not implemented")
}
func (UnimplementedBESSControlServer) KillBess(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KillBess not implemented")
}
func (UnimplementedBESSControlServer) ImportPlugin(context.Context, *ImportPluginRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportPlugin not implemented")
}
func (UnimplementedBESSControlServer) UnloadPlugin(context.Context, *UnloadPluginRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnloadPlugin not implemented")
}
func (UnimplementedBESSControlServer) ListPlugins(context.Context, *EmptyRequest) (*ListPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPlugins not implemented")
}
func (UnimplementedBESSControlServer) PauseAll(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseAll not implemented")
}
func (UnimplementedBESSControlServer) PauseWorker(context.Context, *PauseWorkerRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseWorker not implemented")
}
func (UnimplementedBESSControlServer) ResumeWorker(context.Context, *ResumeWorkerRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeWorker not implemented")
}
func (UnimplementedBESSControlServer) ResumeAll(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeAll not implemented")
}
func (UnimplementedBESSControlServer) ResetWorkers(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetWorkers not implemented")
}
func (UnimplementedBESSControlServer) ListWorkers(context.Context, *EmptyRequest) (*ListWorkersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkers not implemented")
}
func (UnimplementedBESSControlServer) AddWorker(context.Context, *AddWorkerRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWorker not implemented")
}
func (UnimplementedBESSControlServer) DestroyWorker(context.Context, *DestroyWorkerRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorker not implemented")
}
func (UnimplementedBESSControlServer) ResetTcs(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetTcs not implemented")
}
func (UnimplementedBESSControlServer) ListTcs(context.Context, *ListTcsRequest) (*ListTcsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTcs not implemented")
}
func (UnimplementedBESSControlServer) CheckSchedulingConstraints(context.Context, *EmptyRequest) (*CheckSchedulingConstraintsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckSchedulingConstraints not implemented")
}
func (UnimplementedBESSControlServer) AddTc(context.Context, *AddTcRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTc not implemented")
}
func (UnimplementedBESSControlServer) UpdateTcParams(context.Context, *UpdateTcParamsRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTcParams not implemented")
}
func (UnimplementedBESSControlServer) UpdateTcParent(context.Context, *UpdateTcParentRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTcParent not implemented")
}
func (UnimplementedBESSControlServer) GetTcStats(context.Context, *GetTcStatsRequest) (*GetTcStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTcStats not implemented")
}
func (UnimplementedBESSControlServer) ListDrivers(context.Context, *EmptyRequest) (*ListDriversResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDrivers not implemented")
}
func (UnimplementedBESSControlServer) GetDriverInfo(context.Context, *GetDriverInfoRequest) (*GetDriverInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriverInfo not implemented")
}
func (UnimplementedBESSControlServer) ResetPorts(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPorts not implemented")
}
func (UnimplementedBESSControlServer) ListPorts(context.Context, *EmptyRequest) (*ListPortsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPorts not implemented")
}
func (UnimplementedBESSControlServer) CreatePort(context.Context, *CreatePortRequest) (*CreatePortResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePort not implemented")
}
func (UnimplementedBESSControlServer) DestroyPort(context.Context, *DestroyPortRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyPort not implemented")
}
func (UnimplementedBESSControlServer) SetPortConf(context.Context, *SetPortConfRequest) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPortConf not implemented")
}
func (UnimplementedBESSControlServer) GetPortConf(context.Context, *GetPortConfRequest) (*GetPortConfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPortConf not implemented")
}
func (UnimplementedBESSControlServer) GetPortStats(context.Context, *GetPortStatsRequest) (*GetPortStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPortStats not implemented")
}
func (UnimplementedBESSControlServer) GetLinkStatus(context.Context, *GetLinkStatusRequest) (*GetLinkStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLinkStatus not implemented")
}
func (UnimplementedBESSControlServer) ListMclass(context.Context, *EmptyRequest) (*ListMclassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMclass not implemented")
}
func (UnimplementedBESSControlServer) GetMclassInfo(context.Context, *GetMclassInfoRequest) (*GetMclassInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMclassInfo not implemented")
}
func (UnimplementedBESSControlServer) ResetModules(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetModules not implemented")
}
func (UnimplementedBESSControlServer) ListModules(context.Context, *EmptyRequest) (*ListModulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModules not implemented")
}
func (UnimplementedBESSControlServer) CreateModule(context.Context, *CreateModuleRequest) (*CreateModuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateModule not implemented")
}
func (UnimplementedBESSControlServer) DestroyModule(context.Context, *DestroyModuleRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyModule not implemented")
}
func (UnimplementedBESSControlServer) GetModuleInfo(context.Context, *GetModuleInfoRequest) (*GetModuleInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleInfo not implemented")
}
func (UnimplementedBESSControlServer) ConnectModules(context.Context, *ConnectModulesRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectModules not implemented")
}
func (UnimplementedBESSControlServer) DisconnectModules(context.Context, *DisconnectModulesRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectModules not implemented")
}
func (UnimplementedBESSControlServer) DumpMempool(context.Context, *DumpMempoolRequest) (*DumpMempoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpMempool not implemented")
}
func (UnimplementedBESSControlServer) ModuleCommand(context.Context, *CommandRequest) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleCommand not implemented")
}
func (UnimplementedBESSControlServer) ListGateHookClass(context.Context, *EmptyRequest) (*ListGateHookClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGateHookClass not implemented")
}
func (UnimplementedBESSControlServer) GetGateHookClassInfo(context.Context, *GetGateHookClassInfoRequest) (*GetGateHookClassInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGateHookClassInfo not implemented")
}
func (UnimplementedBESSControlServer) ConfigureGateHook(context.Context, *ConfigureGateHookRequest) (*ConfigureGateHookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureGateHook not implemented")
}
func (UnimplementedBESSControlServer) ListGateHooks(context.Context, *EmptyRequest) (*ListGateHooksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGateHooks not implemented")
}
func (UnimplementedBESSControlServer) GateHookCommand(context.Context, *GateHookCommandRequest) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GateHookCommand not implemented")
}
func (UnimplementedBESSControlServer) ConfigureResumeHook(context.Context, *ConfigureResumeHookRequest) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureResumeHook not implemented")
}
func (UnimplementedBESSControlServer) mustEmbedUnimplementedBESSControlServer() {}
func (UnimplementedBESSControlServer) testEmbeddedByValue()                     {}

// UnsafeBESSControlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BESSControlServer will
// result in compilation errors.
type UnsafeBESSControlServer interface {
	mustEmbedUnimplementedBESSControlServer()
}

func RegisterBESSControlServer(s grpc.ServiceRegistrar, srv BESSControlServer) {
	// If the following call panics, it indicates UnimplementedBESSControlServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BESSControl_ServiceDesc, srv)
}

func _BESSControl_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetVersion(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ResetAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_KillBess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).KillBess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_KillBess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).KillBess(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ImportPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ImportPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ImportPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ImportPlugin(ctx, req.(*ImportPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UnloadPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnloadPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UnloadPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_UnloadPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UnloadPlugin(ctx, req.(*UnloadPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListPlugins(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_PauseAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).PauseAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_PauseAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).PauseAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_PauseWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).PauseWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_PauseWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).PauseWorker(ctx, req.(*PauseWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResumeWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResumeWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ResumeWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResumeWorker(ctx, req.(*ResumeWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResumeAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResumeAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ResumeAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResumeAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ResetWorkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetWorkers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListWorkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListWorkers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_AddWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).AddWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_AddWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).AddWorker(ctx, req.(*AddWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_DestroyWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyWorker(ctx, req.(*DestroyWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetTcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetTcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ResetTcs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetTcs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListTcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListTcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListTcs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListTcs(ctx, req.(*ListTcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CheckSchedulingConstraints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CheckSchedulingConstraints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_CheckSchedulingConstraints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CheckSchedulingConstraints(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_AddTc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).AddTc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_AddTc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).AddTc(ctx, req.(*AddTcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UpdateTcParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTcParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UpdateTcParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_UpdateTcParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UpdateTcParams(ctx, req.(*UpdateTcParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UpdateTcParent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTcParentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UpdateTcParent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_UpdateTcParent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UpdateTcParent(ctx, req.(*UpdateTcParentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetTcStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTcStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetTcStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetTcStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetTcStats(ctx, req.(*GetTcStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListDrivers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListDrivers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetDriverInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDriverInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetDriverInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetDriverInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetDriverInfo(ctx, req.(*GetDriverInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ResetPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetPorts(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListPorts(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CreatePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CreatePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_CreatePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CreatePort(ctx, req.(*CreatePortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_DestroyPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyPort(ctx, req.(*DestroyPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_SetPortConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPortConfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).SetPortConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_SetPortConf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).SetPortConf(ctx, req.(*SetPortConfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetPortConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortConfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetPortConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetPortConf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetPortConf(ctx, req.(*GetPortConfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetPortStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetPortStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetPortStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetPortStats(ctx, req.(*GetPortStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetLinkStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinkStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetLinkStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetLinkStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetLinkStatus(ctx, req.(*GetLinkStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListMclass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListMclass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListMclass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListMclass(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetMclassInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMclassInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetMclassInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetMclassInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetMclassInfo(ctx, req.(*GetMclassInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ResetModules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetModules(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListModules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListModules(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CreateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CreateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_CreateModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CreateModule(ctx, req.(*CreateModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_DestroyModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyModule(ctx, req.(*DestroyModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetModuleInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModuleInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetModuleInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetModuleInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetModuleInfo(ctx, req.(*GetModuleInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConnectModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectModulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConnectModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ConnectModules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConnectModules(ctx, req.(*ConnectModulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DisconnectModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectModulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DisconnectModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_DisconnectModules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DisconnectModules(ctx, req.(*DisconnectModulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DumpMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpMempoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DumpMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_DumpMempool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DumpMempool(ctx, req.(*DumpMempoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ModuleCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ModuleCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ModuleCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ModuleCommand(ctx, req.(*CommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListGateHookClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListGateHookClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListGateHookClass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListGateHookClass(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetGateHookClassInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGateHookClassInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetGateHookClassInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GetGateHookClassInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetGateHookClassInfo(ctx, req.(*GetGateHookClassInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConfigureGateHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureGateHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConfigureGateHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ConfigureGateHook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConfigureGateHook(ctx, req.(*ConfigureGateHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListGateHooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListGateHooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ListGateHooks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListGateHooks(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GateHookCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GateHookCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GateHookCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_GateHookCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GateHookCommand(ctx, req.(*GateHookCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConfigureResumeHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureResumeHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConfigureResumeHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BESSControl_ConfigureResumeHook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConfigureResumeHook(ctx, req.(*ConfigureResumeHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BESSControl_ServiceDesc is the grpc.ServiceDesc for BESSControl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BESSControl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bess.pb.BESSControl",
	HandlerType: (*BESSControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _BESSControl_GetVersion_Handler,
		},
		{
			MethodName: "ResetAll",
			Handler:    _BESSControl_ResetAll_Handler,
		},
		{
			MethodName: "KillBess",
			Handler:    _BESSControl_KillBess_Handler,
		},
		{
			MethodName: "ImportPlugin",
			Handler:    _BESSControl_ImportPlugin_Handler,
		},
		{
			MethodName: "UnloadPlugin",
			Handler:    _BESSControl_UnloadPlugin_Handler,
		},
		{
			MethodName: "ListPlugins",
			Handler:    _BESSControl_ListPlugins_Handler,
		},
		{
			MethodName: "PauseAll",
			Handler:    _BESSControl_PauseAll_Handler,
		},
		{
			MethodName: "PauseWorker",
			Handler:    _BESSControl_PauseWorker_Handler,
		},
		{
			MethodName: "ResumeWorker",
			Handler:    _BESSControl_ResumeWorker_Handler,
		},
		{
			MethodName: "ResumeAll",
			Handler:    _BESSControl_ResumeAll_Handler,
		},
		{
			MethodName: "ResetWorkers",
			Handler:    _BESSControl_ResetWorkers_Handler,
		},
		{
			MethodName: "ListWorkers",
			Handler:    _BESSControl_ListWorkers_Handler,
		},
		{
			MethodName: "AddWorker",
			Handler:    _BESSControl_AddWorker_Handler,
		},
		{
			MethodName: "DestroyWorker",
			Handler:    _BESSControl_DestroyWorker_Handler,
		},
		{
			MethodName: "ResetTcs",
			Handler:    _BESSControl_ResetTcs_Handler,
		},
		{
			MethodName: "ListTcs",
			Handler:    _BESSControl_ListTcs_Handler,
		},
		{
			MethodName: "CheckSchedulingConstraints",
			Handler:    _BESSControl_CheckSchedulingConstraints_Handler,
		},
		{
			MethodName: "AddTc",
			Handler:    _BESSControl_AddTc_Handler,
		},
		{
			MethodName: "UpdateTcParams",
			Handler:    _BESSControl_UpdateTcParams_Handler,
		},
		{
			MethodName: "UpdateTcParent",
			Handler:    _BESSControl_UpdateTcParent_Handler,
		},
		{
			MethodName: "GetTcStats",
			Handler:    _BESSControl_GetTcStats_Handler,
		},
		{
			MethodName: "ListDrivers",
			Handler:    _BESSControl_ListDrivers_Handler,
		},
		{
			MethodName: "GetDriverInfo",
			Handler:    _BESSControl_GetDriverInfo_Handler,
		},
		{
			MethodName: "ResetPorts",
			Handler:    _BESSControl_ResetPorts_Handler,
		},
		{
			MethodName: "ListPorts",
			Handler:    _BESSControl_ListPorts_Handler,
		},
		{
			MethodName: "CreatePort",
			Handler:    _BESSControl_CreatePort_Handler,
		},
		{
			MethodName: "DestroyPort",
			Handler:    _BESSControl_DestroyPort_Handler,
		},
		{
			MethodName: "SetPortConf",
			Handler:    _BESSControl_SetPortConf_Handler,
		},
		{
			MethodName: "GetPortConf",
			Handler:    _BESSControl_GetPortConf_Handler,
		},
		{
			MethodName: "GetPortStats",
			Handler:    _BESSControl_GetPortStats_Handler,
		},
		{
			MethodName: "GetLinkStatus",
			Handler:    _BESSControl_GetLinkStatus_Handler,
		},
		{
			MethodName: "ListMclass",
			Handler:    _BESSControl_ListMclass_Handler,
		},
		{
			MethodName: "GetMclassInfo",
			Handler:    _BESSControl_GetMclassInfo_Handler,
		},
		{
			MethodName: "ResetModules",
			Handler:    _BESSControl_ResetModules_Handler,
		},
		{
			MethodName: "ListModules",
			Handler:    _BESSControl_ListModules_Handler,
		},
		{
			MethodName: "CreateModule",
			Handler:    _BESSControl_CreateModule_Handler,
		},
		{
			MethodName: "DestroyModule",
			Handler:    _BESSControl_DestroyModule_Handler,
		},
		{
			MethodName: "GetModuleInfo",
			Handler:    _BESSControl_GetModuleInfo_Handler,
		},
		{
			MethodName: "ConnectModules",
			Handler:    _BESSControl_ConnectModules_Handler,
		},
		{
			MethodName: "DisconnectModules",
			Handler:    _BESSControl_DisconnectModules_Handler,
		},
		{
			MethodName: "DumpMempool",
			Handler:    _BESSControl_DumpMempool_Handler,
		},
		{
			MethodName: "ModuleCommand",
			Handler:    _BESSControl_ModuleCommand_Handler,
		},
		{
			MethodName: "ListGateHookClass",
			Handler:    _BESSControl_ListGateHookClass_Handler,
		},
		{
			MethodName: "GetGateHookClassInfo",
			Handler:    _BESSControl_GetGateHookClassInfo_Handler,
		},
		{
			MethodName: "ConfigureGateHook",
			Handler:    _BESSControl_ConfigureGateHook_Handler,
		},
		{
			MethodName: "ListGateHooks",
			Handler:    _BESSControl_ListGateHooks_Handler,
		},
		{
			MethodName: "GateHookCommand",
			Handler:    _BESSControl_GateHookCommand_Handler,
		},
		{
			MethodName: "ConfigureResumeHook",
			Handler:    _BESSControl_ConfigureResumeHook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
