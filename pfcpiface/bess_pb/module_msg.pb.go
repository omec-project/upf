// Copyright (c) 2016-2017, Nefeli Networks, Inc.
// Copyright (c) 2017, The Regents of the University of California.
// All rights reserved.
//
// SPDX-License-Identifier: BSD-3-Clause
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
// list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// * Neither the names of the copyright holders nor the names of their
// contributors may be used to endorse or promote products derived from this
// software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: module_msg.proto

package bess_pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type EmptyArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmptyArg) Reset() {
	*x = EmptyArg{}
	mi := &file_module_msg_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmptyArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmptyArg) ProtoMessage() {}

func (x *EmptyArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmptyArg.ProtoReflect.Descriptor instead.
func (*EmptyArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{0}
}

// *
// The BPF module has a command `clear()` that takes no parameters.
// This command removes all filters from the module.
type BPFCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BPFCommandClearArg) Reset() {
	*x = BPFCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BPFCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BPFCommandClearArg) ProtoMessage() {}

func (x *BPFCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BPFCommandClearArg.ProtoReflect.Descriptor instead.
func (*BPFCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{1}
}

// *
// The ExactMatch module has a command `add(...)` that takes two parameters.
// The ExactMatch initializer specifies what fields in a packet to inspect;
// add() specifies which values to check for over these fields. add() inserts a
// new rule into the ExactMatch module such that traffic matching that
// bytestring will be forwarded out a specified gate. Example use:
// `add(fields=[aton('12.3.4.5'), aton('5.4.3.2')], gate=2)`
type ExactMatchCommandAddArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gate          uint64                 `protobuf:"varint,1,opt,name=gate,proto3" json:"gate,omitempty"`    /// The gate to forward out packets that mach this rule.
	Fields        []*FieldData           `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"` /// The exact match values to check for
	Values        []*FieldData           `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"` /// The exact match values to check for
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExactMatchCommandAddArg) Reset() {
	*x = ExactMatchCommandAddArg{}
	mi := &file_module_msg_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExactMatchCommandAddArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExactMatchCommandAddArg) ProtoMessage() {}

func (x *ExactMatchCommandAddArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExactMatchCommandAddArg.ProtoReflect.Descriptor instead.
func (*ExactMatchCommandAddArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{2}
}

func (x *ExactMatchCommandAddArg) GetGate() uint64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

func (x *ExactMatchCommandAddArg) GetFields() []*FieldData {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *ExactMatchCommandAddArg) GetValues() []*FieldData {
	if x != nil {
		return x.Values
	}
	return nil
}

// *
// The ExactMatch module has a command `delete(...)` which deletes an existing
// rule. Example use: `delete(fields=[aton('12.3.4.5'), aton('5.4.3.2')])`
type ExactMatchCommandDeleteArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fields        []*FieldData           `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"` /// The field values for the rule to be deleted.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExactMatchCommandDeleteArg) Reset() {
	*x = ExactMatchCommandDeleteArg{}
	mi := &file_module_msg_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExactMatchCommandDeleteArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExactMatchCommandDeleteArg) ProtoMessage() {}

func (x *ExactMatchCommandDeleteArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExactMatchCommandDeleteArg.ProtoReflect.Descriptor instead.
func (*ExactMatchCommandDeleteArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{3}
}

func (x *ExactMatchCommandDeleteArg) GetFields() []*FieldData {
	if x != nil {
		return x.Fields
	}
	return nil
}

// *
// The ExactMatch module has a command `clear()` which takes no parameters.
// This command removes all rules from the ExactMatch module.
type ExactMatchCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExactMatchCommandClearArg) Reset() {
	*x = ExactMatchCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExactMatchCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExactMatchCommandClearArg) ProtoMessage() {}

func (x *ExactMatchCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExactMatchCommandClearArg.ProtoReflect.Descriptor instead.
func (*ExactMatchCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{4}
}

// *
// The ExactMatch module has a command `set_default_gate(...)` which takes one
// parameter. This command routes all traffic which does _not_ match a rule to a
// specified gate. Example use in bessctl: `setDefaultGate(gate=2)`
type ExactMatchCommandSetDefaultGateArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gate          uint64                 `protobuf:"varint,1,opt,name=gate,proto3" json:"gate,omitempty"` /// The gate number to send the default traffic out.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExactMatchCommandSetDefaultGateArg) Reset() {
	*x = ExactMatchCommandSetDefaultGateArg{}
	mi := &file_module_msg_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExactMatchCommandSetDefaultGateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExactMatchCommandSetDefaultGateArg) ProtoMessage() {}

func (x *ExactMatchCommandSetDefaultGateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExactMatchCommandSetDefaultGateArg.ProtoReflect.Descriptor instead.
func (*ExactMatchCommandSetDefaultGateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{5}
}

func (x *ExactMatchCommandSetDefaultGateArg) GetGate() uint64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

// *
// The FlowGen module has a command `set_burst(...)` that allows you to specify
// the maximum number of packets to be stored in a single PacketBatch released
// by the module.
type FlowGenCommandSetBurstArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Burst         uint64                 `protobuf:"varint,1,opt,name=burst,proto3" json:"burst,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowGenCommandSetBurstArg) Reset() {
	*x = FlowGenCommandSetBurstArg{}
	mi := &file_module_msg_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowGenCommandSetBurstArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowGenCommandSetBurstArg) ProtoMessage() {}

func (x *FlowGenCommandSetBurstArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowGenCommandSetBurstArg.ProtoReflect.Descriptor instead.
func (*FlowGenCommandSetBurstArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{6}
}

func (x *FlowGenCommandSetBurstArg) GetBurst() uint64 {
	if x != nil {
		return x.Burst
	}
	return 0
}

// *
// The HashLB module has a command `set_mode(...)` which takes two parameters.
// The `mode` parameter specifies whether the load balancer will hash over the
// src/dest ethernet header (`'l2'`), over the src/dest IP addresses (`'l3'`),
// or over the flow 5-tuple (`'l4'`).  Alternatively, if the `fields` parameter
// is set, the load balancer will hash over the N-tuple with the specified
// offsets and sizes. Example use in bessctl: `lb.set_mode('l2')`
type HashLBCommandSetModeArg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Mode  string                 `protobuf:"bytes,1,opt,name=mode,proto3" json:"mode,omitempty"` /// What fields to hash over, `'l2'`, `'l3'`, and `'l4'` are
	// / only valid values.
	Fields        []*Field `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"` /// A list of fields that define a custom tuple.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HashLBCommandSetModeArg) Reset() {
	*x = HashLBCommandSetModeArg{}
	mi := &file_module_msg_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HashLBCommandSetModeArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HashLBCommandSetModeArg) ProtoMessage() {}

func (x *HashLBCommandSetModeArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HashLBCommandSetModeArg.ProtoReflect.Descriptor instead.
func (*HashLBCommandSetModeArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{7}
}

func (x *HashLBCommandSetModeArg) GetMode() string {
	if x != nil {
		return x.Mode
	}
	return ""
}

func (x *HashLBCommandSetModeArg) GetFields() []*Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

// *
// The HashLB module has a command `set_gates(...)` which takes one parameter.
// This function takes in a list of gate numbers to send hashed traffic out
// over. Example use in bessctl: `lb.setGates(gates=[0,1,2,3])`
type HashLBCommandSetGatesArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gates         []int64                `protobuf:"varint,1,rep,packed,name=gates,proto3" json:"gates,omitempty"` /// A list of gate numbers to load balance traffic over
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HashLBCommandSetGatesArg) Reset() {
	*x = HashLBCommandSetGatesArg{}
	mi := &file_module_msg_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HashLBCommandSetGatesArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HashLBCommandSetGatesArg) ProtoMessage() {}

func (x *HashLBCommandSetGatesArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HashLBCommandSetGatesArg.ProtoReflect.Descriptor instead.
func (*HashLBCommandSetGatesArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{8}
}

func (x *HashLBCommandSetGatesArg) GetGates() []int64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

// *
// The IPLookup module has a command `add(...)` which takes three paramters.
// This function accepts the routing rules -- CIDR prefix, CIDR prefix length,
// and what gate to forward matching traffic out on.
// Example use in bessctl: `table.add(prefix='10.0.0.0', prefix_len=8, gate=2)`
type IPLookupCommandAddArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Prefix        string                 `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`                         /// The CIDR IP part of the prefix to match
	PrefixLen     uint64                 `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"` /// The prefix length
	Gate          uint64                 `protobuf:"varint,3,opt,name=gate,proto3" json:"gate,omitempty"`                            /// The number of the gate to forward matching traffic on.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPLookupCommandAddArg) Reset() {
	*x = IPLookupCommandAddArg{}
	mi := &file_module_msg_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPLookupCommandAddArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPLookupCommandAddArg) ProtoMessage() {}

func (x *IPLookupCommandAddArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPLookupCommandAddArg.ProtoReflect.Descriptor instead.
func (*IPLookupCommandAddArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{9}
}

func (x *IPLookupCommandAddArg) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *IPLookupCommandAddArg) GetPrefixLen() uint64 {
	if x != nil {
		return x.PrefixLen
	}
	return 0
}

func (x *IPLookupCommandAddArg) GetGate() uint64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

// *
// The IPLookup module has a command `delete(...)` which takes two paramters.
// This function accepts the routing rules -- CIDR prefix, CIDR prefix length,
// Example use in bessctl: `table.delete(prefix='10.0.0.0', prefix_len=8)`
type IPLookupCommandDeleteArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Prefix        string                 `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`                         /// The CIDR IP part of the prefix to match
	PrefixLen     uint64                 `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"` /// The prefix length
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPLookupCommandDeleteArg) Reset() {
	*x = IPLookupCommandDeleteArg{}
	mi := &file_module_msg_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPLookupCommandDeleteArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPLookupCommandDeleteArg) ProtoMessage() {}

func (x *IPLookupCommandDeleteArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPLookupCommandDeleteArg.ProtoReflect.Descriptor instead.
func (*IPLookupCommandDeleteArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{10}
}

func (x *IPLookupCommandDeleteArg) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *IPLookupCommandDeleteArg) GetPrefixLen() uint64 {
	if x != nil {
		return x.PrefixLen
	}
	return 0
}

// *
// The IPLookup module has a command `clear()` which takes no parameters.
// This function removes all rules in the IPLookup table.
// Example use in bessctl: `myiplookuptable.clear()`
type IPLookupCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPLookupCommandClearArg) Reset() {
	*x = IPLookupCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPLookupCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPLookupCommandClearArg) ProtoMessage() {}

func (x *IPLookupCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPLookupCommandClearArg.ProtoReflect.Descriptor instead.
func (*IPLookupCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{11}
}

// *
// The L2Forward module forwards traffic via exact match over the Ethernet
// destination address. The command `add(...)`  allows you to specifiy a
// MAC address and which gate the L2Forward module should direct it out of.
type L2ForwardCommandAddArg struct {
	state         protoimpl.MessageState          `protogen:"open.v1"`
	Entries       []*L2ForwardCommandAddArg_Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"` /// A list of L2Forward entries.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L2ForwardCommandAddArg) Reset() {
	*x = L2ForwardCommandAddArg{}
	mi := &file_module_msg_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L2ForwardCommandAddArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2ForwardCommandAddArg) ProtoMessage() {}

func (x *L2ForwardCommandAddArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2ForwardCommandAddArg.ProtoReflect.Descriptor instead.
func (*L2ForwardCommandAddArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{12}
}

func (x *L2ForwardCommandAddArg) GetEntries() []*L2ForwardCommandAddArg_Entry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// *
// The L2Forward module has a function `delete(...)` to remove a rule
// from the MAC forwarding table.
type L2ForwardCommandDeleteArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Addrs         []string               `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"` /// The address to remove from the forwarding table
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L2ForwardCommandDeleteArg) Reset() {
	*x = L2ForwardCommandDeleteArg{}
	mi := &file_module_msg_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L2ForwardCommandDeleteArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2ForwardCommandDeleteArg) ProtoMessage() {}

func (x *L2ForwardCommandDeleteArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2ForwardCommandDeleteArg.ProtoReflect.Descriptor instead.
func (*L2ForwardCommandDeleteArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{13}
}

func (x *L2ForwardCommandDeleteArg) GetAddrs() []string {
	if x != nil {
		return x.Addrs
	}
	return nil
}

// *
// For traffic reaching the L2Forward module which does not match a MAC rule,
// the function `set_default_gate(...)` allows you to specify a default gate
// to direct unmatched traffic to.
type L2ForwardCommandSetDefaultGateArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gate          int64                  `protobuf:"varint,1,opt,name=gate,proto3" json:"gate,omitempty"` /// The default gate to forward traffic which matches no entry to.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L2ForwardCommandSetDefaultGateArg) Reset() {
	*x = L2ForwardCommandSetDefaultGateArg{}
	mi := &file_module_msg_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L2ForwardCommandSetDefaultGateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2ForwardCommandSetDefaultGateArg) ProtoMessage() {}

func (x *L2ForwardCommandSetDefaultGateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2ForwardCommandSetDefaultGateArg.ProtoReflect.Descriptor instead.
func (*L2ForwardCommandSetDefaultGateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{14}
}

func (x *L2ForwardCommandSetDefaultGateArg) GetGate() int64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

// *
// The L2Forward module has a function `lookup(...)` to query what output gate
// a given MAC address will be forwared to; it returns the gate ID number.
type L2ForwardCommandLookupArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Addrs         []string               `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"` /// The MAC address to query for
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L2ForwardCommandLookupArg) Reset() {
	*x = L2ForwardCommandLookupArg{}
	mi := &file_module_msg_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L2ForwardCommandLookupArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2ForwardCommandLookupArg) ProtoMessage() {}

func (x *L2ForwardCommandLookupArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2ForwardCommandLookupArg.ProtoReflect.Descriptor instead.
func (*L2ForwardCommandLookupArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{15}
}

func (x *L2ForwardCommandLookupArg) GetAddrs() []string {
	if x != nil {
		return x.Addrs
	}
	return nil
}

// *
// This message type provides the reponse to the L2Forward function
// `lookup(..)`. It returns the gate that a requested MAC address is currently
// assigned to.
type L2ForwardCommandLookupResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gates         []uint64               `protobuf:"varint,1,rep,packed,name=gates,proto3" json:"gates,omitempty"` /// The gate ID that the requested MAC address maps to
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L2ForwardCommandLookupResponse) Reset() {
	*x = L2ForwardCommandLookupResponse{}
	mi := &file_module_msg_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L2ForwardCommandLookupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2ForwardCommandLookupResponse) ProtoMessage() {}

func (x *L2ForwardCommandLookupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2ForwardCommandLookupResponse.ProtoReflect.Descriptor instead.
func (*L2ForwardCommandLookupResponse) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{16}
}

func (x *L2ForwardCommandLookupResponse) GetGates() []uint64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

// *
// The L2Forward module has a command `populate(...)` which allows for fast
// creation of the forwarding table given a range of MAC addresses. The function
// takes in a 'base' MAC address, a count (number of MAC addresses), and a
// gate_id. The module will route all MAC addresses starting from the base
// address, up to base+count address round-robin over gate_count total gates.
// For example, `populate(base='11:22:33:44:00', count = 10, gate_count = 2)`
// would route addresses `11:22:33:44::(00, 02, 04, 06, 08)` out a gate 0 and
// the odd-suffixed addresses out gate 1.
type L2ForwardCommandPopulateArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          string                 `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`                             /// The base MAC address
	Count         int64                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`                          /// How many addresses beyond base to populate into the routing table
	GateCount     int64                  `protobuf:"varint,3,opt,name=gate_count,json=gateCount,proto3" json:"gate_count,omitempty"` /// How many gates to create in the L2Forward module.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L2ForwardCommandPopulateArg) Reset() {
	*x = L2ForwardCommandPopulateArg{}
	mi := &file_module_msg_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L2ForwardCommandPopulateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2ForwardCommandPopulateArg) ProtoMessage() {}

func (x *L2ForwardCommandPopulateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2ForwardCommandPopulateArg.ProtoReflect.Descriptor instead.
func (*L2ForwardCommandPopulateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{17}
}

func (x *L2ForwardCommandPopulateArg) GetBase() string {
	if x != nil {
		return x.Base
	}
	return ""
}

func (x *L2ForwardCommandPopulateArg) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *L2ForwardCommandPopulateArg) GetGateCount() int64 {
	if x != nil {
		return x.GateCount
	}
	return 0
}

// *
// The Measure module measures and collects latency/jitter data for packets
// annotated by a Timestamp module. Note that Timestamp and Measure module must
// reside on the server for accurate measurement (as a result, the most typical
// use case is measuring roundtrip time). Optionally, you can also retrieve
// percentile values by specifying points in "percentiles". For example,
// "percentiles" of [50.0, 99.0] will return [median, 99'th %-ile tail latency]
// in "percentile_values_ns" in the response.
type MeasureCommandGetSummaryArg struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Clear              bool                   `protobuf:"varint,1,opt,name=clear,proto3" json:"clear,omitempty"`                                                             /// if true, the data will be all cleared after read
	LatencyPercentiles []float64              `protobuf:"fixed64,2,rep,packed,name=latency_percentiles,json=latencyPercentiles,proto3" json:"latency_percentiles,omitempty"` /// ascending list of real numbers in [0.0, 100.0]
	JitterPercentiles  []float64              `protobuf:"fixed64,3,rep,packed,name=jitter_percentiles,json=jitterPercentiles,proto3" json:"jitter_percentiles,omitempty"`    /// ascending list of real numbers in [0.0, 100.0]
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *MeasureCommandGetSummaryArg) Reset() {
	*x = MeasureCommandGetSummaryArg{}
	mi := &file_module_msg_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MeasureCommandGetSummaryArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeasureCommandGetSummaryArg) ProtoMessage() {}

func (x *MeasureCommandGetSummaryArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeasureCommandGetSummaryArg.ProtoReflect.Descriptor instead.
func (*MeasureCommandGetSummaryArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{18}
}

func (x *MeasureCommandGetSummaryArg) GetClear() bool {
	if x != nil {
		return x.Clear
	}
	return false
}

func (x *MeasureCommandGetSummaryArg) GetLatencyPercentiles() []float64 {
	if x != nil {
		return x.LatencyPercentiles
	}
	return nil
}

func (x *MeasureCommandGetSummaryArg) GetJitterPercentiles() []float64 {
	if x != nil {
		return x.JitterPercentiles
	}
	return nil
}

// *
// The Measure module function `get_summary()` returns the following values.
// Note that the resolution value tells you how grainy the samples are,
// e.g., 100 means that anything from 0-99 ns counts as "0",
// anything from 100-199 counts as "100", and so on.  The average
// is of samples using this graininess, but (being a result of division)
// may not be a multiple of the resolution.
type MeasureCommandGetSummaryResponse struct {
	state         protoimpl.MessageState                      `protogen:"open.v1"`
	Timestamp     float64                                     `protobuf:"fixed64,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"` /// Seconds since boot.
	Packets       uint64                                      `protobuf:"varint,2,opt,name=packets,proto3" json:"packets,omitempty"`      /// Total # of packets seen by this module.
	Bits          uint64                                      `protobuf:"varint,3,opt,name=bits,proto3" json:"bits,omitempty"`            /// Total # of bits seen by this module.
	Latency       *MeasureCommandGetSummaryResponse_Histogram `protobuf:"bytes,4,opt,name=latency,proto3" json:"latency,omitempty"`
	Jitter        *MeasureCommandGetSummaryResponse_Histogram `protobuf:"bytes,5,opt,name=jitter,proto3" json:"jitter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MeasureCommandGetSummaryResponse) Reset() {
	*x = MeasureCommandGetSummaryResponse{}
	mi := &file_module_msg_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MeasureCommandGetSummaryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeasureCommandGetSummaryResponse) ProtoMessage() {}

func (x *MeasureCommandGetSummaryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeasureCommandGetSummaryResponse.ProtoReflect.Descriptor instead.
func (*MeasureCommandGetSummaryResponse) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{19}
}

func (x *MeasureCommandGetSummaryResponse) GetTimestamp() float64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse) GetPackets() uint64 {
	if x != nil {
		return x.Packets
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse) GetBits() uint64 {
	if x != nil {
		return x.Bits
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse) GetLatency() *MeasureCommandGetSummaryResponse_Histogram {
	if x != nil {
		return x.Latency
	}
	return nil
}

func (x *MeasureCommandGetSummaryResponse) GetJitter() *MeasureCommandGetSummaryResponse_Histogram {
	if x != nil {
		return x.Jitter
	}
	return nil
}

// *
// The Module DRR provides fair scheduling of flows based on a quantum which is
// number of bytes allocated to each flow on each round of going through all
// flows. Examples can be found [./bessctl/conf/samples/drr.bess]
//
// __Input_Gates__: 1
// __Output_Gates__:  1
type DRRArg struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	NumFlows         uint32                 `protobuf:"varint,1,opt,name=num_flows,json=numFlows,proto3" json:"num_flows,omitempty"`                             /// Number of flows to handle in module
	Quantum          uint64                 `protobuf:"varint,2,opt,name=quantum,proto3" json:"quantum,omitempty"`                                               /// the number of bytes to allocate to each on every round
	MaxFlowQueueSize uint32                 `protobuf:"varint,3,opt,name=max_flow_queue_size,json=maxFlowQueueSize,proto3" json:"max_flow_queue_size,omitempty"` /// the max size that any Flows queue can get
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DRRArg) Reset() {
	*x = DRRArg{}
	mi := &file_module_msg_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DRRArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DRRArg) ProtoMessage() {}

func (x *DRRArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DRRArg.ProtoReflect.Descriptor instead.
func (*DRRArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{20}
}

func (x *DRRArg) GetNumFlows() uint32 {
	if x != nil {
		return x.NumFlows
	}
	return 0
}

func (x *DRRArg) GetQuantum() uint64 {
	if x != nil {
		return x.Quantum
	}
	return 0
}

func (x *DRRArg) GetMaxFlowQueueSize() uint32 {
	if x != nil {
		return x.MaxFlowQueueSize
	}
	return 0
}

// *
// the SetQuantumSize function sets a new quantum for DRR module to operate on.
type DRRQuantumArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Quantum       uint32                 `protobuf:"varint,1,opt,name=quantum,proto3" json:"quantum,omitempty"` /// the number of bytes to allocate to each on every round
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DRRQuantumArg) Reset() {
	*x = DRRQuantumArg{}
	mi := &file_module_msg_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DRRQuantumArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DRRQuantumArg) ProtoMessage() {}

func (x *DRRQuantumArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DRRQuantumArg.ProtoReflect.Descriptor instead.
func (*DRRQuantumArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{21}
}

func (x *DRRQuantumArg) GetQuantum() uint32 {
	if x != nil {
		return x.Quantum
	}
	return 0
}

// *
// The SetMaxQueueSize function sets a new maximum flow queue size for DRR
// module. If the flow's queue gets to this size, the module starts dropping
// packets to that flow until the queue is below this size.
type DRRMaxFlowQueueSizeArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MaxQueueSize  uint32                 `protobuf:"varint,1,opt,name=max_queue_size,json=maxQueueSize,proto3" json:"max_queue_size,omitempty"` /// the max size that any Flows queue can get
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DRRMaxFlowQueueSizeArg) Reset() {
	*x = DRRMaxFlowQueueSizeArg{}
	mi := &file_module_msg_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DRRMaxFlowQueueSizeArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DRRMaxFlowQueueSizeArg) ProtoMessage() {}

func (x *DRRMaxFlowQueueSizeArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DRRMaxFlowQueueSizeArg.ProtoReflect.Descriptor instead.
func (*DRRMaxFlowQueueSizeArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{22}
}

func (x *DRRMaxFlowQueueSizeArg) GetMaxQueueSize() uint32 {
	if x != nil {
		return x.MaxQueueSize
	}
	return 0
}

// *
// The module PortInc has a function `set_burst(...)` that allows you to specify
// the maximum number of packets to be stored in a single PacketBatch released
// by the module.
type PortIncCommandSetBurstArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Burst         uint64                 `protobuf:"varint,1,opt,name=burst,proto3" json:"burst,omitempty"` /// The maximum "burst" of packets (ie, the maximum batch size)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortIncCommandSetBurstArg) Reset() {
	*x = PortIncCommandSetBurstArg{}
	mi := &file_module_msg_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortIncCommandSetBurstArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortIncCommandSetBurstArg) ProtoMessage() {}

func (x *PortIncCommandSetBurstArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortIncCommandSetBurstArg.ProtoReflect.Descriptor instead.
func (*PortIncCommandSetBurstArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{23}
}

func (x *PortIncCommandSetBurstArg) GetBurst() uint64 {
	if x != nil {
		return x.Burst
	}
	return 0
}

// *
// The module QueueInc has a function `set_burst(...)` that allows you to
// specify the maximum number of packets to be stored in a single PacketBatch
// released by the module.
type QueueIncCommandSetBurstArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Burst         uint64                 `protobuf:"varint,1,opt,name=burst,proto3" json:"burst,omitempty"` /// The maximum "burst" of packets (ie, the maximum batch size)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueIncCommandSetBurstArg) Reset() {
	*x = QueueIncCommandSetBurstArg{}
	mi := &file_module_msg_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueIncCommandSetBurstArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueIncCommandSetBurstArg) ProtoMessage() {}

func (x *QueueIncCommandSetBurstArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueIncCommandSetBurstArg.ProtoReflect.Descriptor instead.
func (*QueueIncCommandSetBurstArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{24}
}

func (x *QueueIncCommandSetBurstArg) GetBurst() uint64 {
	if x != nil {
		return x.Burst
	}
	return 0
}

// *
// The module Queue has a function `set_burst(...)` that allows you to specify
// the maximum number of packets to be stored in a single PacketBatch released
// by the module.
type QueueCommandSetBurstArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Burst         uint64                 `protobuf:"varint,1,opt,name=burst,proto3" json:"burst,omitempty"` /// The maximum "burst" of packets (ie, the maximum batch size)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueCommandSetBurstArg) Reset() {
	*x = QueueCommandSetBurstArg{}
	mi := &file_module_msg_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueCommandSetBurstArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueCommandSetBurstArg) ProtoMessage() {}

func (x *QueueCommandSetBurstArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueCommandSetBurstArg.ProtoReflect.Descriptor instead.
func (*QueueCommandSetBurstArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{25}
}

func (x *QueueCommandSetBurstArg) GetBurst() uint64 {
	if x != nil {
		return x.Burst
	}
	return 0
}

// *
// The module Queue has a function `set_size(...)` that allows specifying the
// size of the queue in total number of packets.
type QueueCommandSetSizeArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Size          uint64                 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"` /// The maximum number of packets to store in the queue.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueCommandSetSizeArg) Reset() {
	*x = QueueCommandSetSizeArg{}
	mi := &file_module_msg_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueCommandSetSizeArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueCommandSetSizeArg) ProtoMessage() {}

func (x *QueueCommandSetSizeArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueCommandSetSizeArg.ProtoReflect.Descriptor instead.
func (*QueueCommandSetSizeArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{26}
}

func (x *QueueCommandSetSizeArg) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

// *
// Modules that are queues or contain queues may contain functions
// `get_status()` that return QueueCommandGetStatusResponse.
type QueueCommandGetStatusArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueCommandGetStatusArg) Reset() {
	*x = QueueCommandGetStatusArg{}
	mi := &file_module_msg_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueCommandGetStatusArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueCommandGetStatusArg) ProtoMessage() {}

func (x *QueueCommandGetStatusArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueCommandGetStatusArg.ProtoReflect.Descriptor instead.
func (*QueueCommandGetStatusArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{27}
}

// *
// Modules that are queues or contain queues may contain functions
// `get_status()` that take no parameters and returns the queue occupancy and
// size.
type QueueCommandGetStatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Count         uint64                 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`       /// The number of packets currently in the queue.
	Size          uint64                 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`         /// The maximum number of packets the queue can contain.
	Enqueued      uint64                 `protobuf:"varint,3,opt,name=enqueued,proto3" json:"enqueued,omitempty"` /// total enqueued
	Dequeued      uint64                 `protobuf:"varint,4,opt,name=dequeued,proto3" json:"dequeued,omitempty"` /// total dequeued
	Dropped       uint64                 `protobuf:"varint,5,opt,name=dropped,proto3" json:"dropped,omitempty"`   /// total dropped
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueCommandGetStatusResponse) Reset() {
	*x = QueueCommandGetStatusResponse{}
	mi := &file_module_msg_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueCommandGetStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueCommandGetStatusResponse) ProtoMessage() {}

func (x *QueueCommandGetStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueCommandGetStatusResponse.ProtoReflect.Descriptor instead.
func (*QueueCommandGetStatusResponse) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{28}
}

func (x *QueueCommandGetStatusResponse) GetCount() uint64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *QueueCommandGetStatusResponse) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *QueueCommandGetStatusResponse) GetEnqueued() uint64 {
	if x != nil {
		return x.Enqueued
	}
	return 0
}

func (x *QueueCommandGetStatusResponse) GetDequeued() uint64 {
	if x != nil {
		return x.Dequeued
	}
	return 0
}

func (x *QueueCommandGetStatusResponse) GetDropped() uint64 {
	if x != nil {
		return x.Dropped
	}
	return 0
}

// *
// The function `clear()` for RandomUpdate takes no parameters and clears all
// state in the module.
type RandomUpdateCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RandomUpdateCommandClearArg) Reset() {
	*x = RandomUpdateCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RandomUpdateCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RandomUpdateCommandClearArg) ProtoMessage() {}

func (x *RandomUpdateCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RandomUpdateCommandClearArg.ProtoReflect.Descriptor instead.
func (*RandomUpdateCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{29}
}

// *
// The function `clear()` for Rewrite takes no parameters and clears all state
// in the module.
type RewriteCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RewriteCommandClearArg) Reset() {
	*x = RewriteCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RewriteCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RewriteCommandClearArg) ProtoMessage() {}

func (x *RewriteCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RewriteCommandClearArg.ProtoReflect.Descriptor instead.
func (*RewriteCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{30}
}

// *
// The function `clear()` for Update takes no parameters and clears all state in
// the module.
type UpdateCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateCommandClearArg) Reset() {
	*x = UpdateCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateCommandClearArg) ProtoMessage() {}

func (x *UpdateCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateCommandClearArg.ProtoReflect.Descriptor instead.
func (*UpdateCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{31}
}

// *
// The module WildcardMatch has a command `add(...)` which inserts a new rule
// into the WildcardMatch module. For an example of code using WilcardMatch see
// `bess/bessctl/conf/samples/wildcardmatch.bess`.
type WildcardMatchCommandAddArg struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Gate     uint64                 `protobuf:"varint,1,opt,name=gate,proto3" json:"gate,omitempty"`         /// Traffic matching this new rule will be sent to this gate.
	Priority int64                  `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"` /// If a packet matches multiple rules, the rule with higher priority
	// / will be applied. If priorities are equal behavior is undefined.
	Values []*FieldData `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"` /// The values to check for in each field.
	Masks  []*FieldData `protobuf:"bytes,4,rep,name=masks,proto3" json:"masks,omitempty"`   /// The bitmask for each field -- set `0x0` to
	// / ignore the field altogether.
	Valuesv       []*FieldData `protobuf:"bytes,5,rep,name=valuesv,proto3" json:"valuesv,omitempty"` /// The values to check for in each fieldv.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WildcardMatchCommandAddArg) Reset() {
	*x = WildcardMatchCommandAddArg{}
	mi := &file_module_msg_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WildcardMatchCommandAddArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WildcardMatchCommandAddArg) ProtoMessage() {}

func (x *WildcardMatchCommandAddArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WildcardMatchCommandAddArg.ProtoReflect.Descriptor instead.
func (*WildcardMatchCommandAddArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{32}
}

func (x *WildcardMatchCommandAddArg) GetGate() uint64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

func (x *WildcardMatchCommandAddArg) GetPriority() int64 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *WildcardMatchCommandAddArg) GetValues() []*FieldData {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *WildcardMatchCommandAddArg) GetMasks() []*FieldData {
	if x != nil {
		return x.Masks
	}
	return nil
}

func (x *WildcardMatchCommandAddArg) GetValuesv() []*FieldData {
	if x != nil {
		return x.Valuesv
	}
	return nil
}

// *
// The module WildcardMatch has a command `delete(...)` which removes a rule --
// simply specify the values and masks from the previously inserted rule to
// remove them.
type WildcardMatchCommandDeleteArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []*FieldData           `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"` /// The values being checked for in the rule
	Masks         []*FieldData           `protobuf:"bytes,2,rep,name=masks,proto3" json:"masks,omitempty"`   /// The bitmask from the rule.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WildcardMatchCommandDeleteArg) Reset() {
	*x = WildcardMatchCommandDeleteArg{}
	mi := &file_module_msg_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WildcardMatchCommandDeleteArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WildcardMatchCommandDeleteArg) ProtoMessage() {}

func (x *WildcardMatchCommandDeleteArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WildcardMatchCommandDeleteArg.ProtoReflect.Descriptor instead.
func (*WildcardMatchCommandDeleteArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{33}
}

func (x *WildcardMatchCommandDeleteArg) GetValues() []*FieldData {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *WildcardMatchCommandDeleteArg) GetMasks() []*FieldData {
	if x != nil {
		return x.Masks
	}
	return nil
}

// *
// The function `clear()` for WildcardMatch takes no parameters, it clears
// all state in the WildcardMatch module (is equivalent to calling delete for
// all rules)
type WildcardMatchCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WildcardMatchCommandClearArg) Reset() {
	*x = WildcardMatchCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WildcardMatchCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WildcardMatchCommandClearArg) ProtoMessage() {}

func (x *WildcardMatchCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WildcardMatchCommandClearArg.ProtoReflect.Descriptor instead.
func (*WildcardMatchCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{34}
}

// *
// For traffic which does not match any rule in the WildcardMatch module,
// the `set_default_gate(...)` function specifies which gate to send this extra
// traffic to.
type WildcardMatchCommandSetDefaultGateArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gate          uint64                 `protobuf:"varint,1,opt,name=gate,proto3" json:"gate,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WildcardMatchCommandSetDefaultGateArg) Reset() {
	*x = WildcardMatchCommandSetDefaultGateArg{}
	mi := &file_module_msg_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WildcardMatchCommandSetDefaultGateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WildcardMatchCommandSetDefaultGateArg) ProtoMessage() {}

func (x *WildcardMatchCommandSetDefaultGateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WildcardMatchCommandSetDefaultGateArg.ProtoReflect.Descriptor instead.
func (*WildcardMatchCommandSetDefaultGateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{35}
}

func (x *WildcardMatchCommandSetDefaultGateArg) GetGate() uint64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

// *
// The module ACL creates an access control module which by default blocks all
// traffic, unless it contains a rule which specifies otherwise. Examples of ACL
// can be found in
// [acl.bess](https://github.com/omec-project/bess/blob/master/bessctl/conf/samples/acl.bess)
//
// __Input Gates__: 1
// __Output Gates__: 1
type ACLArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*ACLArg_Rule         `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"` /// A list of ACL rules.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ACLArg) Reset() {
	*x = ACLArg{}
	mi := &file_module_msg_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ACLArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ACLArg) ProtoMessage() {}

func (x *ACLArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ACLArg.ProtoReflect.Descriptor instead.
func (*ACLArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{36}
}

func (x *ACLArg) GetRules() []*ACLArg_Rule {
	if x != nil {
		return x.Rules
	}
	return nil
}

// *
// The BPF module is an access control module that sends packets out on a
// particular gate based on whether they match a BPF filter.
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type BPFArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Filters       []*BPFArg_Filter       `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"` /// The BPF initialized function takes a list of BPF filters.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BPFArg) Reset() {
	*x = BPFArg{}
	mi := &file_module_msg_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BPFArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BPFArg) ProtoMessage() {}

func (x *BPFArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BPFArg.ProtoReflect.Descriptor instead.
func (*BPFArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{37}
}

func (x *BPFArg) GetFilters() []*BPFArg_Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

// *
// The Buffer module takes no parameters to initialize (ie, `Buffer()` is
// sufficient to create one). Buffer accepts packets and stores them; it may
// forward them to the next module only after it has received enough packets to
// fill an entire PacketBatch.
//
// __Input Gates__: 1
// __Output Gates__: 1
type BufferArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BufferArg) Reset() {
	*x = BufferArg{}
	mi := &file_module_msg_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BufferArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BufferArg) ProtoMessage() {}

func (x *BufferArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BufferArg.ProtoReflect.Descriptor instead.
func (*BufferArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{38}
}

// *
// The Bypass module forwards packets by emulating pre-defined packet processing
// overhead. It burns cpu cycles per_batch, per_packet, and per-bytes. Bypass is
// useful primarily for testing and performance evaluation.
//
// __Input Gates__: 1
// __Output Gates__: 1
type BypassArg struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	CyclesPerBatch  uint32                 `protobuf:"varint,1,opt,name=cycles_per_batch,json=cyclesPerBatch,proto3" json:"cycles_per_batch,omitempty"`
	CyclesPerPacket uint32                 `protobuf:"varint,2,opt,name=cycles_per_packet,json=cyclesPerPacket,proto3" json:"cycles_per_packet,omitempty"`
	CyclesPerByte   uint32                 `protobuf:"varint,3,opt,name=cycles_per_byte,json=cyclesPerByte,proto3" json:"cycles_per_byte,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BypassArg) Reset() {
	*x = BypassArg{}
	mi := &file_module_msg_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BypassArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BypassArg) ProtoMessage() {}

func (x *BypassArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BypassArg.ProtoReflect.Descriptor instead.
func (*BypassArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{39}
}

func (x *BypassArg) GetCyclesPerBatch() uint32 {
	if x != nil {
		return x.CyclesPerBatch
	}
	return 0
}

func (x *BypassArg) GetCyclesPerPacket() uint32 {
	if x != nil {
		return x.CyclesPerPacket
	}
	return 0
}

func (x *BypassArg) GetCyclesPerByte() uint32 {
	if x != nil {
		return x.CyclesPerByte
	}
	return 0
}

// *
// The Dump module blindly forwards packets without modifying them. It
// periodically samples a packet and prints out out to the BESS log (by default
// stored in `/tmp/bessd.INFO`).
//
// __Input Gates__: 1
// __Output Gates__: 1
type DumpArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Interval      float64                `protobuf:"fixed64,1,opt,name=interval,proto3" json:"interval,omitempty"` /// How frequently to sample and print a packet, in seconds.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DumpArg) Reset() {
	*x = DumpArg{}
	mi := &file_module_msg_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DumpArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DumpArg) ProtoMessage() {}

func (x *DumpArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DumpArg.ProtoReflect.Descriptor instead.
func (*DumpArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{40}
}

func (x *DumpArg) GetInterval() float64 {
	if x != nil {
		return x.Interval
	}
	return 0
}

// *
// The EtherEncap module wraps packets in an Ethernet header, but it takes no
// parameters. Instead, Ethernet source, destination, and type are pulled from a
// packet's metadata attributes. For example: `SetMetadata('dst_mac',
// 11:22:33:44:55) -> EtherEncap()` This is useful when upstream modules wish to
// assign a MAC address to a packet, e.g., due to an ARP request.
//
// __Input Gates__: 1
// __Output Gates__: 1
type EtherEncapArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EtherEncapArg) Reset() {
	*x = EtherEncapArg{}
	mi := &file_module_msg_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EtherEncapArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EtherEncapArg) ProtoMessage() {}

func (x *EtherEncapArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EtherEncapArg.ProtoReflect.Descriptor instead.
func (*EtherEncapArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{41}
}

// *
// The ExactMatch module splits packets along output gates according to exact
// match values in arbitrary packet fields. To instantiate an ExactMatch module,
// you must specify which fields in the packet to match over. You can add rules
// using the function `ExactMatch.add(...)` Fields may be stored either in the
// packet data or its metadata attributes. An example script using the
// ExactMatch code is found in
// [`bess/bessctl/conf/samples/exactmatch.bess`](https://github.com/omec-project/bess/blob/master/bessctl/conf/samples/exactmatch.bess).
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type ExactMatchArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fields        []*Field               `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"` /// A list of ExactMatch Fields
	Masks         []*FieldData           `protobuf:"bytes,2,rep,name=masks,proto3" json:"masks,omitempty"`   /// mask(i) corresponds to the mask for field(i)
	Values        []*Field               `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"` /// A list of ExactMatch Values
	Masksv        []*FieldData           `protobuf:"bytes,4,rep,name=masksv,proto3" json:"masksv,omitempty"` /// mask(i) corresponds to the mask for value(i)
	Entries       uint64                 `protobuf:"varint,5,opt,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExactMatchArg) Reset() {
	*x = ExactMatchArg{}
	mi := &file_module_msg_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExactMatchArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExactMatchArg) ProtoMessage() {}

func (x *ExactMatchArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExactMatchArg.ProtoReflect.Descriptor instead.
func (*ExactMatchArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{42}
}

func (x *ExactMatchArg) GetFields() []*Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *ExactMatchArg) GetMasks() []*FieldData {
	if x != nil {
		return x.Masks
	}
	return nil
}

func (x *ExactMatchArg) GetValues() []*Field {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *ExactMatchArg) GetMasksv() []*FieldData {
	if x != nil {
		return x.Masksv
	}
	return nil
}

func (x *ExactMatchArg) GetEntries() uint64 {
	if x != nil {
		return x.Entries
	}
	return 0
}

// *
// ExactMatchConfig represents the current runtime configuration
// of an ExactMatch module, as returned by get_runtime_config and
// set by set_runtime_config.
type ExactMatchConfig struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	DefaultGate   uint64                     `protobuf:"varint,1,opt,name=default_gate,json=defaultGate,proto3" json:"default_gate,omitempty"`
	Rules         []*ExactMatchCommandAddArg `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExactMatchConfig) Reset() {
	*x = ExactMatchConfig{}
	mi := &file_module_msg_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExactMatchConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExactMatchConfig) ProtoMessage() {}

func (x *ExactMatchConfig) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExactMatchConfig.ProtoReflect.Descriptor instead.
func (*ExactMatchConfig) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{43}
}

func (x *ExactMatchConfig) GetDefaultGate() uint64 {
	if x != nil {
		return x.DefaultGate
	}
	return 0
}

func (x *ExactMatchConfig) GetRules() []*ExactMatchCommandAddArg {
	if x != nil {
		return x.Rules
	}
	return nil
}

// *
// The FlowGen module generates simulated TCP flows of packets with correct
// SYN/FIN flags and sequence numbers. This module is useful for testing, e.g.,
// a NAT module or other flow-aware code. Packets are generated off a base,
// "template" packet by modifying the IP src/dst and TCP src/dst. By default,
// only the ports are changed and will be modified by incrementing the template
// ports by up to 20000 more than the template values.
//
// __Input Gates__: 0
// __Output Gates__: 1
type FlowGenArg struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Template []byte                 `protobuf:"bytes,1,opt,name=template,proto3" json:"template,omitempty"` /// The packet "template". All data packets are derived
	// / from this template and contain the same payload.
	Pps      float64 `protobuf:"fixed64,2,opt,name=pps,proto3" json:"pps,omitempty"`                           /// The total number of packets per second to generate.
	FlowRate float64 `protobuf:"fixed64,3,opt,name=flow_rate,json=flowRate,proto3" json:"flow_rate,omitempty"` /// The number of new flows to create every second.
	// / flow_rate must be <= pps.
	FlowDuration float64 `protobuf:"fixed64,4,opt,name=flow_duration,json=flowDuration,proto3" json:"flow_duration,omitempty"` /// The lifetime of a flow in seconds.
	Arrival      string  `protobuf:"bytes,5,opt,name=arrival,proto3" json:"arrival,omitempty"`                                 /// The packet arrival distribution -- must be either
	// / "uniform" or "exponential"
	Duration string `protobuf:"bytes,6,opt,name=duration,proto3" json:"duration,omitempty"` /// The flow duration distribution -- must be either
	// / "uniform" or "pareto"
	QuickRampup bool `protobuf:"varint,7,opt,name=quick_rampup,json=quickRampup,proto3" json:"quick_rampup,omitempty"` /// Whether or not to populate the flowgenerator with initial flows
	// / (start generating full pps rate immediately) or to wait for new
	// / flows to be generated naturally (all flows have a SYN packet).
	IpSrcRange uint32 `protobuf:"varint,8,opt,name=ip_src_range,json=ipSrcRange,proto3" json:"ip_src_range,omitempty"` /// When generating new flows, FlowGen modifies the template packet by
	// / changing the IP src, incrementing it by at most ip_src_range
	// / (e.g., if the base packet is 10.0.0.1 and range is 5, it will
	// / generate packets with IPs 10.0.0.1-10.0.0.6).
	IpDstRange uint32 `protobuf:"varint,9,opt,name=ip_dst_range,json=ipDstRange,proto3" json:"ip_dst_range,omitempty"` /// When generating new flows, FlowGen modifies the template packet by
	// / changing the IP dst, incrementing it by at most ip_dst_range.
	PortSrcRange uint32 `protobuf:"varint,10,opt,name=port_src_range,json=portSrcRange,proto3" json:"port_src_range,omitempty"` /// When generating new flows, FlowGen modifies
	// / the template packet by changing the TCP port,
	// / incrementing it by at most port_src_range.
	PortDstRange  uint32 `protobuf:"varint,11,opt,name=port_dst_range,json=portDstRange,proto3" json:"port_dst_range,omitempty"` /// When generating new flows, FlowGen modifies the template packet
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowGenArg) Reset() {
	*x = FlowGenArg{}
	mi := &file_module_msg_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowGenArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowGenArg) ProtoMessage() {}

func (x *FlowGenArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowGenArg.ProtoReflect.Descriptor instead.
func (*FlowGenArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{44}
}

func (x *FlowGenArg) GetTemplate() []byte {
	if x != nil {
		return x.Template
	}
	return nil
}

func (x *FlowGenArg) GetPps() float64 {
	if x != nil {
		return x.Pps
	}
	return 0
}

func (x *FlowGenArg) GetFlowRate() float64 {
	if x != nil {
		return x.FlowRate
	}
	return 0
}

func (x *FlowGenArg) GetFlowDuration() float64 {
	if x != nil {
		return x.FlowDuration
	}
	return 0
}

func (x *FlowGenArg) GetArrival() string {
	if x != nil {
		return x.Arrival
	}
	return ""
}

func (x *FlowGenArg) GetDuration() string {
	if x != nil {
		return x.Duration
	}
	return ""
}

func (x *FlowGenArg) GetQuickRampup() bool {
	if x != nil {
		return x.QuickRampup
	}
	return false
}

func (x *FlowGenArg) GetIpSrcRange() uint32 {
	if x != nil {
		return x.IpSrcRange
	}
	return 0
}

func (x *FlowGenArg) GetIpDstRange() uint32 {
	if x != nil {
		return x.IpDstRange
	}
	return 0
}

func (x *FlowGenArg) GetPortSrcRange() uint32 {
	if x != nil {
		return x.PortSrcRange
	}
	return 0
}

func (x *FlowGenArg) GetPortDstRange() uint32 {
	if x != nil {
		return x.PortDstRange
	}
	return 0
}

// *
// The GenericDecap module strips off the first few bytes of data from a packet.
//
// __Input Gates__: 1
// __Ouptut Gates__: 1
type GenericDecapArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Bytes         uint64                 `protobuf:"varint,1,opt,name=bytes,proto3" json:"bytes,omitempty"` /// The number of bytes to strip off.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GenericDecapArg) Reset() {
	*x = GenericDecapArg{}
	mi := &file_module_msg_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenericDecapArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenericDecapArg) ProtoMessage() {}

func (x *GenericDecapArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenericDecapArg.ProtoReflect.Descriptor instead.
func (*GenericDecapArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{45}
}

func (x *GenericDecapArg) GetBytes() uint64 {
	if x != nil {
		return x.Bytes
	}
	return 0
}

// *
// The GenericEncap module adds a header to packets passing through it.
// Takes a list of fields. Each field is either:
//
//  1. {'size': X, 'value': Y}          (for constant values)
//  2. {'size': X, 'attribute': Y}      (for metadata attributes)
//
// e.g.: `GenericEncap([{'size': 4, 'value': 0xdeadbeef},
//
//	{'size': 2, 'attribute': 'foo'},
//	{'size': 2, 'value': 0x1234}])`
//
// will prepend a 8-byte header:
//
//	`de ad be ef <xx> <xx> 12 34`
//
// where the 2-byte `<xx> <xx>` comes from the value of metadata attribute
// `'foo'` for each packet. An example script using GenericEncap is in
// [`bess/bessctl/conf/samples/generic_encap.bess`](https://github.com/omec-project/bess/blob/master/bessctl/conf/samples/generic_encap.bess).
//
// __Input Gates__: 1
// __Output Gates__: 1
type GenericEncapArg struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	Fields        []*GenericEncapArg_EncapField `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GenericEncapArg) Reset() {
	*x = GenericEncapArg{}
	mi := &file_module_msg_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenericEncapArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenericEncapArg) ProtoMessage() {}

func (x *GenericEncapArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenericEncapArg.ProtoReflect.Descriptor instead.
func (*GenericEncapArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{46}
}

func (x *GenericEncapArg) GetFields() []*GenericEncapArg_EncapField {
	if x != nil {
		return x.Fields
	}
	return nil
}

// *
// The HashLB module partitions packets between output gates according to either
// a hash over their MAC src/dst (`mode='l2'`), their IP src/dst (`mode='l3'`),
// the full IP/TCP 5-tuple (`mode='l4'`), or the N-tuple defined by `fields`.
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type HashLBArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gates         []int64                `protobuf:"varint,1,rep,packed,name=gates,proto3" json:"gates,omitempty"` /// A list of gate numbers over which to partition packets
	Mode          string                 `protobuf:"bytes,2,opt,name=mode,proto3" json:"mode,omitempty"`           /// The mode (`'l2'`, `'l3'`, or `'l4'`) for the hash function.
	Fields        []*Field               `protobuf:"bytes,3,rep,name=fields,proto3" json:"fields,omitempty"`       /// A list of fields that define a custom tuple.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HashLBArg) Reset() {
	*x = HashLBArg{}
	mi := &file_module_msg_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HashLBArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HashLBArg) ProtoMessage() {}

func (x *HashLBArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HashLBArg.ProtoReflect.Descriptor instead.
func (*HashLBArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{47}
}

func (x *HashLBArg) GetGates() []int64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

func (x *HashLBArg) GetMode() string {
	if x != nil {
		return x.Mode
	}
	return ""
}

func (x *HashLBArg) GetFields() []*Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

// *
// Encapsulates a packet with an IP header, where IP src, dst, and proto are
// filled in by metadata values carried with the packet. Metadata attributes
// must include: ip_src, ip_dst, ip_proto, ip_nexthop, and ether_type.
//
// __Input Gates__: 1
// __Output Gates__: 1
type IPEncapArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPEncapArg) Reset() {
	*x = IPEncapArg{}
	mi := &file_module_msg_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPEncapArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPEncapArg) ProtoMessage() {}

func (x *IPEncapArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPEncapArg.ProtoReflect.Descriptor instead.
func (*IPEncapArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{48}
}

// *
// An IPLookup module perfroms LPM lookups over a packet destination.
// IPLookup takes no parameters to instantiate.
// To add rules to the IPLookup table, use `IPLookup.add()`
//
// __Input Gates__: 1
// __Output Gates__: many (configurable, depending on rule values)
type IPLookupArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MaxRules      uint32                 `protobuf:"varint,1,opt,name=max_rules,json=maxRules,proto3" json:"max_rules,omitempty"` /// Maximum number of rules (default: 1024)
	MaxTbl8S      uint32                 `protobuf:"varint,2,opt,name=max_tbl8s,json=maxTbl8s,proto3" json:"max_tbl8s,omitempty"` /// Maximum number of IP prefixes with smaller than /24 (default: 128)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPLookupArg) Reset() {
	*x = IPLookupArg{}
	mi := &file_module_msg_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPLookupArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPLookupArg) ProtoMessage() {}

func (x *IPLookupArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPLookupArg.ProtoReflect.Descriptor instead.
func (*IPLookupArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{49}
}

func (x *IPLookupArg) GetMaxRules() uint32 {
	if x != nil {
		return x.MaxRules
	}
	return 0
}

func (x *IPLookupArg) GetMaxTbl8S() uint32 {
	if x != nil {
		return x.MaxTbl8S
	}
	return 0
}

// *
// An L2Forward module forwards packets to an output gate according to
// exact-match rules over an Ethernet destination. Note that this is _not_ a
// learning switch -- forwards according to fixed routes specified by `add(..)`.
//
// __Input Gates__: 1
// __Ouput Gates__: many (configurable, depending on rules)
type L2ForwardArg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Size  int64                  `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"` /// Configures the forwarding hash table -- total number of
	// / hash table entries.
	Bucket        int64 `protobuf:"varint,2,opt,name=bucket,proto3" json:"bucket,omitempty"` /// Configures the forwarding hash table -- total number of
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L2ForwardArg) Reset() {
	*x = L2ForwardArg{}
	mi := &file_module_msg_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L2ForwardArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2ForwardArg) ProtoMessage() {}

func (x *L2ForwardArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2ForwardArg.ProtoReflect.Descriptor instead.
func (*L2ForwardArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{50}
}

func (x *L2ForwardArg) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *L2ForwardArg) GetBucket() int64 {
	if x != nil {
		return x.Bucket
	}
	return 0
}

// *
// The MACSwap module takes no arguments. It swaps the src/destination MAC
// addresses within a packet.
//
// __Input Gates__: 1
// __Output Gates__: 1
type MACSwapArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MACSwapArg) Reset() {
	*x = MACSwapArg{}
	mi := &file_module_msg_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MACSwapArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MACSwapArg) ProtoMessage() {}

func (x *MACSwapArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MACSwapArg.ProtoReflect.Descriptor instead.
func (*MACSwapArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{51}
}

// *
// The measure module tracks latencies, packets per second, and other
// statistics. It should be paired with a Timestamp module, which attaches a
// timestamp to packets. The measure module will log how long (in nanoseconds)
// it has been for each packet it received since it was timestamped. This module
// is somewhat experimental and undergoing various changes. There is a test for
// the the Measure module in
// [`bessctl/module_tests/timestamp.py`](https://github.com/omec-project/bess/blob/master/bessctl/module_tests/timestamp.py).
//
// __Input Gates__: 1
// __Output Gates__: 1
type MeasureArg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// int64 warmup = 1; /// removed: instead of warmup delay, user should Clear()
	//
	// Types that are valid to be assigned to Type:
	//
	//	*MeasureArg_Offset
	//	*MeasureArg_AttrName
	Type             isMeasureArg_Type `protobuf_oneof:"type"`
	JitterSampleProb float64           `protobuf:"fixed64,3,opt,name=jitter_sample_prob,json=jitterSampleProb,proto3" json:"jitter_sample_prob,omitempty"` /// How often the module should sample packets for inter-packet
	// / arrival measurements (to measure jitter).
	LatencyNsMax        uint64 `protobuf:"varint,4,opt,name=latency_ns_max,json=latencyNsMax,proto3" json:"latency_ns_max,omitempty"`                      /// maximum latency expected, in ns (default 0.1 s)
	LatencyNsResolution uint32 `protobuf:"varint,5,opt,name=latency_ns_resolution,json=latencyNsResolution,proto3" json:"latency_ns_resolution,omitempty"` /// resolution, in ns (default 100)
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *MeasureArg) Reset() {
	*x = MeasureArg{}
	mi := &file_module_msg_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MeasureArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeasureArg) ProtoMessage() {}

func (x *MeasureArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeasureArg.ProtoReflect.Descriptor instead.
func (*MeasureArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{52}
}

func (x *MeasureArg) GetType() isMeasureArg_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *MeasureArg) GetOffset() uint64 {
	if x != nil {
		if x, ok := x.Type.(*MeasureArg_Offset); ok {
			return x.Offset
		}
	}
	return 0
}

func (x *MeasureArg) GetAttrName() string {
	if x != nil {
		if x, ok := x.Type.(*MeasureArg_AttrName); ok {
			return x.AttrName
		}
	}
	return ""
}

func (x *MeasureArg) GetJitterSampleProb() float64 {
	if x != nil {
		return x.JitterSampleProb
	}
	return 0
}

func (x *MeasureArg) GetLatencyNsMax() uint64 {
	if x != nil {
		return x.LatencyNsMax
	}
	return 0
}

func (x *MeasureArg) GetLatencyNsResolution() uint32 {
	if x != nil {
		return x.LatencyNsResolution
	}
	return 0
}

type isMeasureArg_Type interface {
	isMeasureArg_Type()
}

type MeasureArg_Offset struct {
	Offset uint64 `protobuf:"varint,2,opt,name=offset,proto3,oneof"` /// Where to store the current time within the packet,
}

type MeasureArg_AttrName struct {
	// / offset in bytes.
	AttrName string `protobuf:"bytes,6,opt,name=attr_name,json=attrName,proto3,oneof"` /// Where to store the current time as attribute
}

func (*MeasureArg_Offset) isMeasureArg_Type() {}

func (*MeasureArg_AttrName) isMeasureArg_Type() {}

// *
// The merge module takes no parameters. It has multiple input gates,
// and passes out all packets from a single output gate.
//
// __Input Gates__: many (configurable)
// __Output Gates__: 1
type MergeArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MergeArg) Reset() {
	*x = MergeArg{}
	mi := &file_module_msg_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MergeArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MergeArg) ProtoMessage() {}

func (x *MergeArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MergeArg.ProtoReflect.Descriptor instead.
func (*MergeArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{53}
}

// *
// The MetadataTest module is used for internal testing purposes.
type MetadataTestArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Read          map[string]int64       `protobuf:"bytes,1,rep,name=read,proto3" json:"read,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Write         map[string]int64       `protobuf:"bytes,2,rep,name=write,proto3" json:"write,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Update        map[string]int64       `protobuf:"bytes,3,rep,name=update,proto3" json:"update,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetadataTestArg) Reset() {
	*x = MetadataTestArg{}
	mi := &file_module_msg_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetadataTestArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetadataTestArg) ProtoMessage() {}

func (x *MetadataTestArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetadataTestArg.ProtoReflect.Descriptor instead.
func (*MetadataTestArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{54}
}

func (x *MetadataTestArg) GetRead() map[string]int64 {
	if x != nil {
		return x.Read
	}
	return nil
}

func (x *MetadataTestArg) GetWrite() map[string]int64 {
	if x != nil {
		return x.Write
	}
	return nil
}

func (x *MetadataTestArg) GetUpdate() map[string]int64 {
	if x != nil {
		return x.Update
	}
	return nil
}

// *
// The NAT module implements Dynamic IPv4 address/port translation,
// rewriting packet source addresses with external addresses as specified,
// and destination addresses for packets on the reverse direction.
// L3/L4 checksums are updated correspondingly.
// To see an example of NAT in use, see:
// [`bess/bessctl/conf/samples/nat.bess`](https://github.com/omec-project/bess/blob/master/bessctl/conf/samples/nat.bess)
//
// Currently only supports TCP/UDP/ICMP.
// Note that address/port in packet payload (e.g., FTP) are NOT translated.
//
// __Input Gates__: 2 (0 for internal->external, and 1 for external->internal
// direction)
// __Output Gates__: 2 (same as the input gate)
type NATArg struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	ExtAddrs      []*NATArg_ExternalAddress `protobuf:"bytes,1,rep,name=ext_addrs,json=extAddrs,proto3" json:"ext_addrs,omitempty"` /// list of external IP addresses
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NATArg) Reset() {
	*x = NATArg{}
	mi := &file_module_msg_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NATArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NATArg) ProtoMessage() {}

func (x *NATArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NATArg.ProtoReflect.Descriptor instead.
func (*NATArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{55}
}

func (x *NATArg) GetExtAddrs() []*NATArg_ExternalAddress {
	if x != nil {
		return x.ExtAddrs
	}
	return nil
}

// *
// Static NAT module implements one-to-one translation of source/destination
// IPv4 addresses. No port number is translated.
// L3/L4 checksums are updated correspondingly.
// To see an example of NAT in use, see:
// [`bess/bessctl/conf/samples/nat.bess`](https://github.com/omec-project/bess/blob/master/bessctl/conf/samples/nat.bess)
//
// Forward direction (from input gate 0 to output gate 0):
//   - Source IP address is updated, from internal to external address.
//
// Reverse direction (from input gate 1 to output gate 1):
//   - Destination IP address is updated, from external to internal address.
//
// If the original address is outside any of the ranges, packets are forwarded
// without NAT.
//
// Note that address in packet payload (e.g., FTP) are NOT translated.
//
// __Input Gates__: 2 (0 for internal->external, and 1 for external->internal
// direction)
// __Output Gates__: 2 (same as the input gate)
type StaticNATArg struct {
	state         protoimpl.MessageState           `protogen:"open.v1"`
	Pairs         []*StaticNATArg_AddressRangePair `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StaticNATArg) Reset() {
	*x = StaticNATArg{}
	mi := &file_module_msg_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StaticNATArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StaticNATArg) ProtoMessage() {}

func (x *StaticNATArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StaticNATArg.ProtoReflect.Descriptor instead.
func (*StaticNATArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{56}
}

func (x *StaticNATArg) GetPairs() []*StaticNATArg_AddressRangePair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

// *
// This module is used for testing purposes.
type NoOpArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NoOpArg) Reset() {
	*x = NoOpArg{}
	mi := &file_module_msg_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NoOpArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NoOpArg) ProtoMessage() {}

func (x *NoOpArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NoOpArg.ProtoReflect.Descriptor instead.
func (*NoOpArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{57}
}

// *
// The PortInc module connects a physical or virtual port and releases
// packets from it. PortInc does not support multiqueueing.
// For details on how to configure PortInc using DPDK, virtual ports,
// or libpcap, see the sidebar in the wiki.
//
// __Input Gates__: 0
// __Output Gates__: 1
type PortIncArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Port          string                 `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"`          /// The portname to connect to.
	Prefetch      bool                   `protobuf:"varint,2,opt,name=prefetch,proto3" json:"prefetch,omitempty"` /// Whether or not to prefetch packets from the port.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortIncArg) Reset() {
	*x = PortIncArg{}
	mi := &file_module_msg_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortIncArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortIncArg) ProtoMessage() {}

func (x *PortIncArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortIncArg.ProtoReflect.Descriptor instead.
func (*PortIncArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{58}
}

func (x *PortIncArg) GetPort() string {
	if x != nil {
		return x.Port
	}
	return ""
}

func (x *PortIncArg) GetPrefetch() bool {
	if x != nil {
		return x.Prefetch
	}
	return false
}

// *
// The PortOut module connects to a physical or virtual port and pushes
// packets to it. For details on how to configure PortOut with DPDK,
// virtual ports, libpcap, etc, see the sidebar in the wiki.
//
// __Input Gates__: 1
// __Output Gates__: 0
type PortOutArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Port          string                 `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"` /// The portname to connect to.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortOutArg) Reset() {
	*x = PortOutArg{}
	mi := &file_module_msg_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortOutArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortOutArg) ProtoMessage() {}

func (x *PortOutArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortOutArg.ProtoReflect.Descriptor instead.
func (*PortOutArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{59}
}

func (x *PortOutArg) GetPort() string {
	if x != nil {
		return x.Port
	}
	return ""
}

// *
// The module QueueInc produces input packets from a physical or virtual port.
// Unlike PortInc, it supports multiqueue ports.
// For details on how to configure QueueInc with DPDK, virtualports,
// libpcap, etc, see the sidebar in the wiki.
//
// __Input Gates__: 0
// __Output Gates__: 1
type QueueIncArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Port          string                 `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"`          /// The portname to connect to (read from).
	Qid           uint64                 `protobuf:"varint,2,opt,name=qid,proto3" json:"qid,omitempty"`           /// The queue on that port to read from. qid starts from 0.
	Prefetch      bool                   `protobuf:"varint,3,opt,name=prefetch,proto3" json:"prefetch,omitempty"` /// When prefetch is enabled, the module will perform CPU
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueIncArg) Reset() {
	*x = QueueIncArg{}
	mi := &file_module_msg_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueIncArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueIncArg) ProtoMessage() {}

func (x *QueueIncArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueIncArg.ProtoReflect.Descriptor instead.
func (*QueueIncArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{60}
}

func (x *QueueIncArg) GetPort() string {
	if x != nil {
		return x.Port
	}
	return ""
}

func (x *QueueIncArg) GetQid() uint64 {
	if x != nil {
		return x.Qid
	}
	return 0
}

func (x *QueueIncArg) GetPrefetch() bool {
	if x != nil {
		return x.Prefetch
	}
	return false
}

// *
// The QueueOut module releases packets to a physical or virtual port.
// Unlike PortOut, it supports multiqueue ports.
// For details on how to configure QueueOut with DPDK, virtualports,
// libpcap, etc, see the sidebar in the wiki.
//
// __Input Gates__: 1
// __Output Gates__: 0
type QueueOutArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Port          string                 `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"` /// The portname to connect to.
	Qid           uint64                 `protobuf:"varint,2,opt,name=qid,proto3" json:"qid,omitempty"`  /// The queue on that port to write out to.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueOutArg) Reset() {
	*x = QueueOutArg{}
	mi := &file_module_msg_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueOutArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueOutArg) ProtoMessage() {}

func (x *QueueOutArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueOutArg.ProtoReflect.Descriptor instead.
func (*QueueOutArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{61}
}

func (x *QueueOutArg) GetPort() string {
	if x != nil {
		return x.Port
	}
	return ""
}

func (x *QueueOutArg) GetQid() uint64 {
	if x != nil {
		return x.Qid
	}
	return 0
}

// *
// The Queue module implements a simple packet queue.
//
// __Input Gates__: 1
// __Output Gates__: 1
type QueueArg struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Size     uint64                 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`         /// The maximum number of packets to store in the queue.
	Prefetch bool                   `protobuf:"varint,2,opt,name=prefetch,proto3" json:"prefetch,omitempty"` /// When prefetch is enabled, the module will perform CPU
	// / prefetch on the first 64B of each packet onto CPU L1
	// / cache. Default value is false.
	Backpressure  bool `protobuf:"varint,3,opt,name=backpressure,proto3" json:"backpressure,omitempty"` // When backpressure is enabled, the module will
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueArg) Reset() {
	*x = QueueArg{}
	mi := &file_module_msg_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueArg) ProtoMessage() {}

func (x *QueueArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueArg.ProtoReflect.Descriptor instead.
func (*QueueArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{62}
}

func (x *QueueArg) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *QueueArg) GetPrefetch() bool {
	if x != nil {
		return x.Prefetch
	}
	return false
}

func (x *QueueArg) GetBackpressure() bool {
	if x != nil {
		return x.Backpressure
	}
	return false
}

// *
// The RandomSplit module randomly split/drop packets
//
// __InputGates__: 1
// __Output Gates__: many (configurable)
type RandomSplitArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DropRate      float64                `protobuf:"fixed64,1,opt,name=drop_rate,json=dropRate,proto3" json:"drop_rate,omitempty"` /// Probability of dropping packet.
	Gates         []int64                `protobuf:"varint,2,rep,packed,name=gates,proto3" json:"gates,omitempty"`                 /// A list of gate numbers to split the traffic.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RandomSplitArg) Reset() {
	*x = RandomSplitArg{}
	mi := &file_module_msg_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RandomSplitArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RandomSplitArg) ProtoMessage() {}

func (x *RandomSplitArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RandomSplitArg.ProtoReflect.Descriptor instead.
func (*RandomSplitArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{63}
}

func (x *RandomSplitArg) GetDropRate() float64 {
	if x != nil {
		return x.DropRate
	}
	return 0
}

func (x *RandomSplitArg) GetGates() []int64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

// *
// The RandomSplit module has a function `set_droprate(...)` which specifies
// the probability of dropping packets
type RandomSplitCommandSetDroprateArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DropRate      float64                `protobuf:"fixed64,1,opt,name=drop_rate,json=dropRate,proto3" json:"drop_rate,omitempty"` /// Probability of dropping packet.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RandomSplitCommandSetDroprateArg) Reset() {
	*x = RandomSplitCommandSetDroprateArg{}
	mi := &file_module_msg_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RandomSplitCommandSetDroprateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RandomSplitCommandSetDroprateArg) ProtoMessage() {}

func (x *RandomSplitCommandSetDroprateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RandomSplitCommandSetDroprateArg.ProtoReflect.Descriptor instead.
func (*RandomSplitCommandSetDroprateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{64}
}

func (x *RandomSplitCommandSetDroprateArg) GetDropRate() float64 {
	if x != nil {
		return x.DropRate
	}
	return 0
}

// *
// The RandomSplit module has a function `set_gates(...)` which changes
// the total number of output gates in the module.
type RandomSplitCommandSetGatesArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gates         []int64                `protobuf:"varint,1,rep,packed,name=gates,proto3" json:"gates,omitempty"` /// A list of gate numbers to split the traffic.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RandomSplitCommandSetGatesArg) Reset() {
	*x = RandomSplitCommandSetGatesArg{}
	mi := &file_module_msg_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RandomSplitCommandSetGatesArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RandomSplitCommandSetGatesArg) ProtoMessage() {}

func (x *RandomSplitCommandSetGatesArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RandomSplitCommandSetGatesArg.ProtoReflect.Descriptor instead.
func (*RandomSplitCommandSetGatesArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{65}
}

func (x *RandomSplitCommandSetGatesArg) GetGates() []int64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

// *
// The RandomUpdate module rewrites a specified field (`offset` and `size`) in a
// packet with a random value between a specified min and max values.
//
// __Input Gates__: 1
// __Output Gates__: 1
type RandomUpdateArg struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Fields        []*RandomUpdateArg_Field `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"` /// A list of Random Update Fields.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RandomUpdateArg) Reset() {
	*x = RandomUpdateArg{}
	mi := &file_module_msg_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RandomUpdateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RandomUpdateArg) ProtoMessage() {}

func (x *RandomUpdateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RandomUpdateArg.ProtoReflect.Descriptor instead.
func (*RandomUpdateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{66}
}

func (x *RandomUpdateArg) GetFields() []*RandomUpdateArg_Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

// *
// The Rewrite module replaces an entire packet body with a packet "template"
// converting all packets that pass through to copies of the of one of
// the templates.
//
// __Input Gates__: 1
// __Output Gates__: 1
type RewriteArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Templates     [][]byte               `protobuf:"bytes,1,rep,name=templates,proto3" json:"templates,omitempty"` /// A list of bytestrings representing packet templates.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RewriteArg) Reset() {
	*x = RewriteArg{}
	mi := &file_module_msg_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RewriteArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RewriteArg) ProtoMessage() {}

func (x *RewriteArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RewriteArg.ProtoReflect.Descriptor instead.
func (*RewriteArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{67}
}

func (x *RewriteArg) GetTemplates() [][]byte {
	if x != nil {
		return x.Templates
	}
	return nil
}

// *
// The RoundRobin module has a function `set_gates(...)` which changes
// the total number of output gates in the module.
type RoundRobinCommandSetGatesArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gates         []int64                `protobuf:"varint,1,rep,packed,name=gates,proto3" json:"gates,omitempty"` /// A list of gate numbers to round-robin the traffic over.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RoundRobinCommandSetGatesArg) Reset() {
	*x = RoundRobinCommandSetGatesArg{}
	mi := &file_module_msg_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoundRobinCommandSetGatesArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoundRobinCommandSetGatesArg) ProtoMessage() {}

func (x *RoundRobinCommandSetGatesArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoundRobinCommandSetGatesArg.ProtoReflect.Descriptor instead.
func (*RoundRobinCommandSetGatesArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{68}
}

func (x *RoundRobinCommandSetGatesArg) GetGates() []int64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

// *
// The RoundRobin module has a function `set_mode(...)` which specifies whether
// to balance traffic across gates per-packet or per-batch.
type RoundRobinCommandSetModeArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mode          string                 `protobuf:"bytes,1,opt,name=mode,proto3" json:"mode,omitempty"` /// whether to perform `'packet'` or `'batch'` round robin
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RoundRobinCommandSetModeArg) Reset() {
	*x = RoundRobinCommandSetModeArg{}
	mi := &file_module_msg_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoundRobinCommandSetModeArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoundRobinCommandSetModeArg) ProtoMessage() {}

func (x *RoundRobinCommandSetModeArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoundRobinCommandSetModeArg.ProtoReflect.Descriptor instead.
func (*RoundRobinCommandSetModeArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{69}
}

func (x *RoundRobinCommandSetModeArg) GetMode() string {
	if x != nil {
		return x.Mode
	}
	return ""
}

// *
// The RoundRobin module splits packets from one input gate across multiple
// output gates.
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type RoundRobinArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gates         []int64                `protobuf:"varint,1,rep,packed,name=gates,proto3" json:"gates,omitempty"` /// A list of gate numbers to split packets across.
	Mode          string                 `protobuf:"bytes,2,opt,name=mode,proto3" json:"mode,omitempty"`           /// Whether to split across gate with every `'packet'` or
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RoundRobinArg) Reset() {
	*x = RoundRobinArg{}
	mi := &file_module_msg_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoundRobinArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoundRobinArg) ProtoMessage() {}

func (x *RoundRobinArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoundRobinArg.ProtoReflect.Descriptor instead.
func (*RoundRobinArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{70}
}

func (x *RoundRobinArg) GetGates() []int64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

func (x *RoundRobinArg) GetMode() string {
	if x != nil {
		return x.Mode
	}
	return ""
}

// *
// The Replicate module makes copies of a packet sending one copy out over each
// of n output gates.
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type ReplicateArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gates         []int64                `protobuf:"varint,1,rep,packed,name=gates,proto3" json:"gates,omitempty"` /// A list of gate numbers to send packet copies to.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicateArg) Reset() {
	*x = ReplicateArg{}
	mi := &file_module_msg_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateArg) ProtoMessage() {}

func (x *ReplicateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateArg.ProtoReflect.Descriptor instead.
func (*ReplicateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{71}
}

func (x *ReplicateArg) GetGates() []int64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

// *
// The Replicate module has a function `set_gates(...)` which changes
// the total number of output gates in the module.
type ReplicateCommandSetGatesArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gates         []int64                `protobuf:"varint,1,rep,packed,name=gates,proto3" json:"gates,omitempty"` /// A list of gate numbers to replicate the traffic over.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicateCommandSetGatesArg) Reset() {
	*x = ReplicateCommandSetGatesArg{}
	mi := &file_module_msg_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateCommandSetGatesArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateCommandSetGatesArg) ProtoMessage() {}

func (x *ReplicateCommandSetGatesArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateCommandSetGatesArg.ProtoReflect.Descriptor instead.
func (*ReplicateCommandSetGatesArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{72}
}

func (x *ReplicateCommandSetGatesArg) GetGates() []int64 {
	if x != nil {
		return x.Gates
	}
	return nil
}

// *
// The SetMetadata module adds metadata attributes to packets, which are not
// stored or sent out with packet data. For examples of SetMetadata use, see
// [`bess/bessctl/conf/attr_match.bess`](https://github.com/omec-project/bess/blob/master/bessctl/conf/metadata/attr_match.bess)
//
// __Input Gates__: 1
// __Output Gates__: 1
type SetMetadataArg struct {
	state         protoimpl.MessageState      `protogen:"open.v1"`
	Attrs         []*SetMetadataArg_Attribute `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"` /// A list of attributes to attach to the packet.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetMetadataArg) Reset() {
	*x = SetMetadataArg{}
	mi := &file_module_msg_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetMetadataArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetMetadataArg) ProtoMessage() {}

func (x *SetMetadataArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetMetadataArg.ProtoReflect.Descriptor instead.
func (*SetMetadataArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{73}
}

func (x *SetMetadataArg) GetAttrs() []*SetMetadataArg_Attribute {
	if x != nil {
		return x.Attrs
	}
	return nil
}

// *
// The sink module drops all packets that are sent to it.
//
// __Input Gates__: 1
// __Output Gates__: 0
type SinkArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SinkArg) Reset() {
	*x = SinkArg{}
	mi := &file_module_msg_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SinkArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SinkArg) ProtoMessage() {}

func (x *SinkArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SinkArg.ProtoReflect.Descriptor instead.
func (*SinkArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{74}
}

// *
// The Source module has a function `set_burst(...)` which
// specifies the maximum number of packets to release in a single packetbatch
// from the module.
type SourceCommandSetBurstArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Burst         uint64                 `protobuf:"varint,1,opt,name=burst,proto3" json:"burst,omitempty"` /// The maximum number of packets to release in a
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceCommandSetBurstArg) Reset() {
	*x = SourceCommandSetBurstArg{}
	mi := &file_module_msg_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceCommandSetBurstArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceCommandSetBurstArg) ProtoMessage() {}

func (x *SourceCommandSetBurstArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceCommandSetBurstArg.ProtoReflect.Descriptor instead.
func (*SourceCommandSetBurstArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{75}
}

func (x *SourceCommandSetBurstArg) GetBurst() uint64 {
	if x != nil {
		return x.Burst
	}
	return 0
}

// *
// The Source module has a function `set_pkt_size(...)` which specifies the size
// of packets to be produced by the Source module.
type SourceCommandSetPktSizeArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PktSize       uint64                 `protobuf:"varint,1,opt,name=pkt_size,json=pktSize,proto3" json:"pkt_size,omitempty"` /// The size (in bytes) of the packets for Source to create.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceCommandSetPktSizeArg) Reset() {
	*x = SourceCommandSetPktSizeArg{}
	mi := &file_module_msg_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceCommandSetPktSizeArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceCommandSetPktSizeArg) ProtoMessage() {}

func (x *SourceCommandSetPktSizeArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceCommandSetPktSizeArg.ProtoReflect.Descriptor instead.
func (*SourceCommandSetPktSizeArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{76}
}

func (x *SourceCommandSetPktSizeArg) GetPktSize() uint64 {
	if x != nil {
		return x.PktSize
	}
	return 0
}

// *
// The Source module generates packets with no payload contents.
//
// __Input Gates__: 0
// __Output Gates__: 1
type SourceArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PktSize       uint64                 `protobuf:"varint,1,opt,name=pkt_size,json=pktSize,proto3" json:"pkt_size,omitempty"` /// The size (in bytes) of packet data to produce.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceArg) Reset() {
	*x = SourceArg{}
	mi := &file_module_msg_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceArg) ProtoMessage() {}

func (x *SourceArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceArg.ProtoReflect.Descriptor instead.
func (*SourceArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{77}
}

func (x *SourceArg) GetPktSize() uint64 {
	if x != nil {
		return x.PktSize
	}
	return 0
}

// *
// The IPChecksum module calculates the IPv4 checksum of packets. If
// verify is set to true, the module can be used to validate the checksum
// of the IPv4 packet. All non-IPv4 packets are forwarded without
// modification. Output gates: (0) Default, (1) Drop.
//
// __Input Gates__: 1
// __Output Gates__: 2
type IPChecksumArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Verify        bool                   `protobuf:"varint,1,opt,name=verify,proto3" json:"verify,omitempty"` /// check checksum
	Hw            bool                   `protobuf:"varint,2,opt,name=hw,proto3" json:"hw,omitempty"`         /// enable hardware offload
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPChecksumArg) Reset() {
	*x = IPChecksumArg{}
	mi := &file_module_msg_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPChecksumArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPChecksumArg) ProtoMessage() {}

func (x *IPChecksumArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPChecksumArg.ProtoReflect.Descriptor instead.
func (*IPChecksumArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{78}
}

func (x *IPChecksumArg) GetVerify() bool {
	if x != nil {
		return x.Verify
	}
	return false
}

func (x *IPChecksumArg) GetHw() bool {
	if x != nil {
		return x.Hw
	}
	return false
}

// *
// The L4Checksum module calculates the UDP/IPv4 checksum of packets. If
// verify is set to true, the module can be used to validate the checksum
// of the UDP/IPv4 packet. All non-IPv4 packets are forwarded without
// modification. Output gates: (0) Default, (1) Drop.
//
// __Input Gates__: MAX_GATES
// __Output Gates__: 2
type L4ChecksumArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Verify        bool                   `protobuf:"varint,1,opt,name=verify,proto3" json:"verify,omitempty"` /// check checksum
	Hw            bool                   `protobuf:"varint,2,opt,name=hw,proto3" json:"hw,omitempty"`         /// enable hardware offload
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L4ChecksumArg) Reset() {
	*x = L4ChecksumArg{}
	mi := &file_module_msg_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L4ChecksumArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L4ChecksumArg) ProtoMessage() {}

func (x *L4ChecksumArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L4ChecksumArg.ProtoReflect.Descriptor instead.
func (*L4ChecksumArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{79}
}

func (x *L4ChecksumArg) GetVerify() bool {
	if x != nil {
		return x.Verify
	}
	return false
}

func (x *L4ChecksumArg) GetHw() bool {
	if x != nil {
		return x.Hw
	}
	return false
}

// *
// The GtpuEcho module processes the GTPv1 echo packet and prepares
// corresponding IP packet containing GTP echo response. It assumes
// Recovery IE is always zero.
//
// __Input Gates__: 1
// __Output Gates__: 1
type GtpuEchoArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	S1USgwIp      uint32                 `protobuf:"varint,1,opt,name=s1u_sgw_ip,json=s1uSgwIp,proto3" json:"s1u_sgw_ip,omitempty"` /// IP address of S1U interface
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GtpuEchoArg) Reset() {
	*x = GtpuEchoArg{}
	mi := &file_module_msg_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GtpuEchoArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GtpuEchoArg) ProtoMessage() {}

func (x *GtpuEchoArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GtpuEchoArg.ProtoReflect.Descriptor instead.
func (*GtpuEchoArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{80}
}

func (x *GtpuEchoArg) GetS1USgwIp() uint32 {
	if x != nil {
		return x.S1USgwIp
	}
	return 0
}

// *
// The IPDefrag module scans the IP datagram and checks whether
// it is fragmented. It returns a fully reassembled datagram or
// an unfragmented IP datagram
//
// __Input Gates__: 1
// __Output Gates__: 1
type IPDefragArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NumFlows      uint32                 `protobuf:"varint,1,opt,name=num_flows,json=numFlows,proto3" json:"num_flows,omitempty"` /// max number of flows the module can handle
	Numa          int32                  `protobuf:"varint,2,opt,name=numa,proto3" json:"numa,omitempty"`                         /// numa placement for ip frags memory management
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPDefragArg) Reset() {
	*x = IPDefragArg{}
	mi := &file_module_msg_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPDefragArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPDefragArg) ProtoMessage() {}

func (x *IPDefragArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPDefragArg.ProtoReflect.Descriptor instead.
func (*IPDefragArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{81}
}

func (x *IPDefragArg) GetNumFlows() uint32 {
	if x != nil {
		return x.NumFlows
	}
	return 0
}

func (x *IPDefragArg) GetNuma() int32 {
	if x != nil {
		return x.Numa
	}
	return 0
}

// *
// The IPDFrag module scans the IP datagram and checks whether
// it needs to be fragmented.
//
// __Input Gates__: 1
// __Output Gates__: 1
type IPFragArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mtu           int32                  `protobuf:"varint,1,opt,name=mtu,proto3" json:"mtu,omitempty"` /// full Ethernet frame size (including CRC) for encapsulated
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPFragArg) Reset() {
	*x = IPFragArg{}
	mi := &file_module_msg_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPFragArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPFragArg) ProtoMessage() {}

func (x *IPFragArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPFragArg.ProtoReflect.Descriptor instead.
func (*IPFragArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{82}
}

func (x *IPFragArg) GetMtu() int32 {
	if x != nil {
		return x.Mtu
	}
	return 0
}

// *
// The Counter module has a command `add(...)` which takes one
// parameters.  This function accepts the counter id of a
// session record.
// Example use in bessctl: `counter.add(ctr_id=0x1)`
type CounterAddArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CtrId         uint32                 `protobuf:"varint,1,opt,name=ctr_id,json=ctrId,proto3" json:"ctr_id,omitempty"` /// counter id
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CounterAddArg) Reset() {
	*x = CounterAddArg{}
	mi := &file_module_msg_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CounterAddArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterAddArg) ProtoMessage() {}

func (x *CounterAddArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterAddArg.ProtoReflect.Descriptor instead.
func (*CounterAddArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{83}
}

func (x *CounterAddArg) GetCtrId() uint32 {
	if x != nil {
		return x.CtrId
	}
	return 0
}

// *
// The Counter module has a command `remove(...)` which takes one
// parameter.  This function accepts ctr_id, and removes the
// respective counter.
// Example use in bessctl: `counter.remove(ctr_id=0x1)`
type CounterRemoveArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CtrId         uint32                 `protobuf:"varint,1,opt,name=ctr_id,json=ctrId,proto3" json:"ctr_id,omitempty"` /// counter id
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CounterRemoveArg) Reset() {
	*x = CounterRemoveArg{}
	mi := &file_module_msg_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CounterRemoveArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterRemoveArg) ProtoMessage() {}

func (x *CounterRemoveArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterRemoveArg.ProtoReflect.Descriptor instead.
func (*CounterRemoveArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{84}
}

func (x *CounterRemoveArg) GetCtrId() uint32 {
	if x != nil {
		return x.CtrId
	}
	return 0
}

// *
// The Counter module counts the number of packets and bytes it passes
//
// __Input Gates__: 1
// __Output Gates__: 1
type CounterArg struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	NameId     string                 `protobuf:"bytes,1,opt,name=name_id,json=nameId,proto3" json:"name_id,omitempty"`              /// Name of the counter_id
	CheckExist bool                   `protobuf:"varint,2,opt,name=check_exist,json=checkExist,proto3" json:"check_exist,omitempty"` /// verify each counter pre-exists before any operation
	// / (default = False)
	Total         uint32 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"` /// Total number of entries it can support
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CounterArg) Reset() {
	*x = CounterArg{}
	mi := &file_module_msg_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CounterArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterArg) ProtoMessage() {}

func (x *CounterArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterArg.ProtoReflect.Descriptor instead.
func (*CounterArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{85}
}

func (x *CounterArg) GetNameId() string {
	if x != nil {
		return x.NameId
	}
	return ""
}

func (x *CounterArg) GetCheckExist() bool {
	if x != nil {
		return x.CheckExist
	}
	return false
}

func (x *CounterArg) GetTotal() uint32 {
	if x != nil {
		return x.Total
	}
	return 0
}

// *
// The GtpuEncap module inserts GTP header in an ethernet frame
//
// __Input Gates__: 1
// __Output Gates__: 1
type GtpuEncapArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AddPsc        bool                   `protobuf:"varint,1,opt,name=add_psc,json=addPsc,proto3" json:"add_psc,omitempty"` /// Add PDU session container in encap (default = False)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GtpuEncapArg) Reset() {
	*x = GtpuEncapArg{}
	mi := &file_module_msg_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GtpuEncapArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GtpuEncapArg) ProtoMessage() {}

func (x *GtpuEncapArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GtpuEncapArg.ProtoReflect.Descriptor instead.
func (*GtpuEncapArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{86}
}

func (x *GtpuEncapArg) GetAddPsc() bool {
	if x != nil {
		return x.AddPsc
	}
	return false
}

// *
// The Split module is a basic classifier which directs packets out a gate
// based on data in the packet (e.g., if the read in value is 3, the packet
// is directed out output gate 3).
//
// __Input Gates__: 1
// __Output Gates__: many (up to 2^(size * 8))
type SplitArg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Size  uint64                 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"` /// The size of the value to read in bytes
	// Types that are valid to be assigned to Type:
	//
	//	*SplitArg_Attribute
	//	*SplitArg_Offset
	Type          isSplitArg_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SplitArg) Reset() {
	*x = SplitArg{}
	mi := &file_module_msg_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SplitArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SplitArg) ProtoMessage() {}

func (x *SplitArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SplitArg.ProtoReflect.Descriptor instead.
func (*SplitArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{87}
}

func (x *SplitArg) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *SplitArg) GetType() isSplitArg_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *SplitArg) GetAttribute() string {
	if x != nil {
		if x, ok := x.Type.(*SplitArg_Attribute); ok {
			return x.Attribute
		}
	}
	return ""
}

func (x *SplitArg) GetOffset() int64 {
	if x != nil {
		if x, ok := x.Type.(*SplitArg_Offset); ok {
			return x.Offset
		}
	}
	return 0
}

type isSplitArg_Type interface {
	isSplitArg_Type()
}

type SplitArg_Attribute struct {
	Attribute string `protobuf:"bytes,2,opt,name=attribute,proto3,oneof"` /// The name of the metadata field to read.
}

type SplitArg_Offset struct {
	Offset int64 `protobuf:"varint,3,opt,name=offset,proto3,oneof"` /// The offset (in bytes) of the data field to read.
}

func (*SplitArg_Attribute) isSplitArg_Type() {}

func (*SplitArg_Offset) isSplitArg_Type() {}

// *
// The timestamp module takes an offset parameter. It inserts the current
// time in nanoseconds into the packet, to be used for latency measurements
// alongside the Measure module.  The default offset is after an IPv4 UDP
// header.
//
// __Input Gates__: 1
// __Output Gates__: 1
type TimestampArg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*TimestampArg_Offset
	//	*TimestampArg_AttrName
	Type          isTimestampArg_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimestampArg) Reset() {
	*x = TimestampArg{}
	mi := &file_module_msg_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimestampArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimestampArg) ProtoMessage() {}

func (x *TimestampArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimestampArg.ProtoReflect.Descriptor instead.
func (*TimestampArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{88}
}

func (x *TimestampArg) GetType() isTimestampArg_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *TimestampArg) GetOffset() uint64 {
	if x != nil {
		if x, ok := x.Type.(*TimestampArg_Offset); ok {
			return x.Offset
		}
	}
	return 0
}

func (x *TimestampArg) GetAttrName() string {
	if x != nil {
		if x, ok := x.Type.(*TimestampArg_AttrName); ok {
			return x.AttrName
		}
	}
	return ""
}

type isTimestampArg_Type interface {
	isTimestampArg_Type()
}

type TimestampArg_Offset struct {
	Offset uint64 `protobuf:"varint,1,opt,name=offset,proto3,oneof"`
}

type TimestampArg_AttrName struct {
	AttrName string `protobuf:"bytes,2,opt,name=attr_name,json=attrName,proto3,oneof"`
}

func (*TimestampArg_Offset) isTimestampArg_Type() {}

func (*TimestampArg_AttrName) isTimestampArg_Type() {}

// *
// The Update module rewrites a field in a packet's data with a specific value.
//
// __Input Gates__: 1
// __Output Gates__: 1
type UpdateArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fields        []*UpdateArg_Field     `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"` /// A list of Update Fields.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateArg) Reset() {
	*x = UpdateArg{}
	mi := &file_module_msg_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateArg) ProtoMessage() {}

func (x *UpdateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateArg.ProtoReflect.Descriptor instead.
func (*UpdateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{89}
}

func (x *UpdateArg) GetFields() []*UpdateArg_Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

// *
// The URLFilter performs TCP reconstruction over a flow and blocks
// connections which mention a banned URL.
//
// __Input Gates__: 2
// __Output Gates__: 2
//
// Note that the add() command takes this same argument, and the
// clear() command takes an empty argument.
type UrlFilterArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Blacklist     []*UrlFilterArg_Url    `protobuf:"bytes,1,rep,name=blacklist,proto3" json:"blacklist,omitempty"` /// A list of Urls to block.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UrlFilterArg) Reset() {
	*x = UrlFilterArg{}
	mi := &file_module_msg_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UrlFilterArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UrlFilterArg) ProtoMessage() {}

func (x *UrlFilterArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UrlFilterArg.ProtoReflect.Descriptor instead.
func (*UrlFilterArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{90}
}

func (x *UrlFilterArg) GetBlacklist() []*UrlFilterArg_Url {
	if x != nil {
		return x.Blacklist
	}
	return nil
}

// *
// The runtime configuration of a URLFilter is the current
// blacklist.  This means that getting the Arg gets an *empty*
// list: we assume anyone using get_initial_arg is also using
// get_runtime_config.
type UrlFilterConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Blacklist     []*UrlFilterArg_Url    `protobuf:"bytes,1,rep,name=blacklist,proto3" json:"blacklist,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UrlFilterConfig) Reset() {
	*x = UrlFilterConfig{}
	mi := &file_module_msg_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UrlFilterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UrlFilterConfig) ProtoMessage() {}

func (x *UrlFilterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UrlFilterConfig.ProtoReflect.Descriptor instead.
func (*UrlFilterConfig) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{91}
}

func (x *UrlFilterConfig) GetBlacklist() []*UrlFilterArg_Url {
	if x != nil {
		return x.Blacklist
	}
	return nil
}

// *
// VLANPop removes the VLAN tag.
//
// __Input Gates__: 1
// __Output Gates__: 1
type VLANPopArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VLANPopArg) Reset() {
	*x = VLANPopArg{}
	mi := &file_module_msg_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VLANPopArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VLANPopArg) ProtoMessage() {}

func (x *VLANPopArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VLANPopArg.ProtoReflect.Descriptor instead.
func (*VLANPopArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{92}
}

// *
// VLANPush appends a VLAN tag with a specified TCI value.
//
// __Input Gates__: 1
// __Output Gates__: 1
type VLANPushArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tci           uint64                 `protobuf:"varint,1,opt,name=tci,proto3" json:"tci,omitempty"` /// The TCI value to insert in the VLAN tag.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VLANPushArg) Reset() {
	*x = VLANPushArg{}
	mi := &file_module_msg_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VLANPushArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VLANPushArg) ProtoMessage() {}

func (x *VLANPushArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VLANPushArg.ProtoReflect.Descriptor instead.
func (*VLANPushArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{93}
}

func (x *VLANPushArg) GetTci() uint64 {
	if x != nil {
		return x.Tci
	}
	return 0
}

// *
// Splits packets across output gates according to VLAN id (e.g., id 3 goes out
// gate 3).
//
// __Input Gates__: 1
// __Output Gates__: many
type VLANSplitArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VLANSplitArg) Reset() {
	*x = VLANSplitArg{}
	mi := &file_module_msg_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VLANSplitArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VLANSplitArg) ProtoMessage() {}

func (x *VLANSplitArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VLANSplitArg.ProtoReflect.Descriptor instead.
func (*VLANSplitArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{94}
}

// *
// VXLANDecap module decapsulates a VXLAN header on a packet.
//
// __Input Gates__: 1
// __Output Gates__: 1
type VXLANDecapArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VXLANDecapArg) Reset() {
	*x = VXLANDecapArg{}
	mi := &file_module_msg_proto_msgTypes[95]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VXLANDecapArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VXLANDecapArg) ProtoMessage() {}

func (x *VXLANDecapArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[95]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VXLANDecapArg.ProtoReflect.Descriptor instead.
func (*VXLANDecapArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{95}
}

// *
// VXLANEncap module wraps a packet in a VXLAN header with a specified
// destination port.
//
// __Input Gates__: 1
// __Output Gates__: 1
type VXLANEncapArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Dstport       uint64                 `protobuf:"varint,1,opt,name=dstport,proto3" json:"dstport,omitempty"` /// The destination UDP port
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VXLANEncapArg) Reset() {
	*x = VXLANEncapArg{}
	mi := &file_module_msg_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VXLANEncapArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VXLANEncapArg) ProtoMessage() {}

func (x *VXLANEncapArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VXLANEncapArg.ProtoReflect.Descriptor instead.
func (*VXLANEncapArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{96}
}

func (x *VXLANEncapArg) GetDstport() uint64 {
	if x != nil {
		return x.Dstport
	}
	return 0
}

// *
// The WildcardMatch module matches over multiple fields in a packet and
// pushes packets that do match out a specified gate, and those that don't out a
// default gate. WildcardMatch is initialized with the fields it should inspect
// over, rules are added via the `add(...)` function. An example of
// WildcardMatch is in
// [`bess/bessctl/conf/samples/wildcardmatch.bess`](https://github.com/omec-project/bess/blob/master/bessctl/conf/samples/wildcardmatch.bess)
//
// __Input Gates__: 1
// __Output Gates__: many (configurable)
type WildcardMatchArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fields        []*Field               `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"` /// A list of WildcardMatch fields.
	Values        []*Field               `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"` /// A list of WildcardMatch values.
	Entries       uint64                 `protobuf:"varint,3,opt,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WildcardMatchArg) Reset() {
	*x = WildcardMatchArg{}
	mi := &file_module_msg_proto_msgTypes[97]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WildcardMatchArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WildcardMatchArg) ProtoMessage() {}

func (x *WildcardMatchArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[97]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WildcardMatchArg.ProtoReflect.Descriptor instead.
func (*WildcardMatchArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{97}
}

func (x *WildcardMatchArg) GetFields() []*Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *WildcardMatchArg) GetValues() []*Field {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *WildcardMatchArg) GetEntries() uint64 {
	if x != nil {
		return x.Entries
	}
	return 0
}

// *
// WildcardMatchConfig represents the current runtime configuration
// of a WildcardMatch module, as returned by get_runtime_config and
// set by set_runtime_config.
type WildcardMatchConfig struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	DefaultGate   uint64                        `protobuf:"varint,1,opt,name=default_gate,json=defaultGate,proto3" json:"default_gate,omitempty"`
	Rules         []*WildcardMatchCommandAddArg `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WildcardMatchConfig) Reset() {
	*x = WildcardMatchConfig{}
	mi := &file_module_msg_proto_msgTypes[98]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WildcardMatchConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WildcardMatchConfig) ProtoMessage() {}

func (x *WildcardMatchConfig) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[98]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WildcardMatchConfig.ProtoReflect.Descriptor instead.
func (*WildcardMatchConfig) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{98}
}

func (x *WildcardMatchConfig) GetDefaultGate() uint64 {
	if x != nil {
		return x.DefaultGate
	}
	return 0
}

func (x *WildcardMatchConfig) GetRules() []*WildcardMatchCommandAddArg {
	if x != nil {
		return x.Rules
	}
	return nil
}

// *
// The ARP Responder module is responding to ARP requests.
// It has a function `add(...)` which adds one IP-MAC mapping.
//
// TODO: Dynamic learn new MAC's-IP's mapping
//
// __Input Gates__: 1
// __Output Gates__: 1
type ArpResponderArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ip            string                 `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`                          /// The IP
	MacAddr       string                 `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"` /// The MAC address
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArpResponderArg) Reset() {
	*x = ArpResponderArg{}
	mi := &file_module_msg_proto_msgTypes[99]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArpResponderArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArpResponderArg) ProtoMessage() {}

func (x *ArpResponderArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[99]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArpResponderArg.ProtoReflect.Descriptor instead.
func (*ArpResponderArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{99}
}

func (x *ArpResponderArg) GetIp() string {
	if x != nil {
		return x.Ip
	}
	return ""
}

func (x *ArpResponderArg) GetMacAddr() string {
	if x != nil {
		return x.MacAddr
	}
	return ""
}

// *
// The MPLS pop module removes MPLS labels
//
// __Input Gates__: 1
// __Output Gates__: 2
type MplsPopArg struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	RemoveEthHeader bool                   `protobuf:"varint,1,opt,name=remove_eth_header,json=removeEthHeader,proto3" json:"remove_eth_header,omitempty"` /// Remove ETH header with the pop
	NextEthType     uint32                 `protobuf:"varint,2,opt,name=next_eth_type,json=nextEthType,proto3" json:"next_eth_type,omitempty"`             /// The next ETH type to set
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *MplsPopArg) Reset() {
	*x = MplsPopArg{}
	mi := &file_module_msg_proto_msgTypes[100]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MplsPopArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MplsPopArg) ProtoMessage() {}

func (x *MplsPopArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[100]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MplsPopArg.ProtoReflect.Descriptor instead.
func (*MplsPopArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{100}
}

func (x *MplsPopArg) GetRemoveEthHeader() bool {
	if x != nil {
		return x.RemoveEthHeader
	}
	return false
}

func (x *MplsPopArg) GetNextEthType() uint32 {
	if x != nil {
		return x.NextEthType
	}
	return 0
}

// *
// WorkerSplit splits packets based on the worker calling ProcessBatch(). It has
// two modes.
//  1. Packets from worker `x` are mapped to output gate `x`. This is the default
//     mode.
//  2. When the `worker_gates` field is set, packets from a worker `x` are mapped
//     to `worker_gates[x]`.  In this mode, packet batches from workers not
//     mapped to an output gate will be dropped.
//
// Calling the `reset` command with an empty `worker_gates` field will revert
// WorkerSplit to the default mode.
//
// __Input Gates__: 1
// __Output Gates__: many
type WorkerSplitArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	WorkerGates   map[uint32]uint32      `protobuf:"bytes,1,rep,name=worker_gates,json=workerGates,proto3" json:"worker_gates,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"` // ogate -> worker mask
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkerSplitArg) Reset() {
	*x = WorkerSplitArg{}
	mi := &file_module_msg_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkerSplitArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkerSplitArg) ProtoMessage() {}

func (x *WorkerSplitArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkerSplitArg.ProtoReflect.Descriptor instead.
func (*WorkerSplitArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{101}
}

func (x *WorkerSplitArg) GetWorkerGates() map[uint32]uint32 {
	if x != nil {
		return x.WorkerGates
	}
	return nil
}

type QosArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fields        []*Field               `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	Values        []*Field               `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	Entries       uint64                 `protobuf:"varint,3,opt,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QosArg) Reset() {
	*x = QosArg{}
	mi := &file_module_msg_proto_msgTypes[102]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QosArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QosArg) ProtoMessage() {}

func (x *QosArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[102]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QosArg.ProtoReflect.Descriptor instead.
func (*QosArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{102}
}

func (x *QosArg) GetFields() []*Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *QosArg) GetValues() []*Field {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *QosArg) GetEntries() uint64 {
	if x != nil {
		return x.Entries
	}
	return 0
}

type QosCommandAddArg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Gate  uint64                 `protobuf:"varint,1,opt,name=gate,proto3" json:"gate,omitempty"`
	Cir   uint64                 `protobuf:"varint,2,opt,name=cir,proto3" json:"cir,omitempty"`
	Pir   uint64                 `protobuf:"varint,3,opt,name=pir,proto3" json:"pir,omitempty"`
	Cbs   uint64                 `protobuf:"varint,4,opt,name=cbs,proto3" json:"cbs,omitempty"`
	Pbs   uint64                 `protobuf:"varint,5,opt,name=pbs,proto3" json:"pbs,omitempty"`
	Ebs   uint64                 `protobuf:"varint,6,opt,name=ebs,proto3" json:"ebs,omitempty"`
	// Types that are valid to be assigned to OptionalDeductLen:
	//
	//	*QosCommandAddArg_DeductLen
	OptionalDeductLen isQosCommandAddArg_OptionalDeductLen `protobuf_oneof:"optional_deduct_len"`
	Fields            []*FieldData                         `protobuf:"bytes,7,rep,name=fields,proto3" json:"fields,omitempty"`
	Values            []*FieldData                         `protobuf:"bytes,8,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QosCommandAddArg) Reset() {
	*x = QosCommandAddArg{}
	mi := &file_module_msg_proto_msgTypes[103]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QosCommandAddArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QosCommandAddArg) ProtoMessage() {}

func (x *QosCommandAddArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[103]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QosCommandAddArg.ProtoReflect.Descriptor instead.
func (*QosCommandAddArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{103}
}

func (x *QosCommandAddArg) GetGate() uint64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

func (x *QosCommandAddArg) GetCir() uint64 {
	if x != nil {
		return x.Cir
	}
	return 0
}

func (x *QosCommandAddArg) GetPir() uint64 {
	if x != nil {
		return x.Pir
	}
	return 0
}

func (x *QosCommandAddArg) GetCbs() uint64 {
	if x != nil {
		return x.Cbs
	}
	return 0
}

func (x *QosCommandAddArg) GetPbs() uint64 {
	if x != nil {
		return x.Pbs
	}
	return 0
}

func (x *QosCommandAddArg) GetEbs() uint64 {
	if x != nil {
		return x.Ebs
	}
	return 0
}

func (x *QosCommandAddArg) GetOptionalDeductLen() isQosCommandAddArg_OptionalDeductLen {
	if x != nil {
		return x.OptionalDeductLen
	}
	return nil
}

func (x *QosCommandAddArg) GetDeductLen() int64 {
	if x != nil {
		if x, ok := x.OptionalDeductLen.(*QosCommandAddArg_DeductLen); ok {
			return x.DeductLen
		}
	}
	return 0
}

func (x *QosCommandAddArg) GetFields() []*FieldData {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *QosCommandAddArg) GetValues() []*FieldData {
	if x != nil {
		return x.Values
	}
	return nil
}

type isQosCommandAddArg_OptionalDeductLen interface {
	isQosCommandAddArg_OptionalDeductLen()
}

type QosCommandAddArg_DeductLen struct {
	DeductLen int64 `protobuf:"varint,9,opt,name=deduct_len,json=deductLen,proto3,oneof"`
}

func (*QosCommandAddArg_DeductLen) isQosCommandAddArg_OptionalDeductLen() {}

type QosCommandDeleteArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fields        []*FieldData           `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QosCommandDeleteArg) Reset() {
	*x = QosCommandDeleteArg{}
	mi := &file_module_msg_proto_msgTypes[104]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QosCommandDeleteArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QosCommandDeleteArg) ProtoMessage() {}

func (x *QosCommandDeleteArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[104]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QosCommandDeleteArg.ProtoReflect.Descriptor instead.
func (*QosCommandDeleteArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{104}
}

func (x *QosCommandDeleteArg) GetFields() []*FieldData {
	if x != nil {
		return x.Fields
	}
	return nil
}

// *
// The function `clear()` for WildcardMatch takes no parameters, it clears
// all state in the WildcardMatch module (is equivalent to calling delete for
// all rules)
type QosCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QosCommandClearArg) Reset() {
	*x = QosCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[105]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QosCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QosCommandClearArg) ProtoMessage() {}

func (x *QosCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[105]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QosCommandClearArg.ProtoReflect.Descriptor instead.
func (*QosCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{105}
}

// *
// For traffic which does not match any rule in the WildcardMatch module,
// the `set_default_gate(...)` function specifies which gate to send this extra
// traffic to.
type QosCommandSetDefaultGateArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Gate          uint64                 `protobuf:"varint,1,opt,name=gate,proto3" json:"gate,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QosCommandSetDefaultGateArg) Reset() {
	*x = QosCommandSetDefaultGateArg{}
	mi := &file_module_msg_proto_msgTypes[106]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QosCommandSetDefaultGateArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QosCommandSetDefaultGateArg) ProtoMessage() {}

func (x *QosCommandSetDefaultGateArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[106]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QosCommandSetDefaultGateArg.ProtoReflect.Descriptor instead.
func (*QosCommandSetDefaultGateArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{106}
}

func (x *QosCommandSetDefaultGateArg) GetGate() uint64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

type FlowMeasureArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FlagAttrName  string                 `protobuf:"bytes,1,opt,name=flag_attr_name,json=flagAttrName,proto3" json:"flag_attr_name,omitempty"`
	Entries       uint64                 `protobuf:"varint,2,opt,name=entries,proto3" json:"entries,omitempty"`
	Leader        bool                   `protobuf:"varint,3,opt,name=leader,proto3" json:"leader,omitempty"` // If true, this module will decide the buffer side
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowMeasureArg) Reset() {
	*x = FlowMeasureArg{}
	mi := &file_module_msg_proto_msgTypes[107]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowMeasureArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMeasureArg) ProtoMessage() {}

func (x *FlowMeasureArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[107]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMeasureArg.ProtoReflect.Descriptor instead.
func (*FlowMeasureArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{107}
}

func (x *FlowMeasureArg) GetFlagAttrName() string {
	if x != nil {
		return x.FlagAttrName
	}
	return ""
}

func (x *FlowMeasureArg) GetEntries() uint64 {
	if x != nil {
		return x.Entries
	}
	return 0
}

func (x *FlowMeasureArg) GetLeader() bool {
	if x != nil {
		return x.Leader
	}
	return false
}

type FlowMeasureCommandReadArg struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Clear              bool                   `protobuf:"varint,1,opt,name=clear,proto3" json:"clear,omitempty"`                                                             // If true, the data will be all cleared after read
	LatencyPercentiles []float64              `protobuf:"fixed64,2,rep,packed,name=latency_percentiles,json=latencyPercentiles,proto3" json:"latency_percentiles,omitempty"` /// ascending list of real numbers in [0.0, 100.0]
	JitterPercentiles  []float64              `protobuf:"fixed64,3,rep,packed,name=jitter_percentiles,json=jitterPercentiles,proto3" json:"jitter_percentiles,omitempty"`    /// ascending list of real numbers in [0.0, 100.0]
	FlagToRead         uint64                 `protobuf:"varint,4,opt,name=flag_to_read,json=flagToRead,proto3" json:"flag_to_read,omitempty"`                               /// Which buffer to read from
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *FlowMeasureCommandReadArg) Reset() {
	*x = FlowMeasureCommandReadArg{}
	mi := &file_module_msg_proto_msgTypes[108]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowMeasureCommandReadArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMeasureCommandReadArg) ProtoMessage() {}

func (x *FlowMeasureCommandReadArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[108]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMeasureCommandReadArg.ProtoReflect.Descriptor instead.
func (*FlowMeasureCommandReadArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{108}
}

func (x *FlowMeasureCommandReadArg) GetClear() bool {
	if x != nil {
		return x.Clear
	}
	return false
}

func (x *FlowMeasureCommandReadArg) GetLatencyPercentiles() []float64 {
	if x != nil {
		return x.LatencyPercentiles
	}
	return nil
}

func (x *FlowMeasureCommandReadArg) GetJitterPercentiles() []float64 {
	if x != nil {
		return x.JitterPercentiles
	}
	return nil
}

func (x *FlowMeasureCommandReadArg) GetFlagToRead() uint64 {
	if x != nil {
		return x.FlagToRead
	}
	return 0
}

type FlowMeasureReadResponse struct {
	state         protoimpl.MessageState               `protogen:"open.v1"`
	Statistics    []*FlowMeasureReadResponse_Statistic `protobuf:"bytes,1,rep,name=statistics,proto3" json:"statistics,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowMeasureReadResponse) Reset() {
	*x = FlowMeasureReadResponse{}
	mi := &file_module_msg_proto_msgTypes[109]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowMeasureReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMeasureReadResponse) ProtoMessage() {}

func (x *FlowMeasureReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[109]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMeasureReadResponse.ProtoReflect.Descriptor instead.
func (*FlowMeasureReadResponse) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{109}
}

func (x *FlowMeasureReadResponse) GetStatistics() []*FlowMeasureReadResponse_Statistic {
	if x != nil {
		return x.Statistics
	}
	return nil
}

type FlowMeasureCommandFlipArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowMeasureCommandFlipArg) Reset() {
	*x = FlowMeasureCommandFlipArg{}
	mi := &file_module_msg_proto_msgTypes[110]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowMeasureCommandFlipArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMeasureCommandFlipArg) ProtoMessage() {}

func (x *FlowMeasureCommandFlipArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[110]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMeasureCommandFlipArg.ProtoReflect.Descriptor instead.
func (*FlowMeasureCommandFlipArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{110}
}

type FlowMeasureFlipResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	OldFlag       uint64                 `protobuf:"varint,1,opt,name=old_flag,json=oldFlag,proto3" json:"old_flag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowMeasureFlipResponse) Reset() {
	*x = FlowMeasureFlipResponse{}
	mi := &file_module_msg_proto_msgTypes[111]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowMeasureFlipResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMeasureFlipResponse) ProtoMessage() {}

func (x *FlowMeasureFlipResponse) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[111]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMeasureFlipResponse.ProtoReflect.Descriptor instead.
func (*FlowMeasureFlipResponse) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{111}
}

func (x *FlowMeasureFlipResponse) GetOldFlag() uint64 {
	if x != nil {
		return x.OldFlag
	}
	return 0
}

// *
// The GtpuPathMonitoring module has a command `add()` and `delete().
// This command add or deletes an IP address from the GtpuPathMonitoring module.
type GtpuPathMonitoringCommandAddDeleteArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GnbIp         uint32                 `protobuf:"varint,1,opt,name=gnb_ip,json=gnbIp,proto3" json:"gnb_ip,omitempty"` // The destination/gNB IP address.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GtpuPathMonitoringCommandAddDeleteArg) Reset() {
	*x = GtpuPathMonitoringCommandAddDeleteArg{}
	mi := &file_module_msg_proto_msgTypes[112]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GtpuPathMonitoringCommandAddDeleteArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GtpuPathMonitoringCommandAddDeleteArg) ProtoMessage() {}

func (x *GtpuPathMonitoringCommandAddDeleteArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[112]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GtpuPathMonitoringCommandAddDeleteArg.ProtoReflect.Descriptor instead.
func (*GtpuPathMonitoringCommandAddDeleteArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{112}
}

func (x *GtpuPathMonitoringCommandAddDeleteArg) GetGnbIp() uint32 {
	if x != nil {
		return x.GnbIp
	}
	return 0
}

// *
// The GtpuPathMonitoring module has a command `clear()` which takes no
// parameters.
// This command removes all IP addresses from the GtpuPathMonitoring module.
type GtpuPathMonitoringCommandClearArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GtpuPathMonitoringCommandClearArg) Reset() {
	*x = GtpuPathMonitoringCommandClearArg{}
	mi := &file_module_msg_proto_msgTypes[113]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GtpuPathMonitoringCommandClearArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GtpuPathMonitoringCommandClearArg) ProtoMessage() {}

func (x *GtpuPathMonitoringCommandClearArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[113]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GtpuPathMonitoringCommandClearArg.ProtoReflect.Descriptor instead.
func (*GtpuPathMonitoringCommandClearArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{113}
}

// *
// The GtpuPathMonitoring module has a command `read()`.
// This command requests to read the stats from the GtpuPathMonitoring module.
// It can also clear the stats
type GtpuPathMonitoringCommandReadArg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Clear         bool                   `protobuf:"varint,1,opt,name=clear,proto3" json:"clear,omitempty"` // If true, the data will be all cleared after read
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GtpuPathMonitoringCommandReadArg) Reset() {
	*x = GtpuPathMonitoringCommandReadArg{}
	mi := &file_module_msg_proto_msgTypes[114]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GtpuPathMonitoringCommandReadArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GtpuPathMonitoringCommandReadArg) ProtoMessage() {}

func (x *GtpuPathMonitoringCommandReadArg) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[114]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GtpuPathMonitoringCommandReadArg.ProtoReflect.Descriptor instead.
func (*GtpuPathMonitoringCommandReadArg) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{114}
}

func (x *GtpuPathMonitoringCommandReadArg) GetClear() bool {
	if x != nil {
		return x.Clear
	}
	return false
}

// *
// The GtpuPathMonitoring module has a command `readResponse()`.
// This command reads the stats from the GtpuPathMonitoring module.
type GtpuPathMonitoringCommandReadResponse struct {
	state         protoimpl.MessageState                             `protogen:"open.v1"`
	Statistics    []*GtpuPathMonitoringCommandReadResponse_Statistic `protobuf:"bytes,1,rep,name=statistics,proto3" json:"statistics,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GtpuPathMonitoringCommandReadResponse) Reset() {
	*x = GtpuPathMonitoringCommandReadResponse{}
	mi := &file_module_msg_proto_msgTypes[115]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GtpuPathMonitoringCommandReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GtpuPathMonitoringCommandReadResponse) ProtoMessage() {}

func (x *GtpuPathMonitoringCommandReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[115]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GtpuPathMonitoringCommandReadResponse.ProtoReflect.Descriptor instead.
func (*GtpuPathMonitoringCommandReadResponse) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{115}
}

func (x *GtpuPathMonitoringCommandReadResponse) GetStatistics() []*GtpuPathMonitoringCommandReadResponse_Statistic {
	if x != nil {
		return x.Statistics
	}
	return nil
}

type L2ForwardCommandAddArg_Entry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Addr          string                 `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`  /// The MAC address to match
	Gate          int64                  `protobuf:"varint,2,opt,name=gate,proto3" json:"gate,omitempty"` /// Which gate to send out traffic matching this address.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *L2ForwardCommandAddArg_Entry) Reset() {
	*x = L2ForwardCommandAddArg_Entry{}
	mi := &file_module_msg_proto_msgTypes[116]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *L2ForwardCommandAddArg_Entry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2ForwardCommandAddArg_Entry) ProtoMessage() {}

func (x *L2ForwardCommandAddArg_Entry) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[116]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2ForwardCommandAddArg_Entry.ProtoReflect.Descriptor instead.
func (*L2ForwardCommandAddArg_Entry) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{12, 0}
}

func (x *L2ForwardCommandAddArg_Entry) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *L2ForwardCommandAddArg_Entry) GetGate() int64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

type MeasureCommandGetSummaryResponse_Histogram struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Count              uint64                 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`                                   /// Total # of measured data points, including above_range
	AboveRange         uint64                 `protobuf:"varint,2,opt,name=above_range,json=aboveRange,proto3" json:"above_range,omitempty"`       /// # of data points for the "too large value" bucket
	ResolutionNs       uint64                 `protobuf:"varint,8,opt,name=resolution_ns,json=resolutionNs,proto3" json:"resolution_ns,omitempty"` /// resolution of measured data
	MinNs              uint64                 `protobuf:"varint,3,opt,name=min_ns,json=minNs,proto3" json:"min_ns,omitempty"`
	AvgNs              uint64                 `protobuf:"varint,4,opt,name=avg_ns,json=avgNs,proto3" json:"avg_ns,omitempty"`
	MaxNs              uint64                 `protobuf:"varint,5,opt,name=max_ns,json=maxNs,proto3" json:"max_ns,omitempty"`
	TotalNs            uint64                 `protobuf:"varint,6,opt,name=total_ns,json=totalNs,proto3" json:"total_ns,omitempty"`
	PercentileValuesNs []uint64               `protobuf:"varint,7,rep,packed,name=percentile_values_ns,json=percentileValuesNs,proto3" json:"percentile_values_ns,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *MeasureCommandGetSummaryResponse_Histogram) Reset() {
	*x = MeasureCommandGetSummaryResponse_Histogram{}
	mi := &file_module_msg_proto_msgTypes[117]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MeasureCommandGetSummaryResponse_Histogram) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeasureCommandGetSummaryResponse_Histogram) ProtoMessage() {}

func (x *MeasureCommandGetSummaryResponse_Histogram) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[117]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeasureCommandGetSummaryResponse_Histogram.ProtoReflect.Descriptor instead.
func (*MeasureCommandGetSummaryResponse_Histogram) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{19, 0}
}

func (x *MeasureCommandGetSummaryResponse_Histogram) GetCount() uint64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse_Histogram) GetAboveRange() uint64 {
	if x != nil {
		return x.AboveRange
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse_Histogram) GetResolutionNs() uint64 {
	if x != nil {
		return x.ResolutionNs
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse_Histogram) GetMinNs() uint64 {
	if x != nil {
		return x.MinNs
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse_Histogram) GetAvgNs() uint64 {
	if x != nil {
		return x.AvgNs
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse_Histogram) GetMaxNs() uint64 {
	if x != nil {
		return x.MaxNs
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse_Histogram) GetTotalNs() uint64 {
	if x != nil {
		return x.TotalNs
	}
	return 0
}

func (x *MeasureCommandGetSummaryResponse_Histogram) GetPercentileValuesNs() []uint64 {
	if x != nil {
		return x.PercentileValuesNs
	}
	return nil
}

// *
// One ACL rule is represented by the following 6-tuple.
type ACLArg_Rule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SrcIp         string                 `protobuf:"bytes,1,opt,name=src_ip,json=srcIp,proto3" json:"src_ip,omitempty"`        /// Source IP block in CIDR. Wildcard if "".
	DstIp         string                 `protobuf:"bytes,2,opt,name=dst_ip,json=dstIp,proto3" json:"dst_ip,omitempty"`        /// Destination IP block in CIDR. Wildcard if "".
	SrcPort       uint32                 `protobuf:"varint,3,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"` /// TCP/UDP source port. Wildcard if 0.
	DstPort       uint32                 `protobuf:"varint,4,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"` /// TCP/UDP Destination port. Wildcard if 0.
	Established   bool                   `protobuf:"varint,5,opt,name=established,proto3" json:"established,omitempty"`        /// Not implemented
	Drop          bool                   `protobuf:"varint,6,opt,name=drop,proto3" json:"drop,omitempty"`                      /// Drop matched packets if true, forward if false. By
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ACLArg_Rule) Reset() {
	*x = ACLArg_Rule{}
	mi := &file_module_msg_proto_msgTypes[118]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ACLArg_Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ACLArg_Rule) ProtoMessage() {}

func (x *ACLArg_Rule) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[118]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ACLArg_Rule.ProtoReflect.Descriptor instead.
func (*ACLArg_Rule) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{36, 0}
}

func (x *ACLArg_Rule) GetSrcIp() string {
	if x != nil {
		return x.SrcIp
	}
	return ""
}

func (x *ACLArg_Rule) GetDstIp() string {
	if x != nil {
		return x.DstIp
	}
	return ""
}

func (x *ACLArg_Rule) GetSrcPort() uint32 {
	if x != nil {
		return x.SrcPort
	}
	return 0
}

func (x *ACLArg_Rule) GetDstPort() uint32 {
	if x != nil {
		return x.DstPort
	}
	return 0
}

func (x *ACLArg_Rule) GetEstablished() bool {
	if x != nil {
		return x.Established
	}
	return false
}

func (x *ACLArg_Rule) GetDrop() bool {
	if x != nil {
		return x.Drop
	}
	return false
}

// *
// One BPF filter is represented by the following 3-tuple.
type BPFArg_Filter struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Priority int64                  `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"` /// The priority level for this rule. If a packet matches multiple
	// / rules, it will be forwarded out the gate with the highest
	// / priority. If a packet matches multiple rules with the same
	// / priority, the behavior is undefined.
	Filter        string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"` /// The actual BPF string.
	Gate          int64  `protobuf:"varint,3,opt,name=gate,proto3" json:"gate,omitempty"`    /// What gate to forward packets that match this BPF to.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BPFArg_Filter) Reset() {
	*x = BPFArg_Filter{}
	mi := &file_module_msg_proto_msgTypes[119]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BPFArg_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BPFArg_Filter) ProtoMessage() {}

func (x *BPFArg_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[119]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BPFArg_Filter.ProtoReflect.Descriptor instead.
func (*BPFArg_Filter) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{37, 0}
}

func (x *BPFArg_Filter) GetPriority() int64 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *BPFArg_Filter) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

func (x *BPFArg_Filter) GetGate() int64 {
	if x != nil {
		return x.Gate
	}
	return 0
}

// *
// An EncapField represents one field in the new packet header.
type GenericEncapArg_EncapField struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Size  uint64                 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"` /// The length of the field.
	// Types that are valid to be assigned to Insertion:
	//
	//	*GenericEncapArg_EncapField_Attribute
	//	*GenericEncapArg_EncapField_Value
	Insertion     isGenericEncapArg_EncapField_Insertion `protobuf_oneof:"insertion"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GenericEncapArg_EncapField) Reset() {
	*x = GenericEncapArg_EncapField{}
	mi := &file_module_msg_proto_msgTypes[120]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenericEncapArg_EncapField) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenericEncapArg_EncapField) ProtoMessage() {}

func (x *GenericEncapArg_EncapField) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[120]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenericEncapArg_EncapField.ProtoReflect.Descriptor instead.
func (*GenericEncapArg_EncapField) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{46, 0}
}

func (x *GenericEncapArg_EncapField) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *GenericEncapArg_EncapField) GetInsertion() isGenericEncapArg_EncapField_Insertion {
	if x != nil {
		return x.Insertion
	}
	return nil
}

func (x *GenericEncapArg_EncapField) GetAttribute() string {
	if x != nil {
		if x, ok := x.Insertion.(*GenericEncapArg_EncapField_Attribute); ok {
			return x.Attribute
		}
	}
	return ""
}

func (x *GenericEncapArg_EncapField) GetValue() *FieldData {
	if x != nil {
		if x, ok := x.Insertion.(*GenericEncapArg_EncapField_Value); ok {
			return x.Value
		}
	}
	return nil
}

type isGenericEncapArg_EncapField_Insertion interface {
	isGenericEncapArg_EncapField_Insertion()
}

type GenericEncapArg_EncapField_Attribute struct {
	Attribute string `protobuf:"bytes,2,opt,name=attribute,proto3,oneof"` /// The metadata attribute name to pull the field value from
}

type GenericEncapArg_EncapField_Value struct {
	Value *FieldData `protobuf:"bytes,3,opt,name=value,proto3,oneof"` /// Or, the fixed value to insert into the packet.
}

func (*GenericEncapArg_EncapField_Attribute) isGenericEncapArg_EncapField_Insertion() {}

func (*GenericEncapArg_EncapField_Value) isGenericEncapArg_EncapField_Insertion() {}

type NATArg_PortRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Begin         uint32                 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End           uint32                 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Suspended     bool                   `protobuf:"varint,3,opt,name=suspended,proto3" json:"suspended,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NATArg_PortRange) Reset() {
	*x = NATArg_PortRange{}
	mi := &file_module_msg_proto_msgTypes[124]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NATArg_PortRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NATArg_PortRange) ProtoMessage() {}

func (x *NATArg_PortRange) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[124]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NATArg_PortRange.ProtoReflect.Descriptor instead.
func (*NATArg_PortRange) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{55, 0}
}

func (x *NATArg_PortRange) GetBegin() uint32 {
	if x != nil {
		return x.Begin
	}
	return 0
}

func (x *NATArg_PortRange) GetEnd() uint32 {
	if x != nil {
		return x.End
	}
	return 0
}

func (x *NATArg_PortRange) GetSuspended() bool {
	if x != nil {
		return x.Suspended
	}
	return false
}

type NATArg_ExternalAddress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ExtAddr       string                 `protobuf:"bytes,1,opt,name=ext_addr,json=extAddr,proto3" json:"ext_addr,omitempty"`
	PortRanges    []*NATArg_PortRange    `protobuf:"bytes,2,rep,name=port_ranges,json=portRanges,proto3" json:"port_ranges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NATArg_ExternalAddress) Reset() {
	*x = NATArg_ExternalAddress{}
	mi := &file_module_msg_proto_msgTypes[125]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NATArg_ExternalAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NATArg_ExternalAddress) ProtoMessage() {}

func (x *NATArg_ExternalAddress) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[125]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NATArg_ExternalAddress.ProtoReflect.Descriptor instead.
func (*NATArg_ExternalAddress) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{55, 1}
}

func (x *NATArg_ExternalAddress) GetExtAddr() string {
	if x != nil {
		return x.ExtAddr
	}
	return ""
}

func (x *NATArg_ExternalAddress) GetPortRanges() []*NATArg_PortRange {
	if x != nil {
		return x.PortRanges
	}
	return nil
}

type StaticNATArg_AddressRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         string                 `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"` /// first IP address to use
	End           string                 `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`     /// last IP address to use
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StaticNATArg_AddressRange) Reset() {
	*x = StaticNATArg_AddressRange{}
	mi := &file_module_msg_proto_msgTypes[126]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StaticNATArg_AddressRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StaticNATArg_AddressRange) ProtoMessage() {}

func (x *StaticNATArg_AddressRange) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[126]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StaticNATArg_AddressRange.ProtoReflect.Descriptor instead.
func (*StaticNATArg_AddressRange) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{56, 0}
}

func (x *StaticNATArg_AddressRange) GetStart() string {
	if x != nil {
		return x.Start
	}
	return ""
}

func (x *StaticNATArg_AddressRange) GetEnd() string {
	if x != nil {
		return x.End
	}
	return ""
}

type StaticNATArg_AddressRangePair struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	IntRange      *StaticNATArg_AddressRange `protobuf:"bytes,1,opt,name=int_range,json=intRange,proto3" json:"int_range,omitempty"`
	ExtRange      *StaticNATArg_AddressRange `protobuf:"bytes,2,opt,name=ext_range,json=extRange,proto3" json:"ext_range,omitempty"` /// should be the same size as int_range
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StaticNATArg_AddressRangePair) Reset() {
	*x = StaticNATArg_AddressRangePair{}
	mi := &file_module_msg_proto_msgTypes[127]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StaticNATArg_AddressRangePair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StaticNATArg_AddressRangePair) ProtoMessage() {}

func (x *StaticNATArg_AddressRangePair) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[127]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StaticNATArg_AddressRangePair.ProtoReflect.Descriptor instead.
func (*StaticNATArg_AddressRangePair) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{56, 1}
}

func (x *StaticNATArg_AddressRangePair) GetIntRange() *StaticNATArg_AddressRange {
	if x != nil {
		return x.IntRange
	}
	return nil
}

func (x *StaticNATArg_AddressRangePair) GetExtRange() *StaticNATArg_AddressRange {
	if x != nil {
		return x.ExtRange
	}
	return nil
}

// *
// RandomUpdate's Field specifies where to rewrite, and what values to rewrite
// in each packet processed.
type RandomUpdateArg_Field struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Offset        int64                  `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"` /// Offset in bytes of where to rewrite.
	Size          uint64                 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`     /// The number of bytes to write.
	Min           uint64                 `protobuf:"varint,3,opt,name=min,proto3" json:"min,omitempty"`       /// The minimum value to insert into the packet.
	Max           uint64                 `protobuf:"varint,4,opt,name=max,proto3" json:"max,omitempty"`       /// The maximum value to insert into the packet.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RandomUpdateArg_Field) Reset() {
	*x = RandomUpdateArg_Field{}
	mi := &file_module_msg_proto_msgTypes[128]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RandomUpdateArg_Field) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RandomUpdateArg_Field) ProtoMessage() {}

func (x *RandomUpdateArg_Field) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[128]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RandomUpdateArg_Field.ProtoReflect.Descriptor instead.
func (*RandomUpdateArg_Field) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{66, 0}
}

func (x *RandomUpdateArg_Field) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *RandomUpdateArg_Field) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *RandomUpdateArg_Field) GetMin() uint64 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *RandomUpdateArg_Field) GetMax() uint64 {
	if x != nil {
		return x.Max
	}
	return 0
}

// *
// SetMetadata Attribute describes a metadata attribute and value to attach to
// every packet. If copying data from a packet buffer, SetMetadata can also
// logically shift then mask the value before storing it as metadata, i.e.,
// metadata_value = (packet_value >> `rshift_bits`) & `mask`.
type SetMetadataArg_Attribute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Name  string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`  /// The metadata attribute name.
	Size  uint64                 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"` /// The size of values stored in this attribute in bytes.
	// Types that are valid to be assigned to Value:
	//
	//	*SetMetadataArg_Attribute_ValueInt
	//	*SetMetadataArg_Attribute_ValueBin
	Value  isSetMetadataArg_Attribute_Value `protobuf_oneof:"value"`
	Offset int32                            `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"` /// An index in the packet data to store copy into the
	// / metadata attribute.
	Mask []byte `protobuf:"bytes,6,opt,name=mask,proto3" json:"mask,omitempty"` /// An array of bit masks to apply to each of the bytes
	// / copied starting from `offset`. If empty, the mask
	// / `[0xFF,....,0xFF]` will be used.
	RshiftBits    int32 `protobuf:"varint,7,opt,name=rshift_bits,json=rshiftBits,proto3" json:"rshift_bits,omitempty"` /// The number of bits to shift the value at `offset` by before
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetMetadataArg_Attribute) Reset() {
	*x = SetMetadataArg_Attribute{}
	mi := &file_module_msg_proto_msgTypes[129]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetMetadataArg_Attribute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetMetadataArg_Attribute) ProtoMessage() {}

func (x *SetMetadataArg_Attribute) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[129]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetMetadataArg_Attribute.ProtoReflect.Descriptor instead.
func (*SetMetadataArg_Attribute) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{73, 0}
}

func (x *SetMetadataArg_Attribute) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SetMetadataArg_Attribute) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *SetMetadataArg_Attribute) GetValue() isSetMetadataArg_Attribute_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *SetMetadataArg_Attribute) GetValueInt() uint64 {
	if x != nil {
		if x, ok := x.Value.(*SetMetadataArg_Attribute_ValueInt); ok {
			return x.ValueInt
		}
	}
	return 0
}

func (x *SetMetadataArg_Attribute) GetValueBin() []byte {
	if x != nil {
		if x, ok := x.Value.(*SetMetadataArg_Attribute_ValueBin); ok {
			return x.ValueBin
		}
	}
	return nil
}

func (x *SetMetadataArg_Attribute) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *SetMetadataArg_Attribute) GetMask() []byte {
	if x != nil {
		return x.Mask
	}
	return nil
}

func (x *SetMetadataArg_Attribute) GetRshiftBits() int32 {
	if x != nil {
		return x.RshiftBits
	}
	return 0
}

type isSetMetadataArg_Attribute_Value interface {
	isSetMetadataArg_Attribute_Value()
}

type SetMetadataArg_Attribute_ValueInt struct {
	ValueInt uint64 `protobuf:"varint,3,opt,name=value_int,json=valueInt,proto3,oneof"` /// An integer value to store in the packet (host-order).
}

type SetMetadataArg_Attribute_ValueBin struct {
	ValueBin []byte `protobuf:"bytes,4,opt,name=value_bin,json=valueBin,proto3,oneof"` /// A binary value to store in the packet (host-order).
}

func (*SetMetadataArg_Attribute_ValueInt) isSetMetadataArg_Attribute_Value() {}

func (*SetMetadataArg_Attribute_ValueBin) isSetMetadataArg_Attribute_Value() {}

// *
// Update Field describes where in a packet's data to rewrite, and with what
// value.
type UpdateArg_Field struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Offset        int64                  `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"` /// The offset in the packet in bytes to rewrite at.
	Size          uint64                 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`     /// The number of bytes to rewrite (max 8 bytes).
	Value         uint64                 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`   /// The value to write into the packet, max 8 bytes.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateArg_Field) Reset() {
	*x = UpdateArg_Field{}
	mi := &file_module_msg_proto_msgTypes[130]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateArg_Field) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateArg_Field) ProtoMessage() {}

func (x *UpdateArg_Field) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[130]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateArg_Field.ProtoReflect.Descriptor instead.
func (*UpdateArg_Field) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{89, 0}
}

func (x *UpdateArg_Field) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *UpdateArg_Field) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *UpdateArg_Field) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

// *
// A URL consists of a host and a path.
type UrlFilterArg_Url struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Host          string                 `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"` /// Host field, e.g. "www.google.com"
	Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"` /// Path prefix, e.g. "/"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UrlFilterArg_Url) Reset() {
	*x = UrlFilterArg_Url{}
	mi := &file_module_msg_proto_msgTypes[131]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UrlFilterArg_Url) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UrlFilterArg_Url) ProtoMessage() {}

func (x *UrlFilterArg_Url) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[131]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UrlFilterArg_Url.ProtoReflect.Descriptor instead.
func (*UrlFilterArg_Url) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{90, 0}
}

func (x *UrlFilterArg_Url) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *UrlFilterArg_Url) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type FlowMeasureReadResponse_Statistic struct {
	state         protoimpl.MessageState                       `protogen:"open.v1"`
	Fseid         uint64                                       `protobuf:"varint,1,opt,name=fseid,proto3" json:"fseid,omitempty"`
	Pdr           uint64                                       `protobuf:"varint,2,opt,name=pdr,proto3" json:"pdr,omitempty"`
	Latency       *FlowMeasureReadResponse_Statistic_Histogram `protobuf:"bytes,3,opt,name=latency,proto3" json:"latency,omitempty"`
	Jitter        *FlowMeasureReadResponse_Statistic_Histogram `protobuf:"bytes,4,opt,name=jitter,proto3" json:"jitter,omitempty"`
	TotalBytes    uint64                                       `protobuf:"varint,11,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	TotalPackets  uint64                                       `protobuf:"varint,12,opt,name=total_packets,json=totalPackets,proto3" json:"total_packets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowMeasureReadResponse_Statistic) Reset() {
	*x = FlowMeasureReadResponse_Statistic{}
	mi := &file_module_msg_proto_msgTypes[133]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowMeasureReadResponse_Statistic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMeasureReadResponse_Statistic) ProtoMessage() {}

func (x *FlowMeasureReadResponse_Statistic) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[133]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMeasureReadResponse_Statistic.ProtoReflect.Descriptor instead.
func (*FlowMeasureReadResponse_Statistic) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{109, 0}
}

func (x *FlowMeasureReadResponse_Statistic) GetFseid() uint64 {
	if x != nil {
		return x.Fseid
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic) GetPdr() uint64 {
	if x != nil {
		return x.Pdr
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic) GetLatency() *FlowMeasureReadResponse_Statistic_Histogram {
	if x != nil {
		return x.Latency
	}
	return nil
}

func (x *FlowMeasureReadResponse_Statistic) GetJitter() *FlowMeasureReadResponse_Statistic_Histogram {
	if x != nil {
		return x.Jitter
	}
	return nil
}

func (x *FlowMeasureReadResponse_Statistic) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic) GetTotalPackets() uint64 {
	if x != nil {
		return x.TotalPackets
	}
	return 0
}

type FlowMeasureReadResponse_Statistic_Histogram struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Count              uint64                 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`                                   /// Total # of measured data points, including above_range
	AboveRange         uint64                 `protobuf:"varint,2,opt,name=above_range,json=aboveRange,proto3" json:"above_range,omitempty"`       /// # of data points for the "too large value" bucket
	ResolutionNs       uint64                 `protobuf:"varint,8,opt,name=resolution_ns,json=resolutionNs,proto3" json:"resolution_ns,omitempty"` /// resolution of measured data
	MinNs              uint64                 `protobuf:"varint,3,opt,name=min_ns,json=minNs,proto3" json:"min_ns,omitempty"`
	AvgNs              uint64                 `protobuf:"varint,4,opt,name=avg_ns,json=avgNs,proto3" json:"avg_ns,omitempty"`
	MaxNs              uint64                 `protobuf:"varint,5,opt,name=max_ns,json=maxNs,proto3" json:"max_ns,omitempty"`
	TotalNs            uint64                 `protobuf:"varint,6,opt,name=total_ns,json=totalNs,proto3" json:"total_ns,omitempty"`
	PercentileValuesNs []uint64               `protobuf:"varint,7,rep,packed,name=percentile_values_ns,json=percentileValuesNs,proto3" json:"percentile_values_ns,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) Reset() {
	*x = FlowMeasureReadResponse_Statistic_Histogram{}
	mi := &file_module_msg_proto_msgTypes[134]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowMeasureReadResponse_Statistic_Histogram) ProtoMessage() {}

func (x *FlowMeasureReadResponse_Statistic_Histogram) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[134]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowMeasureReadResponse_Statistic_Histogram.ProtoReflect.Descriptor instead.
func (*FlowMeasureReadResponse_Statistic_Histogram) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{109, 0, 0}
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) GetCount() uint64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) GetAboveRange() uint64 {
	if x != nil {
		return x.AboveRange
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) GetResolutionNs() uint64 {
	if x != nil {
		return x.ResolutionNs
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) GetMinNs() uint64 {
	if x != nil {
		return x.MinNs
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) GetAvgNs() uint64 {
	if x != nil {
		return x.AvgNs
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) GetMaxNs() uint64 {
	if x != nil {
		return x.MaxNs
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) GetTotalNs() uint64 {
	if x != nil {
		return x.TotalNs
	}
	return 0
}

func (x *FlowMeasureReadResponse_Statistic_Histogram) GetPercentileValuesNs() []uint64 {
	if x != nil {
		return x.PercentileValuesNs
	}
	return nil
}

type GtpuPathMonitoringCommandReadResponse_Statistic struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	GnbIp         uint32                 `protobuf:"varint,1,opt,name=gnb_ip,json=gnbIp,proto3" json:"gnb_ip,omitempty"`                   /// gNB IP
	Count         uint64                 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`                                /// count
	LatencyMin    uint64                 `protobuf:"varint,3,opt,name=latency_min,json=latencyMin,proto3" json:"latency_min,omitempty"`    /// minimum latency
	LatencyMean   uint64                 `protobuf:"varint,4,opt,name=latency_mean,json=latencyMean,proto3" json:"latency_mean,omitempty"` /// average latency
	LatencyMax    uint64                 `protobuf:"varint,5,opt,name=latency_max,json=latencyMax,proto3" json:"latency_max,omitempty"`    /// maximum latency
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GtpuPathMonitoringCommandReadResponse_Statistic) Reset() {
	*x = GtpuPathMonitoringCommandReadResponse_Statistic{}
	mi := &file_module_msg_proto_msgTypes[135]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GtpuPathMonitoringCommandReadResponse_Statistic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GtpuPathMonitoringCommandReadResponse_Statistic) ProtoMessage() {}

func (x *GtpuPathMonitoringCommandReadResponse_Statistic) ProtoReflect() protoreflect.Message {
	mi := &file_module_msg_proto_msgTypes[135]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GtpuPathMonitoringCommandReadResponse_Statistic.ProtoReflect.Descriptor instead.
func (*GtpuPathMonitoringCommandReadResponse_Statistic) Descriptor() ([]byte, []int) {
	return file_module_msg_proto_rawDescGZIP(), []int{115, 0}
}

func (x *GtpuPathMonitoringCommandReadResponse_Statistic) GetGnbIp() uint32 {
	if x != nil {
		return x.GnbIp
	}
	return 0
}

func (x *GtpuPathMonitoringCommandReadResponse_Statistic) GetCount() uint64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *GtpuPathMonitoringCommandReadResponse_Statistic) GetLatencyMin() uint64 {
	if x != nil {
		return x.LatencyMin
	}
	return 0
}

func (x *GtpuPathMonitoringCommandReadResponse_Statistic) GetLatencyMean() uint64 {
	if x != nil {
		return x.LatencyMean
	}
	return 0
}

func (x *GtpuPathMonitoringCommandReadResponse_Statistic) GetLatencyMax() uint64 {
	if x != nil {
		return x.LatencyMax
	}
	return 0
}

var File_module_msg_proto protoreflect.FileDescriptor

const file_module_msg_proto_rawDesc = "" +
	"\n" +
	"\x10module_msg.proto\x12\abess.pb\x1a\x0eutil_msg.proto\"\n" +
	"\n" +
	"\bEmptyArg\"\x14\n" +
	"\x12BPFCommandClearArg\"\x85\x01\n" +
	"\x17ExactMatchCommandAddArg\x12\x12\n" +
	"\x04gate\x18\x01 \x01(\x04R\x04gate\x12*\n" +
	"\x06fields\x18\x02 \x03(\v2\x12.bess.pb.FieldDataR\x06fields\x12*\n" +
	"\x06values\x18\x03 \x03(\v2\x12.bess.pb.FieldDataR\x06values\"H\n" +
	"\x1aExactMatchCommandDeleteArg\x12*\n" +
	"\x06fields\x18\x02 \x03(\v2\x12.bess.pb.FieldDataR\x06fields\"\x1b\n" +
	"\x19ExactMatchCommandClearArg\"8\n" +
	"\"ExactMatchCommandSetDefaultGateArg\x12\x12\n" +
	"\x04gate\x18\x01 \x01(\x04R\x04gate\"1\n" +
	"\x19FlowGenCommandSetBurstArg\x12\x14\n" +
	"\x05burst\x18\x01 \x01(\x04R\x05burst\"U\n" +
	"\x17HashLBCommandSetModeArg\x12\x12\n" +
	"\x04mode\x18\x01 \x01(\tR\x04mode\x12&\n" +
	"\x06fields\x18\x02 \x03(\v2\x0e.bess.pb.FieldR\x06fields\"0\n" +
	"\x18HashLBCommandSetGatesArg\x12\x14\n" +
	"\x05gates\x18\x01 \x03(\x03R\x05gates\"b\n" +
	"\x15IPLookupCommandAddArg\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x1d\n" +
	"\n" +
	"prefix_len\x18\x02 \x01(\x04R\tprefixLen\x12\x12\n" +
	"\x04gate\x18\x03 \x01(\x04R\x04gate\"Q\n" +
	"\x18IPLookupCommandDeleteArg\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x1d\n" +
	"\n" +
	"prefix_len\x18\x02 \x01(\x04R\tprefixLen\"\x19\n" +
	"\x17IPLookupCommandClearArg\"\x8a\x01\n" +
	"\x16L2ForwardCommandAddArg\x12?\n" +
	"\aentries\x18\x01 \x03(\v2%.bess.pb.L2ForwardCommandAddArg.EntryR\aentries\x1a/\n" +
	"\x05Entry\x12\x12\n" +
	"\x04addr\x18\x01 \x01(\tR\x04addr\x12\x12\n" +
	"\x04gate\x18\x02 \x01(\x03R\x04gate\"1\n" +
	"\x19L2ForwardCommandDeleteArg\x12\x14\n" +
	"\x05addrs\x18\x01 \x03(\tR\x05addrs\"7\n" +
	"!L2ForwardCommandSetDefaultGateArg\x12\x12\n" +
	"\x04gate\x18\x01 \x01(\x03R\x04gate\"1\n" +
	"\x19L2ForwardCommandLookupArg\x12\x14\n" +
	"\x05addrs\x18\x01 \x03(\tR\x05addrs\"6\n" +
	"\x1eL2ForwardCommandLookupResponse\x12\x14\n" +
	"\x05gates\x18\x01 \x03(\x04R\x05gates\"f\n" +
	"\x1bL2ForwardCommandPopulateArg\x12\x12\n" +
	"\x04base\x18\x01 \x01(\tR\x04base\x12\x14\n" +
	"\x05count\x18\x02 \x01(\x03R\x05count\x12\x1d\n" +
	"\n" +
	"gate_count\x18\x03 \x01(\x03R\tgateCount\"\x93\x01\n" +
	"\x1bMeasureCommandGetSummaryArg\x12\x14\n" +
	"\x05clear\x18\x01 \x01(\bR\x05clear\x12/\n" +
	"\x13latency_percentiles\x18\x02 \x03(\x01R\x12latencyPercentiles\x12-\n" +
	"\x12jitter_percentiles\x18\x03 \x03(\x01R\x11jitterPercentiles\"\x86\x04\n" +
	" MeasureCommandGetSummaryResponse\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x01R\ttimestamp\x12\x18\n" +
	"\apackets\x18\x02 \x01(\x04R\apackets\x12\x12\n" +
	"\x04bits\x18\x03 \x01(\x04R\x04bits\x12M\n" +
	"\alatency\x18\x04 \x01(\v23.bess.pb.MeasureCommandGetSummaryResponse.HistogramR\alatency\x12K\n" +
	"\x06jitter\x18\x05 \x01(\v23.bess.pb.MeasureCommandGetSummaryResponse.HistogramR\x06jitter\x1a\xf9\x01\n" +
	"\tHistogram\x12\x14\n" +
	"\x05count\x18\x01 \x01(\x04R\x05count\x12\x1f\n" +
	"\vabove_range\x18\x02 \x01(\x04R\n" +
	"aboveRange\x12#\n" +
	"\rresolution_ns\x18\b \x01(\x04R\fresolutionNs\x12\x15\n" +
	"\x06min_ns\x18\x03 \x01(\x04R\x05minNs\x12\x15\n" +
	"\x06avg_ns\x18\x04 \x01(\x04R\x05avgNs\x12\x15\n" +
	"\x06max_ns\x18\x05 \x01(\x04R\x05maxNs\x12\x19\n" +
	"\btotal_ns\x18\x06 \x01(\x04R\atotalNs\x120\n" +
	"\x14percentile_values_ns\x18\a \x03(\x04R\x12percentileValuesNs\"n\n" +
	"\x06DRRArg\x12\x1b\n" +
	"\tnum_flows\x18\x01 \x01(\rR\bnumFlows\x12\x18\n" +
	"\aquantum\x18\x02 \x01(\x04R\aquantum\x12-\n" +
	"\x13max_flow_queue_size\x18\x03 \x01(\rR\x10maxFlowQueueSize\")\n" +
	"\rDRRQuantumArg\x12\x18\n" +
	"\aquantum\x18\x01 \x01(\rR\aquantum\">\n" +
	"\x16DRRMaxFlowQueueSizeArg\x12$\n" +
	"\x0emax_queue_size\x18\x01 \x01(\rR\fmaxQueueSize\"1\n" +
	"\x19PortIncCommandSetBurstArg\x12\x14\n" +
	"\x05burst\x18\x01 \x01(\x04R\x05burst\"2\n" +
	"\x1aQueueIncCommandSetBurstArg\x12\x14\n" +
	"\x05burst\x18\x01 \x01(\x04R\x05burst\"/\n" +
	"\x17QueueCommandSetBurstArg\x12\x14\n" +
	"\x05burst\x18\x01 \x01(\x04R\x05burst\",\n" +
	"\x16QueueCommandSetSizeArg\x12\x12\n" +
	"\x04size\x18\x01 \x01(\x04R\x04size\"\x1a\n" +
	"\x18QueueCommandGetStatusArg\"\x9b\x01\n" +
	"\x1dQueueCommandGetStatusResponse\x12\x14\n" +
	"\x05count\x18\x01 \x01(\x04R\x05count\x12\x12\n" +
	"\x04size\x18\x02 \x01(\x04R\x04size\x12\x1a\n" +
	"\benqueued\x18\x03 \x01(\x04R\benqueued\x12\x1a\n" +
	"\bdequeued\x18\x04 \x01(\x04R\bdequeued\x12\x18\n" +
	"\adropped\x18\x05 \x01(\x04R\adropped\"\x1d\n" +
	"\x1bRandomUpdateCommandClearArg\"\x18\n" +
	"\x16RewriteCommandClearArg\"\x17\n" +
	"\x15UpdateCommandClearArg\"\xd0\x01\n" +
	"\x1aWildcardMatchCommandAddArg\x12\x12\n" +
	"\x04gate\x18\x01 \x01(\x04R\x04gate\x12\x1a\n" +
	"\bpriority\x18\x02 \x01(\x03R\bpriority\x12*\n" +
	"\x06values\x18\x03 \x03(\v2\x12.bess.pb.FieldDataR\x06values\x12(\n" +
	"\x05masks\x18\x04 \x03(\v2\x12.bess.pb.FieldDataR\x05masks\x12,\n" +
	"\avaluesv\x18\x05 \x03(\v2\x12.bess.pb.FieldDataR\avaluesv\"u\n" +
	"\x1dWildcardMatchCommandDeleteArg\x12*\n" +
	"\x06values\x18\x01 \x03(\v2\x12.bess.pb.FieldDataR\x06values\x12(\n" +
	"\x05masks\x18\x02 \x03(\v2\x12.bess.pb.FieldDataR\x05masks\"\x1e\n" +
	"\x1cWildcardMatchCommandClearArg\";\n" +
	"%WildcardMatchCommandSetDefaultGateArg\x12\x12\n" +
	"\x04gate\x18\x01 \x01(\x04R\x04gate\"\xd7\x01\n" +
	"\x06ACLArg\x12*\n" +
	"\x05rules\x18\x01 \x03(\v2\x14.bess.pb.ACLArg.RuleR\x05rules\x1a\xa0\x01\n" +
	"\x04Rule\x12\x15\n" +
	"\x06src_ip\x18\x01 \x01(\tR\x05srcIp\x12\x15\n" +
	"\x06dst_ip\x18\x02 \x01(\tR\x05dstIp\x12\x19\n" +
	"\bsrc_port\x18\x03 \x01(\rR\asrcPort\x12\x19\n" +
	"\bdst_port\x18\x04 \x01(\rR\adstPort\x12 \n" +
	"\vestablished\x18\x05 \x01(\bR\vestablished\x12\x12\n" +
	"\x04drop\x18\x06 \x01(\bR\x04drop\"\x8c\x01\n" +
	"\x06BPFArg\x120\n" +
	"\afilters\x18\x01 \x03(\v2\x16.bess.pb.BPFArg.FilterR\afilters\x1aP\n" +
	"\x06Filter\x12\x1a\n" +
	"\bpriority\x18\x01 \x01(\x03R\bpriority\x12\x16\n" +
	"\x06filter\x18\x02 \x01(\tR\x06filter\x12\x12\n" +
	"\x04gate\x18\x03 \x01(\x03R\x04gate\"\v\n" +
	"\tBufferArg\"\x89\x01\n" +
	"\tBypassArg\x12(\n" +
	"\x10cycles_per_batch\x18\x01 \x01(\rR\x0ecyclesPerBatch\x12*\n" +
	"\x11cycles_per_packet\x18\x02 \x01(\rR\x0fcyclesPerPacket\x12&\n" +
	"\x0fcycles_per_byte\x18\x03 \x01(\rR\rcyclesPerByte\"%\n" +
	"\aDumpArg\x12\x1a\n" +
	"\binterval\x18\x01 \x01(\x01R\binterval\"\x0f\n" +
	"\rEtherEncapArg\"\xcf\x01\n" +
	"\rExactMatchArg\x12&\n" +
	"\x06fields\x18\x01 \x03(\v2\x0e.bess.pb.FieldR\x06fields\x12(\n" +
	"\x05masks\x18\x02 \x03(\v2\x12.bess.pb.FieldDataR\x05masks\x12&\n" +
	"\x06values\x18\x03 \x03(\v2\x0e.bess.pb.FieldR\x06values\x12*\n" +
	"\x06masksv\x18\x04 \x03(\v2\x12.bess.pb.FieldDataR\x06masksv\x12\x18\n" +
	"\aentries\x18\x05 \x01(\x04R\aentries\"m\n" +
	"\x10ExactMatchConfig\x12!\n" +
	"\fdefault_gate\x18\x01 \x01(\x04R\vdefaultGate\x126\n" +
	"\x05rules\x18\x02 \x03(\v2 .bess.pb.ExactMatchCommandAddArgR\x05rules\"\xe5\x02\n" +
	"\n" +
	"FlowGenArg\x12\x1a\n" +
	"\btemplate\x18\x01 \x01(\fR\btemplate\x12\x10\n" +
	"\x03pps\x18\x02 \x01(\x01R\x03pps\x12\x1b\n" +
	"\tflow_rate\x18\x03 \x01(\x01R\bflowRate\x12#\n" +
	"\rflow_duration\x18\x04 \x01(\x01R\fflowDuration\x12\x18\n" +
	"\aarrival\x18\x05 \x01(\tR\aarrival\x12\x1a\n" +
	"\bduration\x18\x06 \x01(\tR\bduration\x12!\n" +
	"\fquick_rampup\x18\a \x01(\bR\vquickRampup\x12 \n" +
	"\fip_src_range\x18\b \x01(\rR\n" +
	"ipSrcRange\x12 \n" +
	"\fip_dst_range\x18\t \x01(\rR\n" +
	"ipDstRange\x12$\n" +
	"\x0eport_src_range\x18\n" +
	" \x01(\rR\fportSrcRange\x12$\n" +
	"\x0eport_dst_range\x18\v \x01(\rR\fportDstRange\"'\n" +
	"\x0fGenericDecapArg\x12\x14\n" +
	"\x05bytes\x18\x01 \x01(\x04R\x05bytes\"\xc9\x01\n" +
	"\x0fGenericEncapArg\x12;\n" +
	"\x06fields\x18\x01 \x03(\v2#.bess.pb.GenericEncapArg.EncapFieldR\x06fields\x1ay\n" +
	"\n" +
	"EncapField\x12\x12\n" +
	"\x04size\x18\x01 \x01(\x04R\x04size\x12\x1e\n" +
	"\tattribute\x18\x02 \x01(\tH\x00R\tattribute\x12*\n" +
	"\x05value\x18\x03 \x01(\v2\x12.bess.pb.FieldDataH\x00R\x05valueB\v\n" +
	"\tinsertion\"]\n" +
	"\tHashLBArg\x12\x14\n" +
	"\x05gates\x18\x01 \x03(\x03R\x05gates\x12\x12\n" +
	"\x04mode\x18\x02 \x01(\tR\x04mode\x12&\n" +
	"\x06fields\x18\x03 \x03(\v2\x0e.bess.pb.FieldR\x06fields\"\f\n" +
	"\n" +
	"IPEncapArg\"G\n" +
	"\vIPLookupArg\x12\x1b\n" +
	"\tmax_rules\x18\x01 \x01(\rR\bmaxRules\x12\x1b\n" +
	"\tmax_tbl8s\x18\x02 \x01(\rR\bmaxTbl8s\":\n" +
	"\fL2ForwardArg\x12\x12\n" +
	"\x04size\x18\x01 \x01(\x03R\x04size\x12\x16\n" +
	"\x06bucket\x18\x02 \x01(\x03R\x06bucket\"\f\n" +
	"\n" +
	"MACSwapArg\"\xd5\x01\n" +
	"\n" +
	"MeasureArg\x12\x18\n" +
	"\x06offset\x18\x02 \x01(\x04H\x00R\x06offset\x12\x1d\n" +
	"\tattr_name\x18\x06 \x01(\tH\x00R\battrName\x12,\n" +
	"\x12jitter_sample_prob\x18\x03 \x01(\x01R\x10jitterSampleProb\x12$\n" +
	"\x0elatency_ns_max\x18\x04 \x01(\x04R\flatencyNsMax\x122\n" +
	"\x15latency_ns_resolution\x18\x05 \x01(\rR\x13latencyNsResolutionB\x06\n" +
	"\x04type\"\n" +
	"\n" +
	"\bMergeArg\"\xf0\x02\n" +
	"\x0fMetadataTestArg\x126\n" +
	"\x04read\x18\x01 \x03(\v2\".bess.pb.MetadataTestArg.ReadEntryR\x04read\x129\n" +
	"\x05write\x18\x02 \x03(\v2#.bess.pb.MetadataTestArg.WriteEntryR\x05write\x12<\n" +
	"\x06update\x18\x03 \x03(\v2$.bess.pb.MetadataTestArg.UpdateEntryR\x06update\x1a7\n" +
	"\tReadEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\x1a8\n" +
	"\n" +
	"WriteEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\x1a9\n" +
	"\vUpdateEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\"\x83\x02\n" +
	"\x06NATArg\x12<\n" +
	"\text_addrs\x18\x01 \x03(\v2\x1f.bess.pb.NATArg.ExternalAddressR\bextAddrs\x1aQ\n" +
	"\tPortRange\x12\x14\n" +
	"\x05begin\x18\x01 \x01(\rR\x05begin\x12\x10\n" +
	"\x03end\x18\x02 \x01(\rR\x03end\x12\x1c\n" +
	"\tsuspended\x18\x03 \x01(\bR\tsuspended\x1ah\n" +
	"\x0fExternalAddress\x12\x19\n" +
	"\bext_addr\x18\x01 \x01(\tR\aextAddr\x12:\n" +
	"\vport_ranges\x18\x02 \x03(\v2\x19.bess.pb.NATArg.PortRangeR\n" +
	"portRanges\"\x9b\x02\n" +
	"\fStaticNATArg\x12<\n" +
	"\x05pairs\x18\x01 \x03(\v2&.bess.pb.StaticNATArg.AddressRangePairR\x05pairs\x1a6\n" +
	"\fAddressRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\tR\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\tR\x03end\x1a\x94\x01\n" +
	"\x10AddressRangePair\x12?\n" +
	"\tint_range\x18\x01 \x01(\v2\".bess.pb.StaticNATArg.AddressRangeR\bintRange\x12?\n" +
	"\text_range\x18\x02 \x01(\v2\".bess.pb.StaticNATArg.AddressRangeR\bextRange\"\t\n" +
	"\aNoOpArg\"<\n" +
	"\n" +
	"PortIncArg\x12\x12\n" +
	"\x04port\x18\x01 \x01(\tR\x04port\x12\x1a\n" +
	"\bprefetch\x18\x02 \x01(\bR\bprefetch\" \n" +
	"\n" +
	"PortOutArg\x12\x12\n" +
	"\x04port\x18\x01 \x01(\tR\x04port\"O\n" +
	"\vQueueIncArg\x12\x12\n" +
	"\x04port\x18\x01 \x01(\tR\x04port\x12\x10\n" +
	"\x03qid\x18\x02 \x01(\x04R\x03qid\x12\x1a\n" +
	"\bprefetch\x18\x03 \x01(\bR\bprefetch\"3\n" +
	"\vQueueOutArg\x12\x12\n" +
	"\x04port\x18\x01 \x01(\tR\x04port\x12\x10\n" +
	"\x03qid\x18\x02 \x01(\x04R\x03qid\"^\n" +
	"\bQueueArg\x12\x12\n" +
	"\x04size\x18\x01 \x01(\x04R\x04size\x12\x1a\n" +
	"\bprefetch\x18\x02 \x01(\bR\bprefetch\x12\"\n" +
	"\fbackpressure\x18\x03 \x01(\bR\fbackpressure\"C\n" +
	"\x0eRandomSplitArg\x12\x1b\n" +
	"\tdrop_rate\x18\x01 \x01(\x01R\bdropRate\x12\x14\n" +
	"\x05gates\x18\x02 \x03(\x03R\x05gates\"?\n" +
	" RandomSplitCommandSetDroprateArg\x12\x1b\n" +
	"\tdrop_rate\x18\x01 \x01(\x01R\bdropRate\"5\n" +
	"\x1dRandomSplitCommandSetGatesArg\x12\x14\n" +
	"\x05gates\x18\x01 \x03(\x03R\x05gates\"\xa2\x01\n" +
	"\x0fRandomUpdateArg\x126\n" +
	"\x06fields\x18\x01 \x03(\v2\x1e.bess.pb.RandomUpdateArg.FieldR\x06fields\x1aW\n" +
	"\x05Field\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x03R\x06offset\x12\x12\n" +
	"\x04size\x18\x02 \x01(\x04R\x04size\x12\x10\n" +
	"\x03min\x18\x03 \x01(\x04R\x03min\x12\x10\n" +
	"\x03max\x18\x04 \x01(\x04R\x03max\"*\n" +
	"\n" +
	"RewriteArg\x12\x1c\n" +
	"\ttemplates\x18\x01 \x03(\fR\ttemplates\"4\n" +
	"\x1cRoundRobinCommandSetGatesArg\x12\x14\n" +
	"\x05gates\x18\x01 \x03(\x03R\x05gates\"1\n" +
	"\x1bRoundRobinCommandSetModeArg\x12\x12\n" +
	"\x04mode\x18\x01 \x01(\tR\x04mode\"9\n" +
	"\rRoundRobinArg\x12\x14\n" +
	"\x05gates\x18\x01 \x03(\x03R\x05gates\x12\x12\n" +
	"\x04mode\x18\x02 \x01(\tR\x04mode\"$\n" +
	"\fReplicateArg\x12\x14\n" +
	"\x05gates\x18\x01 \x03(\x03R\x05gates\"3\n" +
	"\x1bReplicateCommandSetGatesArg\x12\x14\n" +
	"\x05gates\x18\x01 \x03(\x03R\x05gates\"\x93\x02\n" +
	"\x0eSetMetadataArg\x127\n" +
	"\x05attrs\x18\x01 \x03(\v2!.bess.pb.SetMetadataArg.AttributeR\x05attrs\x1a\xc7\x01\n" +
	"\tAttribute\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04size\x18\x02 \x01(\x04R\x04size\x12\x1d\n" +
	"\tvalue_int\x18\x03 \x01(\x04H\x00R\bvalueInt\x12\x1d\n" +
	"\tvalue_bin\x18\x04 \x01(\fH\x00R\bvalueBin\x12\x16\n" +
	"\x06offset\x18\x05 \x01(\x05R\x06offset\x12\x12\n" +
	"\x04mask\x18\x06 \x01(\fR\x04mask\x12\x1f\n" +
	"\vrshift_bits\x18\a \x01(\x05R\n" +
	"rshiftBitsB\a\n" +
	"\x05value\"\t\n" +
	"\aSinkArg\"0\n" +
	"\x18SourceCommandSetBurstArg\x12\x14\n" +
	"\x05burst\x18\x01 \x01(\x04R\x05burst\"7\n" +
	"\x1aSourceCommandSetPktSizeArg\x12\x19\n" +
	"\bpkt_size\x18\x01 \x01(\x04R\apktSize\"&\n" +
	"\tSourceArg\x12\x19\n" +
	"\bpkt_size\x18\x01 \x01(\x04R\apktSize\"7\n" +
	"\rIPChecksumArg\x12\x16\n" +
	"\x06verify\x18\x01 \x01(\bR\x06verify\x12\x0e\n" +
	"\x02hw\x18\x02 \x01(\bR\x02hw\"7\n" +
	"\rL4ChecksumArg\x12\x16\n" +
	"\x06verify\x18\x01 \x01(\bR\x06verify\x12\x0e\n" +
	"\x02hw\x18\x02 \x01(\bR\x02hw\"+\n" +
	"\vGtpuEchoArg\x12\x1c\n" +
	"\n" +
	"s1u_sgw_ip\x18\x01 \x01(\rR\bs1uSgwIp\">\n" +
	"\vIPDefragArg\x12\x1b\n" +
	"\tnum_flows\x18\x01 \x01(\rR\bnumFlows\x12\x12\n" +
	"\x04numa\x18\x02 \x01(\x05R\x04numa\"\x1d\n" +
	"\tIPFragArg\x12\x10\n" +
	"\x03mtu\x18\x01 \x01(\x05R\x03mtu\"&\n" +
	"\rCounterAddArg\x12\x15\n" +
	"\x06ctr_id\x18\x01 \x01(\rR\x05ctrId\")\n" +
	"\x10CounterRemoveArg\x12\x15\n" +
	"\x06ctr_id\x18\x01 \x01(\rR\x05ctrId\"\\\n" +
	"\n" +
	"CounterArg\x12\x17\n" +
	"\aname_id\x18\x01 \x01(\tR\x06nameId\x12\x1f\n" +
	"\vcheck_exist\x18\x02 \x01(\bR\n" +
	"checkExist\x12\x14\n" +
	"\x05total\x18\x03 \x01(\rR\x05total\"'\n" +
	"\fGtpuEncapArg\x12\x17\n" +
	"\aadd_psc\x18\x01 \x01(\bR\x06addPsc\"`\n" +
	"\bSplitArg\x12\x12\n" +
	"\x04size\x18\x01 \x01(\x04R\x04size\x12\x1e\n" +
	"\tattribute\x18\x02 \x01(\tH\x00R\tattribute\x12\x18\n" +
	"\x06offset\x18\x03 \x01(\x03H\x00R\x06offsetB\x06\n" +
	"\x04type\"O\n" +
	"\fTimestampArg\x12\x18\n" +
	"\x06offset\x18\x01 \x01(\x04H\x00R\x06offset\x12\x1d\n" +
	"\tattr_name\x18\x02 \x01(\tH\x00R\battrNameB\x06\n" +
	"\x04type\"\x88\x01\n" +
	"\tUpdateArg\x120\n" +
	"\x06fields\x18\x01 \x03(\v2\x18.bess.pb.UpdateArg.FieldR\x06fields\x1aI\n" +
	"\x05Field\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x03R\x06offset\x12\x12\n" +
	"\x04size\x18\x02 \x01(\x04R\x04size\x12\x14\n" +
	"\x05value\x18\x03 \x01(\x04R\x05value\"v\n" +
	"\fUrlFilterArg\x127\n" +
	"\tblacklist\x18\x01 \x03(\v2\x19.bess.pb.UrlFilterArg.UrlR\tblacklist\x1a-\n" +
	"\x03Url\x12\x12\n" +
	"\x04host\x18\x01 \x01(\tR\x04host\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\"J\n" +
	"\x0fUrlFilterConfig\x127\n" +
	"\tblacklist\x18\x01 \x03(\v2\x19.bess.pb.UrlFilterArg.UrlR\tblacklist\"\f\n" +
	"\n" +
	"VLANPopArg\"\x1f\n" +
	"\vVLANPushArg\x12\x10\n" +
	"\x03tci\x18\x01 \x01(\x04R\x03tci\"\x0e\n" +
	"\fVLANSplitArg\"\x0f\n" +
	"\rVXLANDecapArg\")\n" +
	"\rVXLANEncapArg\x12\x18\n" +
	"\adstport\x18\x01 \x01(\x04R\adstport\"|\n" +
	"\x10WildcardMatchArg\x12&\n" +
	"\x06fields\x18\x01 \x03(\v2\x0e.bess.pb.FieldR\x06fields\x12&\n" +
	"\x06values\x18\x02 \x03(\v2\x0e.bess.pb.FieldR\x06values\x12\x18\n" +
	"\aentries\x18\x03 \x01(\x04R\aentries\"s\n" +
	"\x13WildcardMatchConfig\x12!\n" +
	"\fdefault_gate\x18\x01 \x01(\x04R\vdefaultGate\x129\n" +
	"\x05rules\x18\x02 \x03(\v2#.bess.pb.WildcardMatchCommandAddArgR\x05rules\"<\n" +
	"\x0fArpResponderArg\x12\x0e\n" +
	"\x02ip\x18\x01 \x01(\tR\x02ip\x12\x19\n" +
	"\bmac_addr\x18\x02 \x01(\tR\amacAddr\"\\\n" +
	"\n" +
	"MplsPopArg\x12*\n" +
	"\x11remove_eth_header\x18\x01 \x01(\bR\x0fremoveEthHeader\x12\"\n" +
	"\rnext_eth_type\x18\x02 \x01(\rR\vnextEthType\"\x9d\x01\n" +
	"\x0eWorkerSplitArg\x12K\n" +
	"\fworker_gates\x18\x01 \x03(\v2(.bess.pb.WorkerSplitArg.WorkerGatesEntryR\vworkerGates\x1a>\n" +
	"\x10WorkerGatesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\rR\x05value:\x028\x01\"r\n" +
	"\x06QosArg\x12&\n" +
	"\x06fields\x18\x01 \x03(\v2\x0e.bess.pb.FieldR\x06fields\x12&\n" +
	"\x06values\x18\x02 \x03(\v2\x0e.bess.pb.FieldR\x06values\x12\x18\n" +
	"\aentries\x18\x03 \x01(\x04R\aentries\"\x90\x02\n" +
	"\x10QosCommandAddArg\x12\x12\n" +
	"\x04gate\x18\x01 \x01(\x04R\x04gate\x12\x10\n" +
	"\x03cir\x18\x02 \x01(\x04R\x03cir\x12\x10\n" +
	"\x03pir\x18\x03 \x01(\x04R\x03pir\x12\x10\n" +
	"\x03cbs\x18\x04 \x01(\x04R\x03cbs\x12\x10\n" +
	"\x03pbs\x18\x05 \x01(\x04R\x03pbs\x12\x10\n" +
	"\x03ebs\x18\x06 \x01(\x04R\x03ebs\x12\x1f\n" +
	"\n" +
	"deduct_len\x18\t \x01(\x03H\x00R\tdeductLen\x12*\n" +
	"\x06fields\x18\a \x03(\v2\x12.bess.pb.FieldDataR\x06fields\x12*\n" +
	"\x06values\x18\b \x03(\v2\x12.bess.pb.FieldDataR\x06valuesB\x15\n" +
	"\x13optional_deduct_len\"A\n" +
	"\x13QosCommandDeleteArg\x12*\n" +
	"\x06fields\x18\x02 \x03(\v2\x12.bess.pb.FieldDataR\x06fields\"\x14\n" +
	"\x12QosCommandClearArg\"1\n" +
	"\x1bQosCommandSetDefaultGateArg\x12\x12\n" +
	"\x04gate\x18\x01 \x01(\x04R\x04gate\"h\n" +
	"\x0eFlowMeasureArg\x12$\n" +
	"\x0eflag_attr_name\x18\x01 \x01(\tR\fflagAttrName\x12\x18\n" +
	"\aentries\x18\x02 \x01(\x04R\aentries\x12\x16\n" +
	"\x06leader\x18\x03 \x01(\bR\x06leader\"\xb3\x01\n" +
	"\x19FlowMeasureCommandReadArg\x12\x14\n" +
	"\x05clear\x18\x01 \x01(\bR\x05clear\x12/\n" +
	"\x13latency_percentiles\x18\x02 \x03(\x01R\x12latencyPercentiles\x12-\n" +
	"\x12jitter_percentiles\x18\x03 \x03(\x01R\x11jitterPercentiles\x12 \n" +
	"\fflag_to_read\x18\x04 \x01(\x04R\n" +
	"flagToRead\"\xfb\x04\n" +
	"\x17FlowMeasureReadResponse\x12J\n" +
	"\n" +
	"statistics\x18\x01 \x03(\v2*.bess.pb.FlowMeasureReadResponse.StatisticR\n" +
	"statistics\x1a\x93\x04\n" +
	"\tStatistic\x12\x14\n" +
	"\x05fseid\x18\x01 \x01(\x04R\x05fseid\x12\x10\n" +
	"\x03pdr\x18\x02 \x01(\x04R\x03pdr\x12N\n" +
	"\alatency\x18\x03 \x01(\v24.bess.pb.FlowMeasureReadResponse.Statistic.HistogramR\alatency\x12L\n" +
	"\x06jitter\x18\x04 \x01(\v24.bess.pb.FlowMeasureReadResponse.Statistic.HistogramR\x06jitter\x12\x1f\n" +
	"\vtotal_bytes\x18\v \x01(\x04R\n" +
	"totalBytes\x12#\n" +
	"\rtotal_packets\x18\f \x01(\x04R\ftotalPackets\x1a\xf9\x01\n" +
	"\tHistogram\x12\x14\n" +
	"\x05count\x18\x01 \x01(\x04R\x05count\x12\x1f\n" +
	"\vabove_range\x18\x02 \x01(\x04R\n" +
	"aboveRange\x12#\n" +
	"\rresolution_ns\x18\b \x01(\x04R\fresolutionNs\x12\x15\n" +
	"\x06min_ns\x18\x03 \x01(\x04R\x05minNs\x12\x15\n" +
	"\x06avg_ns\x18\x04 \x01(\x04R\x05avgNs\x12\x15\n" +
	"\x06max_ns\x18\x05 \x01(\x04R\x05maxNs\x12\x19\n" +
	"\btotal_ns\x18\x06 \x01(\x04R\atotalNs\x120\n" +
	"\x14percentile_values_ns\x18\a \x03(\x04R\x12percentileValuesNs\"\x1b\n" +
	"\x19FlowMeasureCommandFlipArg\"4\n" +
	"\x17FlowMeasureFlipResponse\x12\x19\n" +
	"\bold_flag\x18\x01 \x01(\x04R\aoldFlag\">\n" +
	"%GtpuPathMonitoringCommandAddDeleteArg\x12\x15\n" +
	"\x06gnb_ip\x18\x01 \x01(\rR\x05gnbIp\"#\n" +
	"!GtpuPathMonitoringCommandClearArg\"8\n" +
	" GtpuPathMonitoringCommandReadArg\x12\x14\n" +
	"\x05clear\x18\x01 \x01(\bR\x05clear\"\xa1\x02\n" +
	"%GtpuPathMonitoringCommandReadResponse\x12X\n" +
	"\n" +
	"statistics\x18\x01 \x03(\v28.bess.pb.GtpuPathMonitoringCommandReadResponse.StatisticR\n" +
	"statistics\x1a\x9d\x01\n" +
	"\tStatistic\x12\x15\n" +
	"\x06gnb_ip\x18\x01 \x01(\rR\x05gnbIp\x12\x14\n" +
	"\x05count\x18\x02 \x01(\x04R\x05count\x12\x1f\n" +
	"\vlatency_min\x18\x03 \x01(\x04R\n" +
	"latencyMin\x12!\n" +
	"\flatency_mean\x18\x04 \x01(\x04R\vlatencyMean\x12\x1f\n" +
	"\vlatency_max\x18\x05 \x01(\x04R\n" +
	"latencyMaxB3Z1github.com/omec-project/upf-epc/pfcpiface/bess_pbb\x06proto3"

var (
	file_module_msg_proto_rawDescOnce sync.Once
	file_module_msg_proto_rawDescData []byte
)

func file_module_msg_proto_rawDescGZIP() []byte {
	file_module_msg_proto_rawDescOnce.Do(func() {
		file_module_msg_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_module_msg_proto_rawDesc), len(file_module_msg_proto_rawDesc)))
	})
	return file_module_msg_proto_rawDescData
}

var file_module_msg_proto_msgTypes = make([]protoimpl.MessageInfo, 136)
var file_module_msg_proto_goTypes = []any{
	(*EmptyArg)(nil),                                        // 0: bess.pb.EmptyArg
	(*BPFCommandClearArg)(nil),                              // 1: bess.pb.BPFCommandClearArg
	(*ExactMatchCommandAddArg)(nil),                         // 2: bess.pb.ExactMatchCommandAddArg
	(*ExactMatchCommandDeleteArg)(nil),                      // 3: bess.pb.ExactMatchCommandDeleteArg
	(*ExactMatchCommandClearArg)(nil),                       // 4: bess.pb.ExactMatchCommandClearArg
	(*ExactMatchCommandSetDefaultGateArg)(nil),              // 5: bess.pb.ExactMatchCommandSetDefaultGateArg
	(*FlowGenCommandSetBurstArg)(nil),                       // 6: bess.pb.FlowGenCommandSetBurstArg
	(*HashLBCommandSetModeArg)(nil),                         // 7: bess.pb.HashLBCommandSetModeArg
	(*HashLBCommandSetGatesArg)(nil),                        // 8: bess.pb.HashLBCommandSetGatesArg
	(*IPLookupCommandAddArg)(nil),                           // 9: bess.pb.IPLookupCommandAddArg
	(*IPLookupCommandDeleteArg)(nil),                        // 10: bess.pb.IPLookupCommandDeleteArg
	(*IPLookupCommandClearArg)(nil),                         // 11: bess.pb.IPLookupCommandClearArg
	(*L2ForwardCommandAddArg)(nil),                          // 12: bess.pb.L2ForwardCommandAddArg
	(*L2ForwardCommandDeleteArg)(nil),                       // 13: bess.pb.L2ForwardCommandDeleteArg
	(*L2ForwardCommandSetDefaultGateArg)(nil),               // 14: bess.pb.L2ForwardCommandSetDefaultGateArg
	(*L2ForwardCommandLookupArg)(nil),                       // 15: bess.pb.L2ForwardCommandLookupArg
	(*L2ForwardCommandLookupResponse)(nil),                  // 16: bess.pb.L2ForwardCommandLookupResponse
	(*L2ForwardCommandPopulateArg)(nil),                     // 17: bess.pb.L2ForwardCommandPopulateArg
	(*MeasureCommandGetSummaryArg)(nil),                     // 18: bess.pb.MeasureCommandGetSummaryArg
	(*MeasureCommandGetSummaryResponse)(nil),                // 19: bess.pb.MeasureCommandGetSummaryResponse
	(*DRRArg)(nil),                                          // 20: bess.pb.DRRArg
	(*DRRQuantumArg)(nil),                                   // 21: bess.pb.DRRQuantumArg
	(*DRRMaxFlowQueueSizeArg)(nil),                          // 22: bess.pb.DRRMaxFlowQueueSizeArg
	(*PortIncCommandSetBurstArg)(nil),                       // 23: bess.pb.PortIncCommandSetBurstArg
	(*QueueIncCommandSetBurstArg)(nil),                      // 24: bess.pb.QueueIncCommandSetBurstArg
	(*QueueCommandSetBurstArg)(nil),                         // 25: bess.pb.QueueCommandSetBurstArg
	(*QueueCommandSetSizeArg)(nil),                          // 26: bess.pb.QueueCommandSetSizeArg
	(*QueueCommandGetStatusArg)(nil),                        // 27: bess.pb.QueueCommandGetStatusArg
	(*QueueCommandGetStatusResponse)(nil),                   // 28: bess.pb.QueueCommandGetStatusResponse
	(*RandomUpdateCommandClearArg)(nil),                     // 29: bess.pb.RandomUpdateCommandClearArg
	(*RewriteCommandClearArg)(nil),                          // 30: bess.pb.RewriteCommandClearArg
	(*UpdateCommandClearArg)(nil),                           // 31: bess.pb.UpdateCommandClearArg
	(*WildcardMatchCommandAddArg)(nil),                      // 32: bess.pb.WildcardMatchCommandAddArg
	(*WildcardMatchCommandDeleteArg)(nil),                   // 33: bess.pb.WildcardMatchCommandDeleteArg
	(*WildcardMatchCommandClearArg)(nil),                    // 34: bess.pb.WildcardMatchCommandClearArg
	(*WildcardMatchCommandSetDefaultGateArg)(nil),           // 35: bess.pb.WildcardMatchCommandSetDefaultGateArg
	(*ACLArg)(nil),                                          // 36: bess.pb.ACLArg
	(*BPFArg)(nil),                                          // 37: bess.pb.BPFArg
	(*BufferArg)(nil),                                       // 38: bess.pb.BufferArg
	(*BypassArg)(nil),                                       // 39: bess.pb.BypassArg
	(*DumpArg)(nil),                                         // 40: bess.pb.DumpArg
	(*EtherEncapArg)(nil),                                   // 41: bess.pb.EtherEncapArg
	(*ExactMatchArg)(nil),                                   // 42: bess.pb.ExactMatchArg
	(*ExactMatchConfig)(nil),                                // 43: bess.pb.ExactMatchConfig
	(*FlowGenArg)(nil),                                      // 44: bess.pb.FlowGenArg
	(*GenericDecapArg)(nil),                                 // 45: bess.pb.GenericDecapArg
	(*GenericEncapArg)(nil),                                 // 46: bess.pb.GenericEncapArg
	(*HashLBArg)(nil),                                       // 47: bess.pb.HashLBArg
	(*IPEncapArg)(nil),                                      // 48: bess.pb.IPEncapArg
	(*IPLookupArg)(nil),                                     // 49: bess.pb.IPLookupArg
	(*L2ForwardArg)(nil),                                    // 50: bess.pb.L2ForwardArg
	(*MACSwapArg)(nil),                                      // 51: bess.pb.MACSwapArg
	(*MeasureArg)(nil),                                      // 52: bess.pb.MeasureArg
	(*MergeArg)(nil),                                        // 53: bess.pb.MergeArg
	(*MetadataTestArg)(nil),                                 // 54: bess.pb.MetadataTestArg
	(*NATArg)(nil),                                          // 55: bess.pb.NATArg
	(*StaticNATArg)(nil),                                    // 56: bess.pb.StaticNATArg
	(*NoOpArg)(nil),                                         // 57: bess.pb.NoOpArg
	(*PortIncArg)(nil),                                      // 58: bess.pb.PortIncArg
	(*PortOutArg)(nil),                                      // 59: bess.pb.PortOutArg
	(*QueueIncArg)(nil),                                     // 60: bess.pb.QueueIncArg
	(*QueueOutArg)(nil),                                     // 61: bess.pb.QueueOutArg
	(*QueueArg)(nil),                                        // 62: bess.pb.QueueArg
	(*RandomSplitArg)(nil),                                  // 63: bess.pb.RandomSplitArg
	(*RandomSplitCommandSetDroprateArg)(nil),                // 64: bess.pb.RandomSplitCommandSetDroprateArg
	(*RandomSplitCommandSetGatesArg)(nil),                   // 65: bess.pb.RandomSplitCommandSetGatesArg
	(*RandomUpdateArg)(nil),                                 // 66: bess.pb.RandomUpdateArg
	(*RewriteArg)(nil),                                      // 67: bess.pb.RewriteArg
	(*RoundRobinCommandSetGatesArg)(nil),                    // 68: bess.pb.RoundRobinCommandSetGatesArg
	(*RoundRobinCommandSetModeArg)(nil),                     // 69: bess.pb.RoundRobinCommandSetModeArg
	(*RoundRobinArg)(nil),                                   // 70: bess.pb.RoundRobinArg
	(*ReplicateArg)(nil),                                    // 71: bess.pb.ReplicateArg
	(*ReplicateCommandSetGatesArg)(nil),                     // 72: bess.pb.ReplicateCommandSetGatesArg
	(*SetMetadataArg)(nil),                                  // 73: bess.pb.SetMetadataArg
	(*SinkArg)(nil),                                         // 74: bess.pb.SinkArg
	(*SourceCommandSetBurstArg)(nil),                        // 75: bess.pb.SourceCommandSetBurstArg
	(*SourceCommandSetPktSizeArg)(nil),                      // 76: bess.pb.SourceCommandSetPktSizeArg
	(*SourceArg)(nil),                                       // 77: bess.pb.SourceArg
	(*IPChecksumArg)(nil),                                   // 78: bess.pb.IPChecksumArg
	(*L4ChecksumArg)(nil),                                   // 79: bess.pb.L4ChecksumArg
	(*GtpuEchoArg)(nil),                                     // 80: bess.pb.GtpuEchoArg
	(*IPDefragArg)(nil),                                     // 81: bess.pb.IPDefragArg
	(*IPFragArg)(nil),                                       // 82: bess.pb.IPFragArg
	(*CounterAddArg)(nil),                                   // 83: bess.pb.CounterAddArg
	(*CounterRemoveArg)(nil),                                // 84: bess.pb.CounterRemoveArg
	(*CounterArg)(nil),                                      // 85: bess.pb.CounterArg
	(*GtpuEncapArg)(nil),                                    // 86: bess.pb.GtpuEncapArg
	(*SplitArg)(nil),                                        // 87: bess.pb.SplitArg
	(*TimestampArg)(nil),                                    // 88: bess.pb.TimestampArg
	(*UpdateArg)(nil),                                       // 89: bess.pb.UpdateArg
	(*UrlFilterArg)(nil),                                    // 90: bess.pb.UrlFilterArg
	(*UrlFilterConfig)(nil),                                 // 91: bess.pb.UrlFilterConfig
	(*VLANPopArg)(nil),                                      // 92: bess.pb.VLANPopArg
	(*VLANPushArg)(nil),                                     // 93: bess.pb.VLANPushArg
	(*VLANSplitArg)(nil),                                    // 94: bess.pb.VLANSplitArg
	(*VXLANDecapArg)(nil),                                   // 95: bess.pb.VXLANDecapArg
	(*VXLANEncapArg)(nil),                                   // 96: bess.pb.VXLANEncapArg
	(*WildcardMatchArg)(nil),                                // 97: bess.pb.WildcardMatchArg
	(*WildcardMatchConfig)(nil),                             // 98: bess.pb.WildcardMatchConfig
	(*ArpResponderArg)(nil),                                 // 99: bess.pb.ArpResponderArg
	(*MplsPopArg)(nil),                                      // 100: bess.pb.MplsPopArg
	(*WorkerSplitArg)(nil),                                  // 101: bess.pb.WorkerSplitArg
	(*QosArg)(nil),                                          // 102: bess.pb.QosArg
	(*QosCommandAddArg)(nil),                                // 103: bess.pb.QosCommandAddArg
	(*QosCommandDeleteArg)(nil),                             // 104: bess.pb.QosCommandDeleteArg
	(*QosCommandClearArg)(nil),                              // 105: bess.pb.QosCommandClearArg
	(*QosCommandSetDefaultGateArg)(nil),                     // 106: bess.pb.QosCommandSetDefaultGateArg
	(*FlowMeasureArg)(nil),                                  // 107: bess.pb.FlowMeasureArg
	(*FlowMeasureCommandReadArg)(nil),                       // 108: bess.pb.FlowMeasureCommandReadArg
	(*FlowMeasureReadResponse)(nil),                         // 109: bess.pb.FlowMeasureReadResponse
	(*FlowMeasureCommandFlipArg)(nil),                       // 110: bess.pb.FlowMeasureCommandFlipArg
	(*FlowMeasureFlipResponse)(nil),                         // 111: bess.pb.FlowMeasureFlipResponse
	(*GtpuPathMonitoringCommandAddDeleteArg)(nil),           // 112: bess.pb.GtpuPathMonitoringCommandAddDeleteArg
	(*GtpuPathMonitoringCommandClearArg)(nil),               // 113: bess.pb.GtpuPathMonitoringCommandClearArg
	(*GtpuPathMonitoringCommandReadArg)(nil),                // 114: bess.pb.GtpuPathMonitoringCommandReadArg
	(*GtpuPathMonitoringCommandReadResponse)(nil),           // 115: bess.pb.GtpuPathMonitoringCommandReadResponse
	(*L2ForwardCommandAddArg_Entry)(nil),                    // 116: bess.pb.L2ForwardCommandAddArg.Entry
	(*MeasureCommandGetSummaryResponse_Histogram)(nil),      // 117: bess.pb.MeasureCommandGetSummaryResponse.Histogram
	(*ACLArg_Rule)(nil),                                     // 118: bess.pb.ACLArg.Rule
	(*BPFArg_Filter)(nil),                                   // 119: bess.pb.BPFArg.Filter
	(*GenericEncapArg_EncapField)(nil),                      // 120: bess.pb.GenericEncapArg.EncapField
	nil,                                                     // 121: bess.pb.MetadataTestArg.ReadEntry
	nil,                                                     // 122: bess.pb.MetadataTestArg.WriteEntry
	nil,                                                     // 123: bess.pb.MetadataTestArg.UpdateEntry
	(*NATArg_PortRange)(nil),                                // 124: bess.pb.NATArg.PortRange
	(*NATArg_ExternalAddress)(nil),                          // 125: bess.pb.NATArg.ExternalAddress
	(*StaticNATArg_AddressRange)(nil),                       // 126: bess.pb.StaticNATArg.AddressRange
	(*StaticNATArg_AddressRangePair)(nil),                   // 127: bess.pb.StaticNATArg.AddressRangePair
	(*RandomUpdateArg_Field)(nil),                           // 128: bess.pb.RandomUpdateArg.Field
	(*SetMetadataArg_Attribute)(nil),                        // 129: bess.pb.SetMetadataArg.Attribute
	(*UpdateArg_Field)(nil),                                 // 130: bess.pb.UpdateArg.Field
	(*UrlFilterArg_Url)(nil),                                // 131: bess.pb.UrlFilterArg.Url
	nil,                                                     // 132: bess.pb.WorkerSplitArg.WorkerGatesEntry
	(*FlowMeasureReadResponse_Statistic)(nil),               // 133: bess.pb.FlowMeasureReadResponse.Statistic
	(*FlowMeasureReadResponse_Statistic_Histogram)(nil),     // 134: bess.pb.FlowMeasureReadResponse.Statistic.Histogram
	(*GtpuPathMonitoringCommandReadResponse_Statistic)(nil), // 135: bess.pb.GtpuPathMonitoringCommandReadResponse.Statistic
	(*FieldData)(nil),                                       // 136: bess.pb.FieldData
	(*Field)(nil),                                           // 137: bess.pb.Field
}
var file_module_msg_proto_depIdxs = []int32{
	136, // 0: bess.pb.ExactMatchCommandAddArg.fields:type_name -> bess.pb.FieldData
	136, // 1: bess.pb.ExactMatchCommandAddArg.values:type_name -> bess.pb.FieldData
	136, // 2: bess.pb.ExactMatchCommandDeleteArg.fields:type_name -> bess.pb.FieldData
	137, // 3: bess.pb.HashLBCommandSetModeArg.fields:type_name -> bess.pb.Field
	116, // 4: bess.pb.L2ForwardCommandAddArg.entries:type_name -> bess.pb.L2ForwardCommandAddArg.Entry
	117, // 5: bess.pb.MeasureCommandGetSummaryResponse.latency:type_name -> bess.pb.MeasureCommandGetSummaryResponse.Histogram
	117, // 6: bess.pb.MeasureCommandGetSummaryResponse.jitter:type_name -> bess.pb.MeasureCommandGetSummaryResponse.Histogram
	136, // 7: bess.pb.WildcardMatchCommandAddArg.values:type_name -> bess.pb.FieldData
	136, // 8: bess.pb.WildcardMatchCommandAddArg.masks:type_name -> bess.pb.FieldData
	136, // 9: bess.pb.WildcardMatchCommandAddArg.valuesv:type_name -> bess.pb.FieldData
	136, // 10: bess.pb.WildcardMatchCommandDeleteArg.values:type_name -> bess.pb.FieldData
	136, // 11: bess.pb.WildcardMatchCommandDeleteArg.masks:type_name -> bess.pb.FieldData
	118, // 12: bess.pb.ACLArg.rules:type_name -> bess.pb.ACLArg.Rule
	119, // 13: bess.pb.BPFArg.filters:type_name -> bess.pb.BPFArg.Filter
	137, // 14: bess.pb.ExactMatchArg.fields:type_name -> bess.pb.Field
	136, // 15: bess.pb.ExactMatchArg.masks:type_name -> bess.pb.FieldData
	137, // 16: bess.pb.ExactMatchArg.values:type_name -> bess.pb.Field
	136, // 17: bess.pb.ExactMatchArg.masksv:type_name -> bess.pb.FieldData
	2,   // 18: bess.pb.ExactMatchConfig.rules:type_name -> bess.pb.ExactMatchCommandAddArg
	120, // 19: bess.pb.GenericEncapArg.fields:type_name -> bess.pb.GenericEncapArg.EncapField
	137, // 20: bess.pb.HashLBArg.fields:type_name -> bess.pb.Field
	121, // 21: bess.pb.MetadataTestArg.read:type_name -> bess.pb.MetadataTestArg.ReadEntry
	122, // 22: bess.pb.MetadataTestArg.write:type_name -> bess.pb.MetadataTestArg.WriteEntry
	123, // 23: bess.pb.MetadataTestArg.update:type_name -> bess.pb.MetadataTestArg.UpdateEntry
	125, // 24: bess.pb.NATArg.ext_addrs:type_name -> bess.pb.NATArg.ExternalAddress
	127, // 25: bess.pb.StaticNATArg.pairs:type_name -> bess.pb.StaticNATArg.AddressRangePair
	128, // 26: bess.pb.RandomUpdateArg.fields:type_name -> bess.pb.RandomUpdateArg.Field
	129, // 27: bess.pb.SetMetadataArg.attrs:type_name -> bess.pb.SetMetadataArg.Attribute
	130, // 28: bess.pb.UpdateArg.fields:type_name -> bess.pb.UpdateArg.Field
	131, // 29: bess.pb.UrlFilterArg.blacklist:type_name -> bess.pb.UrlFilterArg.Url
	131, // 30: bess.pb.UrlFilterConfig.blacklist:type_name -> bess.pb.UrlFilterArg.Url
	137, // 31: bess.pb.WildcardMatchArg.fields:type_name -> bess.pb.Field
	137, // 32: bess.pb.WildcardMatchArg.values:type_name -> bess.pb.Field
	32,  // 33: bess.pb.WildcardMatchConfig.rules:type_name -> bess.pb.WildcardMatchCommandAddArg
	132, // 34: bess.pb.WorkerSplitArg.worker_gates:type_name -> bess.pb.WorkerSplitArg.WorkerGatesEntry
	137, // 35: bess.pb.QosArg.fields:type_name -> bess.pb.Field
	137, // 36: bess.pb.QosArg.values:type_name -> bess.pb.Field
	136, // 37: bess.pb.QosCommandAddArg.fields:type_name -> bess.pb.FieldData
	136, // 38: bess.pb.QosCommandAddArg.values:type_name -> bess.pb.FieldData
	136, // 39: bess.pb.QosCommandDeleteArg.fields:type_name -> bess.pb.FieldData
	133, // 40: bess.pb.FlowMeasureReadResponse.statistics:type_name -> bess.pb.FlowMeasureReadResponse.Statistic
	135, // 41: bess.pb.GtpuPathMonitoringCommandReadResponse.statistics:type_name -> bess.pb.GtpuPathMonitoringCommandReadResponse.Statistic
	136, // 42: bess.pb.GenericEncapArg.EncapField.value:type_name -> bess.pb.FieldData
	124, // 43: bess.pb.NATArg.ExternalAddress.port_ranges:type_name -> bess.pb.NATArg.PortRange
	126, // 44: bess.pb.StaticNATArg.AddressRangePair.int_range:type_name -> bess.pb.StaticNATArg.AddressRange
	126, // 45: bess.pb.StaticNATArg.AddressRangePair.ext_range:type_name -> bess.pb.StaticNATArg.AddressRange
	134, // 46: bess.pb.FlowMeasureReadResponse.Statistic.latency:type_name -> bess.pb.FlowMeasureReadResponse.Statistic.Histogram
	134, // 47: bess.pb.FlowMeasureReadResponse.Statistic.jitter:type_name -> bess.pb.FlowMeasureReadResponse.Statistic.Histogram
	48,  // [48:48] is the sub-list for method output_type
	48,  // [48:48] is the sub-list for method input_type
	48,  // [48:48] is the sub-list for extension type_name
	48,  // [48:48] is the sub-list for extension extendee
	0,   // [0:48] is the sub-list for field type_name
}

func init() { file_module_msg_proto_init() }
func file_module_msg_proto_init() {
	if File_module_msg_proto != nil {
		return
	}
	file_util_msg_proto_init()
	file_module_msg_proto_msgTypes[52].OneofWrappers = []any{
		(*MeasureArg_Offset)(nil),
		(*MeasureArg_AttrName)(nil),
	}
	file_module_msg_proto_msgTypes[87].OneofWrappers = []any{
		(*SplitArg_Attribute)(nil),
		(*SplitArg_Offset)(nil),
	}
	file_module_msg_proto_msgTypes[88].OneofWrappers = []any{
		(*TimestampArg_Offset)(nil),
		(*TimestampArg_AttrName)(nil),
	}
	file_module_msg_proto_msgTypes[103].OneofWrappers = []any{
		(*QosCommandAddArg_DeductLen)(nil),
	}
	file_module_msg_proto_msgTypes[120].OneofWrappers = []any{
		(*GenericEncapArg_EncapField_Attribute)(nil),
		(*GenericEncapArg_EncapField_Value)(nil),
	}
	file_module_msg_proto_msgTypes[129].OneofWrappers = []any{
		(*SetMetadataArg_Attribute_ValueInt)(nil),
		(*SetMetadataArg_Attribute_ValueBin)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_module_msg_proto_rawDesc), len(file_module_msg_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   136,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_module_msg_proto_goTypes,
		DependencyIndexes: file_module_msg_proto_depIdxs,
		MessageInfos:      file_module_msg_proto_msgTypes,
	}.Build()
	File_module_msg_proto = out.File
	file_module_msg_proto_goTypes = nil
	file_module_msg_proto_depIdxs = nil
}
