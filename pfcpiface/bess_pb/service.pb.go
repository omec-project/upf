// Copyright (c) 2016-2017, Nefeli Networks, Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
// list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// * Neither the names of the copyright holders nor the names of their
// contributors may be used to endorse or promote products derived from this
// software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0-devel
// 	protoc        v3.3.0
// source: service.proto

package bess_pb

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

var File_service_proto protoreflect.FileDescriptor

var file_service_proto_rawDesc = []byte{
	0x0a, 0x0d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x07, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x1a, 0x0e, 0x62, 0x65, 0x73, 0x73, 0x5f, 0x6d,
	0x73, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x32, 0xd4, 0x1b, 0x0a, 0x0b, 0x42, 0x45, 0x53,
	0x53, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x12, 0x3f, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62,
	0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e,
	0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x08, 0x52, 0x65, 0x73,
	0x65, 0x74, 0x41, 0x6c, 0x6c, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e,
	0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62,
	0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x08, 0x4b, 0x69, 0x6c, 0x6c, 0x42, 0x65,
	0x73, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73,
	0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x22, 0x00, 0x12, 0x46, 0x0a, 0x0c, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x50, 0x6c, 0x75,
	0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x49, 0x6d,
	0x70, 0x6f, 0x72, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74,
	0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x46, 0x0a, 0x0c, 0x55,
	0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x55, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x50, 0x6c, 0x75, 0x67,
	0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73,
	0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x22, 0x00, 0x12, 0x44, 0x0a, 0x0b, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69,
	0x6e, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x62, 0x65, 0x73, 0x73,
	0x2e, 0x70, 0x62, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x08, 0x50, 0x61, 0x75,
	0x73, 0x65, 0x41, 0x6c, 0x6c, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e,
	0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62,
	0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x44, 0x0a, 0x0b, 0x50, 0x61, 0x75, 0x73, 0x65, 0x57,
	0x6f, 0x72, 0x6b, 0x65, 0x72, 0x12, 0x1b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e,
	0x50, 0x61, 0x75, 0x73, 0x65, 0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x46, 0x0a, 0x0c,
	0x52, 0x65, 0x73, 0x75, 0x6d, 0x65, 0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x12, 0x1c, 0x2e, 0x62,
	0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65, 0x57, 0x6f, 0x72,
	0x6b, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73,
	0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x00, 0x12, 0x3c, 0x0a, 0x09, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65, 0x41, 0x6c,
	0x6c, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74,
	0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e,
	0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x3f, 0x0a, 0x0c, 0x52, 0x65, 0x73, 0x65, 0x74, 0x57, 0x6f, 0x72, 0x6b, 0x65,
	0x72, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73,
	0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x22, 0x00, 0x12, 0x44, 0x0a, 0x0b, 0x4c, 0x69, 0x73, 0x74, 0x57, 0x6f, 0x72, 0x6b, 0x65,
	0x72, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x62, 0x65, 0x73, 0x73,
	0x2e, 0x70, 0x62, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x40, 0x0a, 0x09, 0x41, 0x64, 0x64,
	0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x12, 0x19, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62,
	0x2e, 0x41, 0x64, 0x64, 0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74,
	0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x48, 0x0a, 0x0d, 0x44,
	0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x12, 0x1d, 0x2e, 0x62,
	0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x57, 0x6f,
	0x72, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x08, 0x52, 0x65, 0x73, 0x65, 0x74, 0x54, 0x63,
	0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74,
	0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e,
	0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x3e, 0x0a, 0x07, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x63, 0x73, 0x12, 0x17, 0x2e,
	0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x63, 0x73, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62,
	0x2e, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x63, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x62, 0x0a, 0x1a, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x53, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73,
	0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70,
	0x62, 0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x69, 0x6e,
	0x67, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x38, 0x0a, 0x05, 0x41, 0x64, 0x64, 0x54, 0x63, 0x12,
	0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x41, 0x64, 0x64, 0x54, 0x63, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62,
	0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x4a, 0x0a, 0x0e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x63, 0x50, 0x61, 0x72, 0x61,
	0x6d, 0x73, 0x12, 0x1e, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x54, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4a, 0x0a, 0x0e,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54, 0x63, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x12, 0x1e,
	0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x54,
	0x63, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16,
	0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x47, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x54,
	0x63, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x1a, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62,
	0x2e, 0x47, 0x65, 0x74, 0x54, 0x63, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74,
	0x54, 0x63, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x00, 0x12, 0x44, 0x0a, 0x0b, 0x4c, 0x69, 0x73, 0x74, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x73,
	0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70,
	0x62, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x50, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x44, 0x72,
	0x69, 0x76, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1d, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e,
	0x70, 0x62, 0x2e, 0x47, 0x65, 0x74, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70,
	0x62, 0x2e, 0x47, 0x65, 0x74, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x0a, 0x52, 0x65, 0x73,
	0x65, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70,
	0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16,
	0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x40, 0x0a, 0x09, 0x4c, 0x69, 0x73, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e,
	0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x62,
	0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x73,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x47, 0x0a, 0x0a, 0x43, 0x72,
	0x65, 0x61, 0x74, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x1a, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e,
	0x70, 0x62, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x22, 0x00, 0x12, 0x44, 0x0a, 0x0b, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x50, 0x6f,
	0x72, 0x74, 0x12, 0x1b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x44, 0x65, 0x73,
	0x74, 0x72, 0x6f, 0x79, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x46, 0x0a, 0x0b, 0x53, 0x65, 0x74,
	0x50, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x12, 0x1b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e,
	0x70, 0x62, 0x2e, 0x53, 0x65, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e,
	0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x00, 0x12, 0x4a, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x6e, 0x66,
	0x12, 0x1b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x6f,
	0x72, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e,
	0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x43,
	0x6f, 0x6e, 0x66, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4d, 0x0a,
	0x0c, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x1c, 0x2e,
	0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x53,
	0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x53, 0x74, 0x61,
	0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x50, 0x0a, 0x0d,
	0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1d, 0x2e,
	0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62,
	0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x42,
	0x0a, 0x0a, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x12, 0x15, 0x2e, 0x62,
	0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x4c, 0x69,
	0x73, 0x74, 0x4d, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x50, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x4d, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x49,
	0x6e, 0x66, 0x6f, 0x12, 0x1d, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65,
	0x74, 0x4d, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74,
	0x4d, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x00, 0x12, 0x3f, 0x0a, 0x0c, 0x52, 0x65, 0x73, 0x65, 0x74, 0x4d, 0x6f, 0x64,
	0x75, 0x6c, 0x65, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45,
	0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x44, 0x0a, 0x0b, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x6f, 0x64,
	0x75, 0x6c, 0x65, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45,
	0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4d, 0x0a, 0x0c, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x12, 0x1c, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x6f, 0x64, 0x75,
	0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x62, 0x65, 0x73, 0x73,
	0x2e, 0x70, 0x62, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x48, 0x0a, 0x0d, 0x44, 0x65,
	0x73, 0x74, 0x72, 0x6f, 0x79, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x12, 0x1d, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x4d, 0x6f, 0x64,
	0x75, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73,
	0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x00, 0x12, 0x50, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x75, 0x6c,
	0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1d, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e,
	0x47, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47,
	0x65, 0x74, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4a, 0x0a, 0x0e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
	0x74, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x1e, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e,
	0x70, 0x62, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65,
	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e,
	0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x12, 0x50, 0x0a, 0x11, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
	0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x21, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70,
	0x62, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4d, 0x6f, 0x64, 0x75,
	0x6c, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x62, 0x65, 0x73,
	0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x00, 0x12, 0x4a, 0x0a, 0x0b, 0x44, 0x75, 0x6d, 0x70, 0x4d, 0x65, 0x6d, 0x70,
	0x6f, 0x6f, 0x6c, 0x12, 0x1b, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x44, 0x75,
	0x6d, 0x70, 0x4d, 0x65, 0x6d, 0x70, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x1c, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x44, 0x75, 0x6d, 0x70, 0x4d,
	0x65, 0x6d, 0x70, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
	0x12, 0x44, 0x0a, 0x0d, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
	0x64, 0x12, 0x17, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x43, 0x6f, 0x6d, 0x6d,
	0x61, 0x6e, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x62, 0x65, 0x73,
	0x73, 0x2e, 0x70, 0x62, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x50, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x47, 0x61,
	0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x12, 0x15, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x22, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x4c, 0x69, 0x73,
	0x74, 0x47, 0x61, 0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x65, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x47,
	0x61, 0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x49, 0x6e, 0x66, 0x6f,
	0x12, 0x24, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x65, 0x74, 0x47, 0x61,
	0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62,
	0x2e, 0x47, 0x65, 0x74, 0x47, 0x61, 0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x43, 0x6c, 0x61, 0x73,
	0x73, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
	0x5c, 0x0a, 0x11, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x47, 0x61, 0x74, 0x65,
	0x48, 0x6f, 0x6f, 0x6b, 0x12, 0x21, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x47, 0x61, 0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70,
	0x62, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x47, 0x61, 0x74, 0x65, 0x48,
	0x6f, 0x6f, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x48, 0x0a,
	0x0d, 0x4c, 0x69, 0x73, 0x74, 0x47, 0x61, 0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x73, 0x12, 0x15,
	0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e,
	0x4c, 0x69, 0x73, 0x74, 0x47, 0x61, 0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4e, 0x0a, 0x0f, 0x47, 0x61, 0x74, 0x65, 0x48,
	0x6f, 0x6f, 0x6b, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x1f, 0x2e, 0x62, 0x65, 0x73,
	0x73, 0x2e, 0x70, 0x62, 0x2e, 0x47, 0x61, 0x74, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x43, 0x6f, 0x6d,
	0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x62, 0x65,
	0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x56, 0x0a, 0x13, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x75, 0x72, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x12, 0x23,
	0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75,
	0x72, 0x65, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x62, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x62, 0x2e, 0x43, 0x6f,
	0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x62,
	0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var file_service_proto_goTypes = []interface{}{
	(*EmptyRequest)(nil),                       // 0: bess.pb.EmptyRequest
	(*ImportPluginRequest)(nil),                // 1: bess.pb.ImportPluginRequest
	(*UnloadPluginRequest)(nil),                // 2: bess.pb.UnloadPluginRequest
	(*PauseWorkerRequest)(nil),                 // 3: bess.pb.PauseWorkerRequest
	(*ResumeWorkerRequest)(nil),                // 4: bess.pb.ResumeWorkerRequest
	(*AddWorkerRequest)(nil),                   // 5: bess.pb.AddWorkerRequest
	(*DestroyWorkerRequest)(nil),               // 6: bess.pb.DestroyWorkerRequest
	(*ListTcsRequest)(nil),                     // 7: bess.pb.ListTcsRequest
	(*AddTcRequest)(nil),                       // 8: bess.pb.AddTcRequest
	(*UpdateTcParamsRequest)(nil),              // 9: bess.pb.UpdateTcParamsRequest
	(*UpdateTcParentRequest)(nil),              // 10: bess.pb.UpdateTcParentRequest
	(*GetTcStatsRequest)(nil),                  // 11: bess.pb.GetTcStatsRequest
	(*GetDriverInfoRequest)(nil),               // 12: bess.pb.GetDriverInfoRequest
	(*CreatePortRequest)(nil),                  // 13: bess.pb.CreatePortRequest
	(*DestroyPortRequest)(nil),                 // 14: bess.pb.DestroyPortRequest
	(*SetPortConfRequest)(nil),                 // 15: bess.pb.SetPortConfRequest
	(*GetPortConfRequest)(nil),                 // 16: bess.pb.GetPortConfRequest
	(*GetPortStatsRequest)(nil),                // 17: bess.pb.GetPortStatsRequest
	(*GetLinkStatusRequest)(nil),               // 18: bess.pb.GetLinkStatusRequest
	(*GetMclassInfoRequest)(nil),               // 19: bess.pb.GetMclassInfoRequest
	(*CreateModuleRequest)(nil),                // 20: bess.pb.CreateModuleRequest
	(*DestroyModuleRequest)(nil),               // 21: bess.pb.DestroyModuleRequest
	(*GetModuleInfoRequest)(nil),               // 22: bess.pb.GetModuleInfoRequest
	(*ConnectModulesRequest)(nil),              // 23: bess.pb.ConnectModulesRequest
	(*DisconnectModulesRequest)(nil),           // 24: bess.pb.DisconnectModulesRequest
	(*DumpMempoolRequest)(nil),                 // 25: bess.pb.DumpMempoolRequest
	(*CommandRequest)(nil),                     // 26: bess.pb.CommandRequest
	(*GetGateHookClassInfoRequest)(nil),        // 27: bess.pb.GetGateHookClassInfoRequest
	(*ConfigureGateHookRequest)(nil),           // 28: bess.pb.ConfigureGateHookRequest
	(*GateHookCommandRequest)(nil),             // 29: bess.pb.GateHookCommandRequest
	(*ConfigureResumeHookRequest)(nil),         // 30: bess.pb.ConfigureResumeHookRequest
	(*VersionResponse)(nil),                    // 31: bess.pb.VersionResponse
	(*EmptyResponse)(nil),                      // 32: bess.pb.EmptyResponse
	(*ListPluginsResponse)(nil),                // 33: bess.pb.ListPluginsResponse
	(*ListWorkersResponse)(nil),                // 34: bess.pb.ListWorkersResponse
	(*ListTcsResponse)(nil),                    // 35: bess.pb.ListTcsResponse
	(*CheckSchedulingConstraintsResponse)(nil), // 36: bess.pb.CheckSchedulingConstraintsResponse
	(*GetTcStatsResponse)(nil),                 // 37: bess.pb.GetTcStatsResponse
	(*ListDriversResponse)(nil),                // 38: bess.pb.ListDriversResponse
	(*GetDriverInfoResponse)(nil),              // 39: bess.pb.GetDriverInfoResponse
	(*ListPortsResponse)(nil),                  // 40: bess.pb.ListPortsResponse
	(*CreatePortResponse)(nil),                 // 41: bess.pb.CreatePortResponse
	(*CommandResponse)(nil),                    // 42: bess.pb.CommandResponse
	(*GetPortConfResponse)(nil),                // 43: bess.pb.GetPortConfResponse
	(*GetPortStatsResponse)(nil),               // 44: bess.pb.GetPortStatsResponse
	(*GetLinkStatusResponse)(nil),              // 45: bess.pb.GetLinkStatusResponse
	(*ListMclassResponse)(nil),                 // 46: bess.pb.ListMclassResponse
	(*GetMclassInfoResponse)(nil),              // 47: bess.pb.GetMclassInfoResponse
	(*ListModulesResponse)(nil),                // 48: bess.pb.ListModulesResponse
	(*CreateModuleResponse)(nil),               // 49: bess.pb.CreateModuleResponse
	(*GetModuleInfoResponse)(nil),              // 50: bess.pb.GetModuleInfoResponse
	(*DumpMempoolResponse)(nil),                // 51: bess.pb.DumpMempoolResponse
	(*ListGateHookClassResponse)(nil),          // 52: bess.pb.ListGateHookClassResponse
	(*GetGateHookClassInfoResponse)(nil),       // 53: bess.pb.GetGateHookClassInfoResponse
	(*ConfigureGateHookResponse)(nil),          // 54: bess.pb.ConfigureGateHookResponse
	(*ListGateHooksResponse)(nil),              // 55: bess.pb.ListGateHooksResponse
}
var file_service_proto_depIdxs = []int32{
	0,  // 0: bess.pb.BESSControl.GetVersion:input_type -> bess.pb.EmptyRequest
	0,  // 1: bess.pb.BESSControl.ResetAll:input_type -> bess.pb.EmptyRequest
	0,  // 2: bess.pb.BESSControl.KillBess:input_type -> bess.pb.EmptyRequest
	1,  // 3: bess.pb.BESSControl.ImportPlugin:input_type -> bess.pb.ImportPluginRequest
	2,  // 4: bess.pb.BESSControl.UnloadPlugin:input_type -> bess.pb.UnloadPluginRequest
	0,  // 5: bess.pb.BESSControl.ListPlugins:input_type -> bess.pb.EmptyRequest
	0,  // 6: bess.pb.BESSControl.PauseAll:input_type -> bess.pb.EmptyRequest
	3,  // 7: bess.pb.BESSControl.PauseWorker:input_type -> bess.pb.PauseWorkerRequest
	4,  // 8: bess.pb.BESSControl.ResumeWorker:input_type -> bess.pb.ResumeWorkerRequest
	0,  // 9: bess.pb.BESSControl.ResumeAll:input_type -> bess.pb.EmptyRequest
	0,  // 10: bess.pb.BESSControl.ResetWorkers:input_type -> bess.pb.EmptyRequest
	0,  // 11: bess.pb.BESSControl.ListWorkers:input_type -> bess.pb.EmptyRequest
	5,  // 12: bess.pb.BESSControl.AddWorker:input_type -> bess.pb.AddWorkerRequest
	6,  // 13: bess.pb.BESSControl.DestroyWorker:input_type -> bess.pb.DestroyWorkerRequest
	0,  // 14: bess.pb.BESSControl.ResetTcs:input_type -> bess.pb.EmptyRequest
	7,  // 15: bess.pb.BESSControl.ListTcs:input_type -> bess.pb.ListTcsRequest
	0,  // 16: bess.pb.BESSControl.CheckSchedulingConstraints:input_type -> bess.pb.EmptyRequest
	8,  // 17: bess.pb.BESSControl.AddTc:input_type -> bess.pb.AddTcRequest
	9,  // 18: bess.pb.BESSControl.UpdateTcParams:input_type -> bess.pb.UpdateTcParamsRequest
	10, // 19: bess.pb.BESSControl.UpdateTcParent:input_type -> bess.pb.UpdateTcParentRequest
	11, // 20: bess.pb.BESSControl.GetTcStats:input_type -> bess.pb.GetTcStatsRequest
	0,  // 21: bess.pb.BESSControl.ListDrivers:input_type -> bess.pb.EmptyRequest
	12, // 22: bess.pb.BESSControl.GetDriverInfo:input_type -> bess.pb.GetDriverInfoRequest
	0,  // 23: bess.pb.BESSControl.ResetPorts:input_type -> bess.pb.EmptyRequest
	0,  // 24: bess.pb.BESSControl.ListPorts:input_type -> bess.pb.EmptyRequest
	13, // 25: bess.pb.BESSControl.CreatePort:input_type -> bess.pb.CreatePortRequest
	14, // 26: bess.pb.BESSControl.DestroyPort:input_type -> bess.pb.DestroyPortRequest
	15, // 27: bess.pb.BESSControl.SetPortConf:input_type -> bess.pb.SetPortConfRequest
	16, // 28: bess.pb.BESSControl.GetPortConf:input_type -> bess.pb.GetPortConfRequest
	17, // 29: bess.pb.BESSControl.GetPortStats:input_type -> bess.pb.GetPortStatsRequest
	18, // 30: bess.pb.BESSControl.GetLinkStatus:input_type -> bess.pb.GetLinkStatusRequest
	0,  // 31: bess.pb.BESSControl.ListMclass:input_type -> bess.pb.EmptyRequest
	19, // 32: bess.pb.BESSControl.GetMclassInfo:input_type -> bess.pb.GetMclassInfoRequest
	0,  // 33: bess.pb.BESSControl.ResetModules:input_type -> bess.pb.EmptyRequest
	0,  // 34: bess.pb.BESSControl.ListModules:input_type -> bess.pb.EmptyRequest
	20, // 35: bess.pb.BESSControl.CreateModule:input_type -> bess.pb.CreateModuleRequest
	21, // 36: bess.pb.BESSControl.DestroyModule:input_type -> bess.pb.DestroyModuleRequest
	22, // 37: bess.pb.BESSControl.GetModuleInfo:input_type -> bess.pb.GetModuleInfoRequest
	23, // 38: bess.pb.BESSControl.ConnectModules:input_type -> bess.pb.ConnectModulesRequest
	24, // 39: bess.pb.BESSControl.DisconnectModules:input_type -> bess.pb.DisconnectModulesRequest
	25, // 40: bess.pb.BESSControl.DumpMempool:input_type -> bess.pb.DumpMempoolRequest
	26, // 41: bess.pb.BESSControl.ModuleCommand:input_type -> bess.pb.CommandRequest
	0,  // 42: bess.pb.BESSControl.ListGateHookClass:input_type -> bess.pb.EmptyRequest
	27, // 43: bess.pb.BESSControl.GetGateHookClassInfo:input_type -> bess.pb.GetGateHookClassInfoRequest
	28, // 44: bess.pb.BESSControl.ConfigureGateHook:input_type -> bess.pb.ConfigureGateHookRequest
	0,  // 45: bess.pb.BESSControl.ListGateHooks:input_type -> bess.pb.EmptyRequest
	29, // 46: bess.pb.BESSControl.GateHookCommand:input_type -> bess.pb.GateHookCommandRequest
	30, // 47: bess.pb.BESSControl.ConfigureResumeHook:input_type -> bess.pb.ConfigureResumeHookRequest
	31, // 48: bess.pb.BESSControl.GetVersion:output_type -> bess.pb.VersionResponse
	32, // 49: bess.pb.BESSControl.ResetAll:output_type -> bess.pb.EmptyResponse
	32, // 50: bess.pb.BESSControl.KillBess:output_type -> bess.pb.EmptyResponse
	32, // 51: bess.pb.BESSControl.ImportPlugin:output_type -> bess.pb.EmptyResponse
	32, // 52: bess.pb.BESSControl.UnloadPlugin:output_type -> bess.pb.EmptyResponse
	33, // 53: bess.pb.BESSControl.ListPlugins:output_type -> bess.pb.ListPluginsResponse
	32, // 54: bess.pb.BESSControl.PauseAll:output_type -> bess.pb.EmptyResponse
	32, // 55: bess.pb.BESSControl.PauseWorker:output_type -> bess.pb.EmptyResponse
	32, // 56: bess.pb.BESSControl.ResumeWorker:output_type -> bess.pb.EmptyResponse
	32, // 57: bess.pb.BESSControl.ResumeAll:output_type -> bess.pb.EmptyResponse
	32, // 58: bess.pb.BESSControl.ResetWorkers:output_type -> bess.pb.EmptyResponse
	34, // 59: bess.pb.BESSControl.ListWorkers:output_type -> bess.pb.ListWorkersResponse
	32, // 60: bess.pb.BESSControl.AddWorker:output_type -> bess.pb.EmptyResponse
	32, // 61: bess.pb.BESSControl.DestroyWorker:output_type -> bess.pb.EmptyResponse
	32, // 62: bess.pb.BESSControl.ResetTcs:output_type -> bess.pb.EmptyResponse
	35, // 63: bess.pb.BESSControl.ListTcs:output_type -> bess.pb.ListTcsResponse
	36, // 64: bess.pb.BESSControl.CheckSchedulingConstraints:output_type -> bess.pb.CheckSchedulingConstraintsResponse
	32, // 65: bess.pb.BESSControl.AddTc:output_type -> bess.pb.EmptyResponse
	32, // 66: bess.pb.BESSControl.UpdateTcParams:output_type -> bess.pb.EmptyResponse
	32, // 67: bess.pb.BESSControl.UpdateTcParent:output_type -> bess.pb.EmptyResponse
	37, // 68: bess.pb.BESSControl.GetTcStats:output_type -> bess.pb.GetTcStatsResponse
	38, // 69: bess.pb.BESSControl.ListDrivers:output_type -> bess.pb.ListDriversResponse
	39, // 70: bess.pb.BESSControl.GetDriverInfo:output_type -> bess.pb.GetDriverInfoResponse
	32, // 71: bess.pb.BESSControl.ResetPorts:output_type -> bess.pb.EmptyResponse
	40, // 72: bess.pb.BESSControl.ListPorts:output_type -> bess.pb.ListPortsResponse
	41, // 73: bess.pb.BESSControl.CreatePort:output_type -> bess.pb.CreatePortResponse
	32, // 74: bess.pb.BESSControl.DestroyPort:output_type -> bess.pb.EmptyResponse
	42, // 75: bess.pb.BESSControl.SetPortConf:output_type -> bess.pb.CommandResponse
	43, // 76: bess.pb.BESSControl.GetPortConf:output_type -> bess.pb.GetPortConfResponse
	44, // 77: bess.pb.BESSControl.GetPortStats:output_type -> bess.pb.GetPortStatsResponse
	45, // 78: bess.pb.BESSControl.GetLinkStatus:output_type -> bess.pb.GetLinkStatusResponse
	46, // 79: bess.pb.BESSControl.ListMclass:output_type -> bess.pb.ListMclassResponse
	47, // 80: bess.pb.BESSControl.GetMclassInfo:output_type -> bess.pb.GetMclassInfoResponse
	32, // 81: bess.pb.BESSControl.ResetModules:output_type -> bess.pb.EmptyResponse
	48, // 82: bess.pb.BESSControl.ListModules:output_type -> bess.pb.ListModulesResponse
	49, // 83: bess.pb.BESSControl.CreateModule:output_type -> bess.pb.CreateModuleResponse
	32, // 84: bess.pb.BESSControl.DestroyModule:output_type -> bess.pb.EmptyResponse
	50, // 85: bess.pb.BESSControl.GetModuleInfo:output_type -> bess.pb.GetModuleInfoResponse
	32, // 86: bess.pb.BESSControl.ConnectModules:output_type -> bess.pb.EmptyResponse
	32, // 87: bess.pb.BESSControl.DisconnectModules:output_type -> bess.pb.EmptyResponse
	51, // 88: bess.pb.BESSControl.DumpMempool:output_type -> bess.pb.DumpMempoolResponse
	42, // 89: bess.pb.BESSControl.ModuleCommand:output_type -> bess.pb.CommandResponse
	52, // 90: bess.pb.BESSControl.ListGateHookClass:output_type -> bess.pb.ListGateHookClassResponse
	53, // 91: bess.pb.BESSControl.GetGateHookClassInfo:output_type -> bess.pb.GetGateHookClassInfoResponse
	54, // 92: bess.pb.BESSControl.ConfigureGateHook:output_type -> bess.pb.ConfigureGateHookResponse
	55, // 93: bess.pb.BESSControl.ListGateHooks:output_type -> bess.pb.ListGateHooksResponse
	42, // 94: bess.pb.BESSControl.GateHookCommand:output_type -> bess.pb.CommandResponse
	42, // 95: bess.pb.BESSControl.ConfigureResumeHook:output_type -> bess.pb.CommandResponse
	48, // [48:96] is the sub-list for method output_type
	0,  // [0:48] is the sub-list for method input_type
	0,  // [0:0] is the sub-list for extension type_name
	0,  // [0:0] is the sub-list for extension extendee
	0,  // [0:0] is the sub-list for field type_name
}

func init() { file_service_proto_init() }
func file_service_proto_init() {
	if File_service_proto != nil {
		return
	}
	file_bess_msg_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_service_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   0,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_service_proto_goTypes,
		DependencyIndexes: file_service_proto_depIdxs,
	}.Build()
	File_service_proto = out.File
	file_service_proto_rawDesc = nil
	file_service_proto_goTypes = nil
	file_service_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// BESSControlClient is the client API for BESSControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BESSControlClient interface {
	/// Query version of bessd
	GetVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	/// Reset the current packet processing datapath to the initial state.
	///
	/// This command is identical to the following sequence:
	///   ResetModules()
	///   ResetPorts()
	///   ResetTcs()
	///   ResetWorkers()
	/// As it clears everything, BESS should appear as if the daemon has freshly
	/// started (if not, it is a bug; please report).
	///
	/// NOTE: There should be no running worker to run this command.
	ResetAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Terminate the BESS daemon.
	///
	/// BESS daemon shuts off in a graceful manner. Note that this command is
	/// "asynchronous": this command doesn't block until the BESS daemon has
	/// shut off.
	///
	/// NOTE: There should be no running worker to run this command.
	/// FIXME: rename (e.g., Terminate)
	KillBess(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Import a plugin
	///
	/// At the moment plugins can only contain module types,
	/// but might also support drivers/hooks/schedulers in the future.
	ImportPlugin(ctx context.Context, in *ImportPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Unload a plugin
	///
	/// At the moment plugins can only contain module types,
	/// but might also support drivers/hooks/schedulers in the future.
	UnloadPlugin(ctx context.Context, in *UnloadPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// List imported plugins
	///
	/// At the moment plugins can only contain module types,
	/// but might also support drivers/hooks/schedulers in the future.
	ListPlugins(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error)
	/// Pause all running workers temporarily
	///
	/// Some RPC commands to BESS or individual modules/ports require that
	/// threads must be inactive, to avoid race conditions.
	/// For such commands, use PauseALl at the beginning and ResumeAll at the end.
	///  PauseAll()
	///   SomeCommand1()
	///   SomeCommand2()
	///   ...
	///  ResumeAll()
	/// Keep the duration as short as possible, to avoid packet drops.
	PauseAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Pause the specified worker temporarily
	///
	/// Some RPC commands to BESS or individual modules/ports require that
	/// threads must be inactive, to avoid race conditions.
	/// For such commands, use PauseWorker at the beginning and ResumeWorker at the end.
	///  PauseWorker(0)
	///   SomeCommand1()
	///   SomeCommand2()
	///   ...
	///  ResumeWorker(0)
	/// Keep the duration as short as possible, to avoid packet drops.
	PauseWorker(ctx context.Context, in *PauseWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Resume the specified worker
	ResumeWorker(ctx context.Context, in *ResumeWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Resume all paused workers
	ResumeAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Remove all existing workers
	///
	/// NOTE: There should be no running worker to run this command.
	ResetWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Enumerate all existing workers
	ListWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error)
	/// Create a new worker
	///
	/// NOTE: There should be no running worker to run this command.
	AddWorker(ctx context.Context, in *AddWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Remove a single worker
	///
	/// NOTE: There should be no running worker to run this command.
	DestroyWorker(ctx context.Context, in *DestroyWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Remove all existing traffic classes
	///
	/// NOTE: There should be no running worker to run this command.
	ResetTcs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Enumerate all existing workers
	ListTcs(ctx context.Context, in *ListTcsRequest, opts ...grpc.CallOption) (*ListTcsResponse, error)
	/// Check scheduling contraints
	CheckSchedulingConstraints(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*CheckSchedulingConstraintsResponse, error)
	/// Create a new traffic class
	///
	/// NOTE: There should be no running worker to run this command.
	AddTc(ctx context.Context, in *AddTcRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Update parameters of an existing traffic class
	///
	/// NOTE: There should be no running worker to run this command.
	UpdateTcParams(ctx context.Context, in *UpdateTcParamsRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Change parent (and child arguments) of an existing traffic class
	///
	/// NOTE: There should be no running worker to run this command.
	UpdateTcParent(ctx context.Context, in *UpdateTcParentRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Collect statistics of a traffic class
	GetTcStats(ctx context.Context, in *GetTcStatsRequest, opts ...grpc.CallOption) (*GetTcStatsResponse, error)
	/// Enumerate all port drivers available
	ListDrivers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListDriversResponse, error)
	/// Query detailed information of a port driver
	GetDriverInfo(ctx context.Context, in *GetDriverInfoRequest, opts ...grpc.CallOption) (*GetDriverInfoResponse, error)
	/// Remove all initialized ports
	///
	/// Will fail if there are modules that are still using ports.
	/// (e.g., PortInc, PortOut, QueueInc, QueueOut)
	///
	/// NOTE: There should be no running worker to run this command.
	ResetPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Enumerate all initialized ports
	ListPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPortsResponse, error)
	/// Create a new port from the specified driver
	CreatePort(ctx context.Context, in *CreatePortRequest, opts ...grpc.CallOption) (*CreatePortResponse, error)
	/// Remove a port
	///
	/// The port should not be being used by a port-related module.
	/// (e.g., PortInc, PortOut, QueueInc, QueueOut)
	DestroyPort(ctx context.Context, in *DestroyPortRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Runtime-updatable configuration
	SetPortConf(ctx context.Context, in *SetPortConfRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	GetPortConf(ctx context.Context, in *GetPortConfRequest, opts ...grpc.CallOption) (*GetPortConfResponse, error)
	/// Collect port statistics
	///
	/// At the moment, per-queue stats are not supported.
	GetPortStats(ctx context.Context, in *GetPortStatsRequest, opts ...grpc.CallOption) (*GetPortStatsResponse, error)
	/// Query link status
	GetLinkStatus(ctx context.Context, in *GetLinkStatusRequest, opts ...grpc.CallOption) (*GetLinkStatusResponse, error)
	/// Enumerate all module types available
	ListMclass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListMclassResponse, error)
	/// Query detailed information of a module type
	GetMclassInfo(ctx context.Context, in *GetMclassInfoRequest, opts ...grpc.CallOption) (*GetMclassInfoResponse, error)
	/// Remove all modules.
	///
	/// This RPC will always succeed (unless there is a running worker)
	///
	/// NOTE: There should be no running worker to run this command.
	ResetModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Enumerate all initialized modules
	ListModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListModulesResponse, error)
	/// Create a new module instance from the given module type
	///
	/// NOTE: There should be no running worker to run this command.
	CreateModule(ctx context.Context, in *CreateModuleRequest, opts ...grpc.CallOption) (*CreateModuleResponse, error)
	/// Destroy an exsting module
	///
	/// If the module is connected to other modules' input/output gate, they are
	/// disconnected first. All tasks created by the module will also be destoyed.
	///
	/// NOTE: There should be no running worker to run this command.
	DestroyModule(ctx context.Context, in *DestroyModuleRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Fetch detailed information of an module instance
	GetModuleInfo(ctx context.Context, in *GetModuleInfoRequest, opts ...grpc.CallOption) (*GetModuleInfoResponse, error)
	/// Connect two modules.
	///
	/// Connect between m1's ogate and n2's igate (i.e., ackets sent to m1's ogate
	/// will be fed to m2's igate). The oate can be connected to only one igate,
	/// while the igate can be connected to multiple output gates.
	///
	/// NOTE: There should be no running worker to run this command.
	ConnectModules(ctx context.Context, in *ConnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Disconnect two modules.
	///
	/// It removes a connection between two modules (you specify the previous one
	/// and its output gate). All packets coming out from the ogate will be
	/// dropped. Once disconnected, the ogate can be connected
	/// to any input gate.
	///
	/// NOTE: There should be no running worker to run this command.
	DisconnectModules(ctx context.Context, in *DisconnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	/// Dump various stats about BESS's packet pools
	DumpMempool(ctx context.Context, in *DumpMempoolRequest, opts ...grpc.CallOption) (*DumpMempoolResponse, error)
	/// Send a command to the specified module instance.
	///
	/// Each module type defines a list of modyle-specific commands, which
	/// allow external programs to communicate with the module at runtime.
	/// See module_msg.proto for details.
	///
	/// NOTE: Some commands cannot be used if there are running workers.
	///       For those commands you must pause all workers first.
	ModuleCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	/// Enumerate all gatehook types available
	ListGateHookClass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHookClassResponse, error)
	/// Query detailed information of a gatehook type
	GetGateHookClassInfo(ctx context.Context, in *GetGateHookClassInfoRequest, opts ...grpc.CallOption) (*GetGateHookClassInfoResponse, error)
	/// Enable/Disable a gate hook.
	ConfigureGateHook(ctx context.Context, in *ConfigureGateHookRequest, opts ...grpc.CallOption) (*ConfigureGateHookResponse, error)
	/// Enumerate all gatehook installed
	ListGateHooks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHooksResponse, error)
	/// Send command to gate hook instance.
	GateHookCommand(ctx context.Context, in *GateHookCommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	/// Enable/Disable a resume hook.
	ConfigureResumeHook(ctx context.Context, in *ConfigureResumeHookRequest, opts ...grpc.CallOption) (*CommandResponse, error)
}

type bESSControlClient struct {
	cc grpc.ClientConnInterface
}

func NewBESSControlClient(cc grpc.ClientConnInterface) BESSControlClient {
	return &bESSControlClient{cc}
}

func (c *bESSControlClient) GetVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ResetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) KillBess(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/KillBess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ImportPlugin(ctx context.Context, in *ImportPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ImportPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UnloadPlugin(ctx context.Context, in *UnloadPluginRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/UnloadPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListPlugins(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	out := new(ListPluginsResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListPlugins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) PauseAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/PauseAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) PauseWorker(ctx context.Context, in *PauseWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/PauseWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResumeWorker(ctx context.Context, in *ResumeWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ResumeWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResumeAll(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ResumeAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ResetWorkers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListWorkers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListWorkersResponse, error) {
	out := new(ListWorkersResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListWorkers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) AddWorker(ctx context.Context, in *AddWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/AddWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyWorker(ctx context.Context, in *DestroyWorkerRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/DestroyWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetTcs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ResetTcs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListTcs(ctx context.Context, in *ListTcsRequest, opts ...grpc.CallOption) (*ListTcsResponse, error) {
	out := new(ListTcsResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListTcs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CheckSchedulingConstraints(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*CheckSchedulingConstraintsResponse, error) {
	out := new(CheckSchedulingConstraintsResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/CheckSchedulingConstraints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) AddTc(ctx context.Context, in *AddTcRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/AddTc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UpdateTcParams(ctx context.Context, in *UpdateTcParamsRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/UpdateTcParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) UpdateTcParent(ctx context.Context, in *UpdateTcParentRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/UpdateTcParent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetTcStats(ctx context.Context, in *GetTcStatsRequest, opts ...grpc.CallOption) (*GetTcStatsResponse, error) {
	out := new(GetTcStatsResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetTcStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListDrivers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListDriversResponse, error) {
	out := new(ListDriversResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListDrivers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetDriverInfo(ctx context.Context, in *GetDriverInfoRequest, opts ...grpc.CallOption) (*GetDriverInfoResponse, error) {
	out := new(GetDriverInfoResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetDriverInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ResetPorts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListPorts(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListPortsResponse, error) {
	out := new(ListPortsResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListPorts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CreatePort(ctx context.Context, in *CreatePortRequest, opts ...grpc.CallOption) (*CreatePortResponse, error) {
	out := new(CreatePortResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/CreatePort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyPort(ctx context.Context, in *DestroyPortRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/DestroyPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) SetPortConf(ctx context.Context, in *SetPortConfRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/SetPortConf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetPortConf(ctx context.Context, in *GetPortConfRequest, opts ...grpc.CallOption) (*GetPortConfResponse, error) {
	out := new(GetPortConfResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetPortConf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetPortStats(ctx context.Context, in *GetPortStatsRequest, opts ...grpc.CallOption) (*GetPortStatsResponse, error) {
	out := new(GetPortStatsResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetPortStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetLinkStatus(ctx context.Context, in *GetLinkStatusRequest, opts ...grpc.CallOption) (*GetLinkStatusResponse, error) {
	out := new(GetLinkStatusResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetLinkStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListMclass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListMclassResponse, error) {
	out := new(ListMclassResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListMclass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetMclassInfo(ctx context.Context, in *GetMclassInfoRequest, opts ...grpc.CallOption) (*GetMclassInfoResponse, error) {
	out := new(GetMclassInfoResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetMclassInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ResetModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ResetModules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListModules(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListModulesResponse, error) {
	out := new(ListModulesResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListModules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) CreateModule(ctx context.Context, in *CreateModuleRequest, opts ...grpc.CallOption) (*CreateModuleResponse, error) {
	out := new(CreateModuleResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/CreateModule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DestroyModule(ctx context.Context, in *DestroyModuleRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/DestroyModule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetModuleInfo(ctx context.Context, in *GetModuleInfoRequest, opts ...grpc.CallOption) (*GetModuleInfoResponse, error) {
	out := new(GetModuleInfoResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetModuleInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConnectModules(ctx context.Context, in *ConnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ConnectModules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DisconnectModules(ctx context.Context, in *DisconnectModulesRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/DisconnectModules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) DumpMempool(ctx context.Context, in *DumpMempoolRequest, opts ...grpc.CallOption) (*DumpMempoolResponse, error) {
	out := new(DumpMempoolResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/DumpMempool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ModuleCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ModuleCommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListGateHookClass(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHookClassResponse, error) {
	out := new(ListGateHookClassResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListGateHookClass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GetGateHookClassInfo(ctx context.Context, in *GetGateHookClassInfoRequest, opts ...grpc.CallOption) (*GetGateHookClassInfoResponse, error) {
	out := new(GetGateHookClassInfoResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GetGateHookClassInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConfigureGateHook(ctx context.Context, in *ConfigureGateHookRequest, opts ...grpc.CallOption) (*ConfigureGateHookResponse, error) {
	out := new(ConfigureGateHookResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ConfigureGateHook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ListGateHooks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListGateHooksResponse, error) {
	out := new(ListGateHooksResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ListGateHooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) GateHookCommand(ctx context.Context, in *GateHookCommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/GateHookCommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bESSControlClient) ConfigureResumeHook(ctx context.Context, in *ConfigureResumeHookRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, "/bess.pb.BESSControl/ConfigureResumeHook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BESSControlServer is the server API for BESSControl service.
type BESSControlServer interface {
	/// Query version of bessd
	GetVersion(context.Context, *EmptyRequest) (*VersionResponse, error)
	/// Reset the current packet processing datapath to the initial state.
	///
	/// This command is identical to the following sequence:
	///   ResetModules()
	///   ResetPorts()
	///   ResetTcs()
	///   ResetWorkers()
	/// As it clears everything, BESS should appear as if the daemon has freshly
	/// started (if not, it is a bug; please report).
	///
	/// NOTE: There should be no running worker to run this command.
	ResetAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	/// Terminate the BESS daemon.
	///
	/// BESS daemon shuts off in a graceful manner. Note that this command is
	/// "asynchronous": this command doesn't block until the BESS daemon has
	/// shut off.
	///
	/// NOTE: There should be no running worker to run this command.
	/// FIXME: rename (e.g., Terminate)
	KillBess(context.Context, *EmptyRequest) (*EmptyResponse, error)
	/// Import a plugin
	///
	/// At the moment plugins can only contain module types,
	/// but might also support drivers/hooks/schedulers in the future.
	ImportPlugin(context.Context, *ImportPluginRequest) (*EmptyResponse, error)
	/// Unload a plugin
	///
	/// At the moment plugins can only contain module types,
	/// but might also support drivers/hooks/schedulers in the future.
	UnloadPlugin(context.Context, *UnloadPluginRequest) (*EmptyResponse, error)
	/// List imported plugins
	///
	/// At the moment plugins can only contain module types,
	/// but might also support drivers/hooks/schedulers in the future.
	ListPlugins(context.Context, *EmptyRequest) (*ListPluginsResponse, error)
	/// Pause all running workers temporarily
	///
	/// Some RPC commands to BESS or individual modules/ports require that
	/// threads must be inactive, to avoid race conditions.
	/// For such commands, use PauseALl at the beginning and ResumeAll at the end.
	///  PauseAll()
	///   SomeCommand1()
	///   SomeCommand2()
	///   ...
	///  ResumeAll()
	/// Keep the duration as short as possible, to avoid packet drops.
	PauseAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	/// Pause the specified worker temporarily
	///
	/// Some RPC commands to BESS or individual modules/ports require that
	/// threads must be inactive, to avoid race conditions.
	/// For such commands, use PauseWorker at the beginning and ResumeWorker at the end.
	///  PauseWorker(0)
	///   SomeCommand1()
	///   SomeCommand2()
	///   ...
	///  ResumeWorker(0)
	/// Keep the duration as short as possible, to avoid packet drops.
	PauseWorker(context.Context, *PauseWorkerRequest) (*EmptyResponse, error)
	/// Resume the specified worker
	ResumeWorker(context.Context, *ResumeWorkerRequest) (*EmptyResponse, error)
	/// Resume all paused workers
	ResumeAll(context.Context, *EmptyRequest) (*EmptyResponse, error)
	/// Remove all existing workers
	///
	/// NOTE: There should be no running worker to run this command.
	ResetWorkers(context.Context, *EmptyRequest) (*EmptyResponse, error)
	/// Enumerate all existing workers
	ListWorkers(context.Context, *EmptyRequest) (*ListWorkersResponse, error)
	/// Create a new worker
	///
	/// NOTE: There should be no running worker to run this command.
	AddWorker(context.Context, *AddWorkerRequest) (*EmptyResponse, error)
	/// Remove a single worker
	///
	/// NOTE: There should be no running worker to run this command.
	DestroyWorker(context.Context, *DestroyWorkerRequest) (*EmptyResponse, error)
	/// Remove all existing traffic classes
	///
	/// NOTE: There should be no running worker to run this command.
	ResetTcs(context.Context, *EmptyRequest) (*EmptyResponse, error)
	/// Enumerate all existing workers
	ListTcs(context.Context, *ListTcsRequest) (*ListTcsResponse, error)
	/// Check scheduling contraints
	CheckSchedulingConstraints(context.Context, *EmptyRequest) (*CheckSchedulingConstraintsResponse, error)
	/// Create a new traffic class
	///
	/// NOTE: There should be no running worker to run this command.
	AddTc(context.Context, *AddTcRequest) (*EmptyResponse, error)
	/// Update parameters of an existing traffic class
	///
	/// NOTE: There should be no running worker to run this command.
	UpdateTcParams(context.Context, *UpdateTcParamsRequest) (*EmptyResponse, error)
	/// Change parent (and child arguments) of an existing traffic class
	///
	/// NOTE: There should be no running worker to run this command.
	UpdateTcParent(context.Context, *UpdateTcParentRequest) (*EmptyResponse, error)
	/// Collect statistics of a traffic class
	GetTcStats(context.Context, *GetTcStatsRequest) (*GetTcStatsResponse, error)
	/// Enumerate all port drivers available
	ListDrivers(context.Context, *EmptyRequest) (*ListDriversResponse, error)
	/// Query detailed information of a port driver
	GetDriverInfo(context.Context, *GetDriverInfoRequest) (*GetDriverInfoResponse, error)
	/// Remove all initialized ports
	///
	/// Will fail if there are modules that are still using ports.
	/// (e.g., PortInc, PortOut, QueueInc, QueueOut)
	///
	/// NOTE: There should be no running worker to run this command.
	ResetPorts(context.Context, *EmptyRequest) (*EmptyResponse, error)
	/// Enumerate all initialized ports
	ListPorts(context.Context, *EmptyRequest) (*ListPortsResponse, error)
	/// Create a new port from the specified driver
	CreatePort(context.Context, *CreatePortRequest) (*CreatePortResponse, error)
	/// Remove a port
	///
	/// The port should not be being used by a port-related module.
	/// (e.g., PortInc, PortOut, QueueInc, QueueOut)
	DestroyPort(context.Context, *DestroyPortRequest) (*EmptyResponse, error)
	/// Runtime-updatable configuration
	SetPortConf(context.Context, *SetPortConfRequest) (*CommandResponse, error)
	GetPortConf(context.Context, *GetPortConfRequest) (*GetPortConfResponse, error)
	/// Collect port statistics
	///
	/// At the moment, per-queue stats are not supported.
	GetPortStats(context.Context, *GetPortStatsRequest) (*GetPortStatsResponse, error)
	/// Query link status
	GetLinkStatus(context.Context, *GetLinkStatusRequest) (*GetLinkStatusResponse, error)
	/// Enumerate all module types available
	ListMclass(context.Context, *EmptyRequest) (*ListMclassResponse, error)
	/// Query detailed information of a module type
	GetMclassInfo(context.Context, *GetMclassInfoRequest) (*GetMclassInfoResponse, error)
	/// Remove all modules.
	///
	/// This RPC will always succeed (unless there is a running worker)
	///
	/// NOTE: There should be no running worker to run this command.
	ResetModules(context.Context, *EmptyRequest) (*EmptyResponse, error)
	/// Enumerate all initialized modules
	ListModules(context.Context, *EmptyRequest) (*ListModulesResponse, error)
	/// Create a new module instance from the given module type
	///
	/// NOTE: There should be no running worker to run this command.
	CreateModule(context.Context, *CreateModuleRequest) (*CreateModuleResponse, error)
	/// Destroy an exsting module
	///
	/// If the module is connected to other modules' input/output gate, they are
	/// disconnected first. All tasks created by the module will also be destoyed.
	///
	/// NOTE: There should be no running worker to run this command.
	DestroyModule(context.Context, *DestroyModuleRequest) (*EmptyResponse, error)
	/// Fetch detailed information of an module instance
	GetModuleInfo(context.Context, *GetModuleInfoRequest) (*GetModuleInfoResponse, error)
	/// Connect two modules.
	///
	/// Connect between m1's ogate and n2's igate (i.e., ackets sent to m1's ogate
	/// will be fed to m2's igate). The oate can be connected to only one igate,
	/// while the igate can be connected to multiple output gates.
	///
	/// NOTE: There should be no running worker to run this command.
	ConnectModules(context.Context, *ConnectModulesRequest) (*EmptyResponse, error)
	/// Disconnect two modules.
	///
	/// It removes a connection between two modules (you specify the previous one
	/// and its output gate). All packets coming out from the ogate will be
	/// dropped. Once disconnected, the ogate can be connected
	/// to any input gate.
	///
	/// NOTE: There should be no running worker to run this command.
	DisconnectModules(context.Context, *DisconnectModulesRequest) (*EmptyResponse, error)
	/// Dump various stats about BESS's packet pools
	DumpMempool(context.Context, *DumpMempoolRequest) (*DumpMempoolResponse, error)
	/// Send a command to the specified module instance.
	///
	/// Each module type defines a list of modyle-specific commands, which
	/// allow external programs to communicate with the module at runtime.
	/// See module_msg.proto for details.
	///
	/// NOTE: Some commands cannot be used if there are running workers.
	///       For those commands you must pause all workers first.
	ModuleCommand(context.Context, *CommandRequest) (*CommandResponse, error)
	/// Enumerate all gatehook types available
	ListGateHookClass(context.Context, *EmptyRequest) (*ListGateHookClassResponse, error)
	/// Query detailed information of a gatehook type
	GetGateHookClassInfo(context.Context, *GetGateHookClassInfoRequest) (*GetGateHookClassInfoResponse, error)
	/// Enable/Disable a gate hook.
	ConfigureGateHook(context.Context, *ConfigureGateHookRequest) (*ConfigureGateHookResponse, error)
	/// Enumerate all gatehook installed
	ListGateHooks(context.Context, *EmptyRequest) (*ListGateHooksResponse, error)
	/// Send command to gate hook instance.
	GateHookCommand(context.Context, *GateHookCommandRequest) (*CommandResponse, error)
	/// Enable/Disable a resume hook.
	ConfigureResumeHook(context.Context, *ConfigureResumeHookRequest) (*CommandResponse, error)
}

// UnimplementedBESSControlServer can be embedded to have forward compatible implementations.
type UnimplementedBESSControlServer struct {
}

func (*UnimplementedBESSControlServer) GetVersion(context.Context, *EmptyRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (*UnimplementedBESSControlServer) ResetAll(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetAll not implemented")
}
func (*UnimplementedBESSControlServer) KillBess(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KillBess not implemented")
}
func (*UnimplementedBESSControlServer) ImportPlugin(context.Context, *ImportPluginRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportPlugin not implemented")
}
func (*UnimplementedBESSControlServer) UnloadPlugin(context.Context, *UnloadPluginRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnloadPlugin not implemented")
}
func (*UnimplementedBESSControlServer) ListPlugins(context.Context, *EmptyRequest) (*ListPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPlugins not implemented")
}
func (*UnimplementedBESSControlServer) PauseAll(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseAll not implemented")
}
func (*UnimplementedBESSControlServer) PauseWorker(context.Context, *PauseWorkerRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseWorker not implemented")
}
func (*UnimplementedBESSControlServer) ResumeWorker(context.Context, *ResumeWorkerRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeWorker not implemented")
}
func (*UnimplementedBESSControlServer) ResumeAll(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeAll not implemented")
}
func (*UnimplementedBESSControlServer) ResetWorkers(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetWorkers not implemented")
}
func (*UnimplementedBESSControlServer) ListWorkers(context.Context, *EmptyRequest) (*ListWorkersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkers not implemented")
}
func (*UnimplementedBESSControlServer) AddWorker(context.Context, *AddWorkerRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWorker not implemented")
}
func (*UnimplementedBESSControlServer) DestroyWorker(context.Context, *DestroyWorkerRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyWorker not implemented")
}
func (*UnimplementedBESSControlServer) ResetTcs(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetTcs not implemented")
}
func (*UnimplementedBESSControlServer) ListTcs(context.Context, *ListTcsRequest) (*ListTcsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTcs not implemented")
}
func (*UnimplementedBESSControlServer) CheckSchedulingConstraints(context.Context, *EmptyRequest) (*CheckSchedulingConstraintsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckSchedulingConstraints not implemented")
}
func (*UnimplementedBESSControlServer) AddTc(context.Context, *AddTcRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTc not implemented")
}
func (*UnimplementedBESSControlServer) UpdateTcParams(context.Context, *UpdateTcParamsRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTcParams not implemented")
}
func (*UnimplementedBESSControlServer) UpdateTcParent(context.Context, *UpdateTcParentRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTcParent not implemented")
}
func (*UnimplementedBESSControlServer) GetTcStats(context.Context, *GetTcStatsRequest) (*GetTcStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTcStats not implemented")
}
func (*UnimplementedBESSControlServer) ListDrivers(context.Context, *EmptyRequest) (*ListDriversResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDrivers not implemented")
}
func (*UnimplementedBESSControlServer) GetDriverInfo(context.Context, *GetDriverInfoRequest) (*GetDriverInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDriverInfo not implemented")
}
func (*UnimplementedBESSControlServer) ResetPorts(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPorts not implemented")
}
func (*UnimplementedBESSControlServer) ListPorts(context.Context, *EmptyRequest) (*ListPortsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPorts not implemented")
}
func (*UnimplementedBESSControlServer) CreatePort(context.Context, *CreatePortRequest) (*CreatePortResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePort not implemented")
}
func (*UnimplementedBESSControlServer) DestroyPort(context.Context, *DestroyPortRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyPort not implemented")
}
func (*UnimplementedBESSControlServer) SetPortConf(context.Context, *SetPortConfRequest) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPortConf not implemented")
}
func (*UnimplementedBESSControlServer) GetPortConf(context.Context, *GetPortConfRequest) (*GetPortConfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPortConf not implemented")
}
func (*UnimplementedBESSControlServer) GetPortStats(context.Context, *GetPortStatsRequest) (*GetPortStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPortStats not implemented")
}
func (*UnimplementedBESSControlServer) GetLinkStatus(context.Context, *GetLinkStatusRequest) (*GetLinkStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLinkStatus not implemented")
}
func (*UnimplementedBESSControlServer) ListMclass(context.Context, *EmptyRequest) (*ListMclassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMclass not implemented")
}
func (*UnimplementedBESSControlServer) GetMclassInfo(context.Context, *GetMclassInfoRequest) (*GetMclassInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMclassInfo not implemented")
}
func (*UnimplementedBESSControlServer) ResetModules(context.Context, *EmptyRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetModules not implemented")
}
func (*UnimplementedBESSControlServer) ListModules(context.Context, *EmptyRequest) (*ListModulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModules not implemented")
}
func (*UnimplementedBESSControlServer) CreateModule(context.Context, *CreateModuleRequest) (*CreateModuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateModule not implemented")
}
func (*UnimplementedBESSControlServer) DestroyModule(context.Context, *DestroyModuleRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyModule not implemented")
}
func (*UnimplementedBESSControlServer) GetModuleInfo(context.Context, *GetModuleInfoRequest) (*GetModuleInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleInfo not implemented")
}
func (*UnimplementedBESSControlServer) ConnectModules(context.Context, *ConnectModulesRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectModules not implemented")
}
func (*UnimplementedBESSControlServer) DisconnectModules(context.Context, *DisconnectModulesRequest) (*EmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectModules not implemented")
}
func (*UnimplementedBESSControlServer) DumpMempool(context.Context, *DumpMempoolRequest) (*DumpMempoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpMempool not implemented")
}
func (*UnimplementedBESSControlServer) ModuleCommand(context.Context, *CommandRequest) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleCommand not implemented")
}
func (*UnimplementedBESSControlServer) ListGateHookClass(context.Context, *EmptyRequest) (*ListGateHookClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGateHookClass not implemented")
}
func (*UnimplementedBESSControlServer) GetGateHookClassInfo(context.Context, *GetGateHookClassInfoRequest) (*GetGateHookClassInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGateHookClassInfo not implemented")
}
func (*UnimplementedBESSControlServer) ConfigureGateHook(context.Context, *ConfigureGateHookRequest) (*ConfigureGateHookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureGateHook not implemented")
}
func (*UnimplementedBESSControlServer) ListGateHooks(context.Context, *EmptyRequest) (*ListGateHooksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGateHooks not implemented")
}
func (*UnimplementedBESSControlServer) GateHookCommand(context.Context, *GateHookCommandRequest) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GateHookCommand not implemented")
}
func (*UnimplementedBESSControlServer) ConfigureResumeHook(context.Context, *ConfigureResumeHookRequest) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureResumeHook not implemented")
}

func RegisterBESSControlServer(s *grpc.Server, srv BESSControlServer) {
	s.RegisterService(&_BESSControl_serviceDesc, srv)
}

func _BESSControl_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetVersion(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_KillBess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).KillBess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/KillBess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).KillBess(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ImportPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ImportPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ImportPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ImportPlugin(ctx, req.(*ImportPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UnloadPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnloadPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UnloadPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/UnloadPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UnloadPlugin(ctx, req.(*UnloadPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListPlugins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListPlugins(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_PauseAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).PauseAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/PauseAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).PauseAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_PauseWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).PauseWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/PauseWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).PauseWorker(ctx, req.(*PauseWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResumeWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResumeWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResumeWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResumeWorker(ctx, req.(*ResumeWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResumeAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResumeAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResumeAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResumeAll(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetWorkers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetWorkers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListWorkers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListWorkers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_AddWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).AddWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/AddWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).AddWorker(ctx, req.(*AddWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DestroyWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyWorker(ctx, req.(*DestroyWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetTcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetTcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetTcs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetTcs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListTcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListTcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListTcs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListTcs(ctx, req.(*ListTcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CheckSchedulingConstraints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CheckSchedulingConstraints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/CheckSchedulingConstraints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CheckSchedulingConstraints(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_AddTc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).AddTc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/AddTc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).AddTc(ctx, req.(*AddTcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UpdateTcParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTcParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UpdateTcParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/UpdateTcParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UpdateTcParams(ctx, req.(*UpdateTcParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_UpdateTcParent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTcParentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).UpdateTcParent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/UpdateTcParent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).UpdateTcParent(ctx, req.(*UpdateTcParentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetTcStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTcStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetTcStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetTcStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetTcStats(ctx, req.(*GetTcStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListDrivers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListDrivers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetDriverInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDriverInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetDriverInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetDriverInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetDriverInfo(ctx, req.(*GetDriverInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetPorts(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListPorts(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CreatePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CreatePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/CreatePort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CreatePort(ctx, req.(*CreatePortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DestroyPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyPort(ctx, req.(*DestroyPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_SetPortConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPortConfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).SetPortConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/SetPortConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).SetPortConf(ctx, req.(*SetPortConfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetPortConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortConfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetPortConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetPortConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetPortConf(ctx, req.(*GetPortConfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetPortStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetPortStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetPortStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetPortStats(ctx, req.(*GetPortStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetLinkStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinkStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetLinkStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetLinkStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetLinkStatus(ctx, req.(*GetLinkStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListMclass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListMclass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListMclass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListMclass(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetMclassInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMclassInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetMclassInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetMclassInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetMclassInfo(ctx, req.(*GetMclassInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ResetModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ResetModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ResetModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ResetModules(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListModules(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_CreateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).CreateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/CreateModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).CreateModule(ctx, req.(*CreateModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DestroyModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DestroyModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DestroyModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DestroyModule(ctx, req.(*DestroyModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetModuleInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModuleInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetModuleInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetModuleInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetModuleInfo(ctx, req.(*GetModuleInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConnectModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectModulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConnectModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ConnectModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConnectModules(ctx, req.(*ConnectModulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DisconnectModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectModulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DisconnectModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DisconnectModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DisconnectModules(ctx, req.(*DisconnectModulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_DumpMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpMempoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).DumpMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/DumpMempool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).DumpMempool(ctx, req.(*DumpMempoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ModuleCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ModuleCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ModuleCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ModuleCommand(ctx, req.(*CommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListGateHookClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListGateHookClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListGateHookClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListGateHookClass(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GetGateHookClassInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGateHookClassInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GetGateHookClassInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GetGateHookClassInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GetGateHookClassInfo(ctx, req.(*GetGateHookClassInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConfigureGateHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureGateHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConfigureGateHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ConfigureGateHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConfigureGateHook(ctx, req.(*ConfigureGateHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ListGateHooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ListGateHooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ListGateHooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ListGateHooks(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_GateHookCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GateHookCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).GateHookCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/GateHookCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).GateHookCommand(ctx, req.(*GateHookCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BESSControl_ConfigureResumeHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureResumeHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BESSControlServer).ConfigureResumeHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bess.pb.BESSControl/ConfigureResumeHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BESSControlServer).ConfigureResumeHook(ctx, req.(*ConfigureResumeHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BESSControl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bess.pb.BESSControl",
	HandlerType: (*BESSControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _BESSControl_GetVersion_Handler,
		},
		{
			MethodName: "ResetAll",
			Handler:    _BESSControl_ResetAll_Handler,
		},
		{
			MethodName: "KillBess",
			Handler:    _BESSControl_KillBess_Handler,
		},
		{
			MethodName: "ImportPlugin",
			Handler:    _BESSControl_ImportPlugin_Handler,
		},
		{
			MethodName: "UnloadPlugin",
			Handler:    _BESSControl_UnloadPlugin_Handler,
		},
		{
			MethodName: "ListPlugins",
			Handler:    _BESSControl_ListPlugins_Handler,
		},
		{
			MethodName: "PauseAll",
			Handler:    _BESSControl_PauseAll_Handler,
		},
		{
			MethodName: "PauseWorker",
			Handler:    _BESSControl_PauseWorker_Handler,
		},
		{
			MethodName: "ResumeWorker",
			Handler:    _BESSControl_ResumeWorker_Handler,
		},
		{
			MethodName: "ResumeAll",
			Handler:    _BESSControl_ResumeAll_Handler,
		},
		{
			MethodName: "ResetWorkers",
			Handler:    _BESSControl_ResetWorkers_Handler,
		},
		{
			MethodName: "ListWorkers",
			Handler:    _BESSControl_ListWorkers_Handler,
		},
		{
			MethodName: "AddWorker",
			Handler:    _BESSControl_AddWorker_Handler,
		},
		{
			MethodName: "DestroyWorker",
			Handler:    _BESSControl_DestroyWorker_Handler,
		},
		{
			MethodName: "ResetTcs",
			Handler:    _BESSControl_ResetTcs_Handler,
		},
		{
			MethodName: "ListTcs",
			Handler:    _BESSControl_ListTcs_Handler,
		},
		{
			MethodName: "CheckSchedulingConstraints",
			Handler:    _BESSControl_CheckSchedulingConstraints_Handler,
		},
		{
			MethodName: "AddTc",
			Handler:    _BESSControl_AddTc_Handler,
		},
		{
			MethodName: "UpdateTcParams",
			Handler:    _BESSControl_UpdateTcParams_Handler,
		},
		{
			MethodName: "UpdateTcParent",
			Handler:    _BESSControl_UpdateTcParent_Handler,
		},
		{
			MethodName: "GetTcStats",
			Handler:    _BESSControl_GetTcStats_Handler,
		},
		{
			MethodName: "ListDrivers",
			Handler:    _BESSControl_ListDrivers_Handler,
		},
		{
			MethodName: "GetDriverInfo",
			Handler:    _BESSControl_GetDriverInfo_Handler,
		},
		{
			MethodName: "ResetPorts",
			Handler:    _BESSControl_ResetPorts_Handler,
		},
		{
			MethodName: "ListPorts",
			Handler:    _BESSControl_ListPorts_Handler,
		},
		{
			MethodName: "CreatePort",
			Handler:    _BESSControl_CreatePort_Handler,
		},
		{
			MethodName: "DestroyPort",
			Handler:    _BESSControl_DestroyPort_Handler,
		},
		{
			MethodName: "SetPortConf",
			Handler:    _BESSControl_SetPortConf_Handler,
		},
		{
			MethodName: "GetPortConf",
			Handler:    _BESSControl_GetPortConf_Handler,
		},
		{
			MethodName: "GetPortStats",
			Handler:    _BESSControl_GetPortStats_Handler,
		},
		{
			MethodName: "GetLinkStatus",
			Handler:    _BESSControl_GetLinkStatus_Handler,
		},
		{
			MethodName: "ListMclass",
			Handler:    _BESSControl_ListMclass_Handler,
		},
		{
			MethodName: "GetMclassInfo",
			Handler:    _BESSControl_GetMclassInfo_Handler,
		},
		{
			MethodName: "ResetModules",
			Handler:    _BESSControl_ResetModules_Handler,
		},
		{
			MethodName: "ListModules",
			Handler:    _BESSControl_ListModules_Handler,
		},
		{
			MethodName: "CreateModule",
			Handler:    _BESSControl_CreateModule_Handler,
		},
		{
			MethodName: "DestroyModule",
			Handler:    _BESSControl_DestroyModule_Handler,
		},
		{
			MethodName: "GetModuleInfo",
			Handler:    _BESSControl_GetModuleInfo_Handler,
		},
		{
			MethodName: "ConnectModules",
			Handler:    _BESSControl_ConnectModules_Handler,
		},
		{
			MethodName: "DisconnectModules",
			Handler:    _BESSControl_DisconnectModules_Handler,
		},
		{
			MethodName: "DumpMempool",
			Handler:    _BESSControl_DumpMempool_Handler,
		},
		{
			MethodName: "ModuleCommand",
			Handler:    _BESSControl_ModuleCommand_Handler,
		},
		{
			MethodName: "ListGateHookClass",
			Handler:    _BESSControl_ListGateHookClass_Handler,
		},
		{
			MethodName: "GetGateHookClassInfo",
			Handler:    _BESSControl_GetGateHookClassInfo_Handler,
		},
		{
			MethodName: "ConfigureGateHook",
			Handler:    _BESSControl_ConfigureGateHook_Handler,
		},
		{
			MethodName: "ListGateHooks",
			Handler:    _BESSControl_ListGateHooks_Handler,
		},
		{
			MethodName: "GateHookCommand",
			Handler:    _BESSControl_GateHookCommand_Handler,
		},
		{
			MethodName: "ConfigureResumeHook",
			Handler:    _BESSControl_ConfigureResumeHook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
