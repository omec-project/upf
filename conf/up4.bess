# vim: syntax=py
# -*- mode: python -*-
# SPDX-License-Identifier: Apache-2.0
# Copyright(c) 2019 Intel Corporation

from conf.parser import *
import conf.ports as port
import conf.sim as sim

port.setup_globals()


# ====================================================
#	Read json config file (START HERE)
# ====================================================

Uplink = 0x0100
Downlink = 0x0200
Access = 1
Core = 2
FARForwardAction = 0
FARTunnelAction = 1
FARDropAction = 2
FARNotifyCPAction = 4
interfaces = ["s1u", "sgi"]
parser = Parser('conf/spgwu.json')
parser.parse(interfaces)

# Catch sgi & s1u MAC/IPv4 addresses
macstr_d = None
macstr_u = None
s1u_ip = None
if parser.mode == 'sim':
    macstr_d = '00:00:00:00:00:02'
    macstr_u = '00:00:00:00:00:01'
    s1u_ip = {0: '11.1.1.1'}
else:
    macstr_d = mac_by_interface(parser.sgi_ifname)
    macstr_u = mac_by_interface(parser.s1u_ifname)
    s1u_ip = ips_by_interface(parser.s1u_ifname)


inet_packets = [sim.gen_inet_packet(128, macstr_u, macstr_d, '172.16.100.1', '16.0.0.1'),
               sim.gen_inet_packet(128, macstr_u, macstr_d, '172.12.55.99', '16.0.0.1')]
ue_packets = [sim.gen_ue_packet(128, macstr_d, macstr_u, '11.1.1.128', '11.1.1.1', '16.0.0.1', '172.16.100.1')]
packet_generator = {'s1u': ue_packets, 'sgi': inet_packets}


# ====================================================
#       Core Setup
# ====================================================


# Initialize workers
cores = get_process_affinity()
for wid in xrange(parser.workers):
    bess.add_worker(wid=wid, core=int(cores[wid % len(cores)]))


# ====================================================
#       Port Setup
# ====================================================

ports = {}

# Before constructing the pipeline, pause bessd
bess.pause_all()

for idx, iface in enumerate(interfaces):
    # check if source natting for a given port is required
    try:
        ext_addrs = parser.interfaces[iface]["ip_masquerade"]
    except KeyError:
        ext_addrs = None
    except TypeError:
        ext_addrs = None

    p = port.Port(parser.interfaces[iface]["ifname"], ext_addrs)
    if p.name in ports:
        continue

    # initialize port with the configured driver
    p.init_port(idx, parser.mode, parser.workers)

    # setup port module with auxiliary modules
    p.setup_port(parser.ip_frag_with_eth_mtu, parser.measure, packet_generator[iface])

    # Finally add entry to ports list
    ports[p.name] = p


# ====================================================
# 	Shared Pipeline (DL + UL)
# ====================================================

######################################################
# The following atrributes are created by GtpuParser:
#   - dst_ip
#   - src_ip
#   - dst_port
#   - src_port
#   - teid (fseid)
#   - tunnel_ip4_dst
#   - proto_id

LinkMerge::Merge() \
    -> PktParse::GtpuParser():1 \
    -> PDRLookup::WildcardMatch(fields=[{'attr_name':'src_iface', 'num_bytes':1}, \
                                        {'attr_name':'tunnel_ipv4_dst', 'num_bytes':4}, \
                                        {'attr_name':'teid', 'num_bytes':4}, \
                                        {'attr_name':'dst_ip', 'num_bytes':4}, \
                                        {'attr_name':'src_ip', 'num_bytes':4}, \
                                        {'attr_name':'dst_port', 'num_bytes':2}, \
                                        {'attr_name':'src_port', 'num_bytes':2}, \
                                        {'attr_name':'ip_proto', 'num_bytes':1}], \
                                values=[{'attr_name':'pdr_id', 'num_bytes':4}, \
                                        {'attr_name':'fseid', 'num_bytes':4}, \
                                        {'attr_name':'ctr_id', 'num_bytes':4}, \
                                        {'attr_name':'far_id', 'num_bytes':4}, \
                                        {'attr_name':'needs_gtpu_decap', 'num_bytes':1}]):1 \
    -> PreQoSCounter::Counter(name_id='ctr_id', check_exist=True) \
    -> FARLookup::ExactMatch(fields=[{'attr_name':'far_id', 'num_bytes':4}, \
                                     {'attr_name':'fseid', 'num_bytes':4}], \
                             values=[{'attr_name':'action', 'num_bytes':1}, \
                                     {'attr_name':'tunnel_out_type', 'num_bytes':1}, \
                                     {'attr_name':'tunnel_out_src_ip4addr', 'num_bytes':4}, \
                                     {'attr_name':'tunnel_out_dst_ip4addr', 'num_bytes':4}, \
                                     {'attr_name':'tunnel_out_teid', 'num_bytes':4}, \
                                     {'attr_name':'tunnel_out_udp_port', 'num_bytes':2}]):1 \
    -> ExecuteFAR::Split(size=1, attribute='action')

# Drop unknown packets
PktParse:0 -> Sink()
PDRLookup:0 -> Sink()
FARLookup:0 -> Sink()
ExecuteFAR:FARDropAction -> FARDrop::Sink()
ExecuteFAR:FARNotifyCPAction -> FARNotifyCP::Sink()

# Set default gates for relevant modules
PDRLookup.set_default_gate(gate=0)
FARLookup.set_default_gate(gate=0)


# ====================================================
#       Downlink Pipeline
# ====================================================

# Pick fast-path gate for DL pipeline
sgiFastBPF = ports[parser.sgi_ifname].bpf
UEGate = 0
if ports[parser.sgi_ifname].ext_addrs is not None:
    UEGate = ports[parser.sgi_ifname].bpf_gate()
    ports[parser.sgi_ifname].bpf -> Sink()


# 1. Build initial DL pipeline here
sgiFastBPF:UEGate \
    -> sgiRxIPCksum::IPChecksum(verify=True) \
    -> sgiRxUDPCksum::L4Checksum(verify=True) \
    -> DLMACDstMatch::ExactMatch(fields=[{'offset':0, 'num_bytes':6}])

# Record last module to chain up optional modules
_in = DLMACDstMatch
gate = 0

# Append nat module (if enabled)
if ports[parser.sgi_ifname].nat is not None:
    _in:gate -> 1:ports[parser.sgi_ifname].nat
    _in = ports[parser.sgi_ifname].nat
    gate = 0

# Append sgiIP4Defrag module (if enabled)
if parser.max_ip_defrag_flows is not None:
    _in:gate -> sgiIP4Defrag::IPDefrag(num_flows=parser.max_ip_defrag_flows, numa=0)
    _in = sgiIP4Defrag
    gate = 1
    # Drop pkts that are unable to be fragmented
    sgiIP4Defrag:0 -> Sink()

# 2. Build the remaining first half of the DL pipeline before entering the shared pipeline
#ports[parser.sgi_ifname].rewrite \
_in:gate -> ueLookup::IPLookup() \
    -> SetMetadata(attrs=[{'name':'direction', 'size':4, 'value_int':Downlink}, \
                          {'name':'src_iface', 'size':1, 'value_int':Core}]) \
    -> LinkMerge # Start of the shared pipeline


# 3. Complete the last part of the DL pipeline
ExecuteFAR:FARTunnelAction \
    -> EtherEncapTrim::GenericDecap(bytes=14) \
    -> GTPUEncap::GtpuEncap():1 \
    -> S1UEtherAdd::GenericEncap(fields=[
        {'size': 6, 'value': {'value_int': 0x0}},
        {'size': 6, 'value': {'value_int': mac2hex(macstr_u)}},
        {'size': 2, 'value': {'value_int': 0x0800}}]) \
    -> PostDLQoSCounter::Counter(name_id='ctr_id', check_exist=True) \
    -> OuterUDPCsum::L4Checksum() \
    -> OuterIPCsum::IPChecksum() \
    -> ports[parser.s1u_ifname].rtr

# Drop unknown packets
GTPUEncap:0 -> Sink()
sgiRxIPCksum:1 -> Sink()
sgiRxUDPCksum:1 -> Sink()
OuterIPCsum:1 -> Sink()
OuterUDPCsum:1 -> Sink()
DLMACDstMatch:1 -> Sink()
ueLookup:MAX_GATES-1 -> Sink()

# Set default gates for relevant modules
DLMACDstMatch.set_default_gate(gate=1)

# Add SGi filter rules, i.e.:
# setting filter to detect ue_filter traffic
# the filter can either be based on the NAT IP addr(s),
# or ue IP addr subnet
if ports[parser.sgi_ifname].nat is not None:
    ue_filter = {"priority": -UEGate,
                 "filter": "ip dst {}".format(ports[parser.sgi_ifname].ext_addrs), "gate": UEGate}
    sgiFastBPF.add(filters=[ue_filter])

# Verify that destination MAC address matches that with sgi interface
# i.e. insert a rule so that destination MAC address of the interface
# is an 'exact' match
DLMACDstMatch.add(fields=[{'value_int': mac2hex(macstr_d)}], gate=0)

# Add ueLookup rules
ueLookup.add(prefix='0.0.0.0', prefix_len=0, gate=MAX_GATES-1)
ueLookup.add(prefix=cidr2netmask(parser.ue_cidr)[0], prefix_len=(int)(parser.ue_cidr.split('/')[1]), gate=0)


# ====================================================
#       Uplink Pipeline
# ====================================================


# Pick fast-path and echo gates for UL pipeline
s1uFastBPF = ports[parser.s1u_ifname].bpf
GTPUEchoGate = ports[parser.s1u_ifname].bpf_gate()
GTPUGate = 0


# 1. Build initial UL pipeline here
s1uFastBPF:GTPUGate \
    -> s1uRxIPCksum::IPChecksum(verify=True) \
    -> s1uRxUDPCksum::L4Checksum(verify=True) \
    -> ULMACDstMatch::ExactMatch(fields=[{'offset':0, 'num_bytes':6}])

# Record last module to chain up option modules
_in = ULMACDstMatch
gate = 0

# Append s1uIP4Defrag module (if enabled)
if parser.max_ip_defrag_flows is not None:
    _in:gate ->s1uIP4Defrag::IPDefrag(num_flows=parser.max_ip_defrag_flows, numa=0)
    _in = s1uIP4Defrag
    gate = 1
    # Drop pkts that are unable to be fragmented
    s1uIP4Defrag:0 -> Sink()

# 2. Build the remaining first half of the UL pipeline before entering the shard pipeline
#ports[parser.s1u_ifname].rewrite \
_in:gate -> InetLookup::IPLookup() \
    -> SetMetadata(attrs=[{'name':'direction', 'size':4, 'value_int':Uplink}, \
                          {'name':'src_iface', 'size':1, 'value_int':Access}]) \
    -> LinkMerge # Start of the shared pipeline

# 3. Complete the last part of the UL pipeline
ExecuteFAR:FARForwardAction \
    -> EtherDecapTrim::GenericDecap(bytes=14) -> GTPUDecap::GtpuDecap() \
    -> SGIEtherAdd::GenericEncap(fields=[
        {'size': 6, 'value': {'value_int': 0x0}},
        {'size': 6, 'value': {'value_int': mac2hex(macstr_d)}},
        {'size': 2, 'value': {'value_int': 0x0800}}]) \
    -> PostULQoSCounter::Counter(name_id='ctr_id', check_exist=True) \
    -> ports[parser.sgi_ifname].rtr

# 4. GTP Echo response pipeline
s1uFastBPF:GTPUEchoGate \
    	-> gtpRxIPCksum::IPChecksum(verify=True) \
        -> gtpRxUDPCksum::L4Checksum(verify=True) \
	-> GTPUEcho::GtpuEcho(s1u_sgw_ip=ip2long(s1u_ip[0])):1 \
        -> EthSwap::MACSwap() \
        -> 1:OuterUDPCsum

# Drop unknown packets
GTPUEcho:0 -> Sink()
gtpRxIPCksum:1 -> Sink()
gtpRxUDPCksum:1 -> Sink()
ULMACDstMatch:1 -> Sink()
s1uRxIPCksum:1 -> Sink()
s1uRxUDPCksum:1 -> Sink()

# Set default gates for relevant modules
ULMACDstMatch.set_default_gate(gate=1)

# Add S1u filter rules, i.e.:
# setting filter to detect gtpu traffic
# src net 11.1.1.0 mask 255.255.255.0           # check eNB subnet
# and dst host 11.1.1.1                         # check S/PGWU IP
# and udp dst port 2152                         # check GTPU port
# and (udp[28:4] & 0xffffff00) = 0x10000000     # check UE subnet
check_enb_subnet = "src net {} ".format(parser.enb_cidr)
check_spgwu_ip = " and dst host " + \
    " or ".join(str(x) for x in s1u_ip)
check_gtpu_port = " and udp dst port 2152"
check_ue_subnet = " and (udp[28:4] & 0x{}) = 0x{}".format(
    cidr2mask(parser.ue_cidr), ip2hex(cidr2block(parser.ue_cidr)[0]))
check_gtpu_msg_echo = " and udp[9] = 0x1"

# Echo filter
uplink_echo_filter = {"priority": -GTPUEchoGate, "filter": check_enb_subnet +
                      check_spgwu_ip + check_gtpu_port +
                      check_gtpu_msg_echo, "gate": GTPUEchoGate}
s1uFastBPF.add(filters=[uplink_echo_filter])

# PDU rule
uplink_filter = {"priority": -GTPUGate, "filter": check_enb_subnet +
               check_spgwu_ip + check_gtpu_port, "gate": GTPUGate}
s1uFastBPF.add(filters=[uplink_filter])

# Verify that destination MAC address matches that with s1u interface
# Exact match on desstination MAC address of the interface
ULMACDstMatch.add(fields=[{'value_int': mac2hex(macstr_u)}], gate=0)

# Add InetLookup rules
InetLookup.add(prefix='0.0.0.0', prefix_len=0, gate=0)


# ====================================================
#       Route Control
# ====================================================
# Finally send SIGHUP to route_control daemon on reload
# TODO: behavior is unspecified if route_control.py pid is not found
route_control_pid = getpythonpid('route_control.py')
if route_control_pid:
    os.kill(route_control_pid, signal.SIGHUP)


# ===================================================
#	SIM TEST FUNC DEFINITIONS
#====================================================
import time

start_teid = 0xf0000000
start_ue_ip = 0x10000001
start_enb_ip = 0x0b010181
NG4T_MAX_UE_RAN = 500000
NG4T_MAX_ENB_RAN = 80
s1u_sgw_ip=ip2long(s1u_ip[0])


def sim_start_test():

    for i in range(parser.max_sessions):

        # NG4T-based formula to calculate enodeB IP address against a given UE IP address
        # il_trafficgen also uses the same scheme
        # See SimuCPEnbv4Teid(...) in ngic code for more details
        ue_of_ran = i % NG4T_MAX_UE_RAN
        ran = i / NG4T_MAX_UE_RAN
        enb_of_ran = ue_of_ran % NG4T_MAX_ENB_RAN
        enb_idx = ran * NG4T_MAX_ENB_RAN + enb_of_ran

        PDRLookup.add(gate=1, priority=1,
                      values=[{'value_int':Core},	     # src_iface
                              {'value_int':0},		     # tunnel_ipv4_dst
                              {'value_int':0},               # enb_teid
                              {'value_int':start_ue_ip+i},   # ueaddr ip
                              {'value_int':0},               # inet ip
                              {'value_int':0},               # ue port
                              {'value_int':0},               # inet port
                              {'value_int':0}],              # proto-id
                      masks=[{'value_int':0xFF},	     # src_iface-mask
                              {'value_int':0},		     # tunnel_ipv4_dst-mask
                              {'value_int':0},               # enb_teid-mask
                              {'value_int':0xFFFFFFFF},      # ueaddr ip-mask
                              {'value_int':0},               # inet ip-mask
                              {'value_int':0},               # ue port-mask
                              {'value_int':0},               # inet port-mask
                              {'value_int':0}],              # proto-id-mask
                      valuesv=[{'value_int':0},	     	     # pdr-id
                              {'value_int':start_teid+i},    # fseid
                              {'value_int':start_teid+i},    # ctr_id
                              {'value_int':1},               # far_id
                              {'value_int':0}])              # need_decap

        PDRLookup.add(gate=1, priority=1,
                      values=[{'value_int':Access},	     # src_iface
                              {'value_int':0},		     # tunnel_ipv4_dst
                              {'value_int':start_teid+i},    # enb_teid
                              {'value_int':0},               # inet ip
                              {'value_int':start_ue_ip+i},   # ueaddr ip
                              {'value_int':0},               # inet port
                              {'value_int':0},               # ue port
                              {'value_int':0}],              # proto-id
                      masks=[{'value_int':0xFF},	     # src_iface-mask
                              {'value_int':0},		     # tunnel_ipv4_dst-mask
                              {'value_int':0xFFFFFFFF},      # enb_teid-mask
                              {'value_int':0},               # inet ip-mask
                              {'value_int':0xFFFFFFFF},      # ueaddr ip-mask
                              {'value_int':0},               # inet port-mask
                              {'value_int':0},               # ue port-mask
                              {'value_int':0}],              # proto-id-mask
                      valuesv=[{'value_int':0},	     	     # pdr-id
                              {'value_int':start_teid+i},    # fseid
                              {'value_int':start_teid+i},    # ctr_id
                              {'value_int':0},               # far_id
                              {'value_int':1}])              # need_decap-mask

        FARLookup.add(gate=1,
                      fields=[{'value_int':1},                      # far-id
                              {'value_int':start_teid+i}],          # fseid
                      values=[{'value_int':FARTunnelAction},        # action
                              {'value_int':1},                      # tunnel_out_type
                              {'value_int':s1u_sgw_ip},             # s1u_ip
                              {'value_int':start_enb_ip+enb_idx},   # enb ip
                              {'value_int':start_teid+i},           # enb teid
                              {'value_int':2152}])                  # udp gtpu port

        FARLookup.add(gate=1,
                      fields=[{'value_int':0},                      # far-id
                              {'value_int':start_teid+i}],          # fseid
                      values=[{'value_int':FARForwardAction},       # action
                              {'value_int':0},                      # tunnel_out_type
                              {'value_int':0},                      # not needed
                              {'value_int':0},                      # not needed
                              {'value_int':0},                      # not needed
                              {'value_int':0}])                     # not needed

        PreQoSCounter.add(ctr_id=start_teid+i)                      # fseid

        PostDLQoSCounter.add(ctr_id=start_teid+i)                     # fseid

    # Connect the source with the pipeline to start pumping the packets
    bess.resume_all()


def sim_end_test():

    # Disconnect the source with the pipeline to end traffic movement
    bess.pause_all()
    bess.disconnect_modules(ports[parser.sgi_ifname].fpi.name)
    bess.disconnect_modules(ports[parser.s1u_ifname].fpi.name)

    for i in range(parser.max_sessions):

        # NG4T-based formula to calculate enodeB IP address against a given UE IP address
        # il_trafficgen also uses the same scheme
        # See SimuCPEnbv4Teid(...) in ngic code for more details
        ue_of_ran = i % NG4T_MAX_UE_RAN
        ran = i / NG4T_MAX_UE_RAN
        enb_of_ran = ue_of_ran % NG4T_MAX_ENB_RAN
        enb_idx = ran * NG4T_MAX_ENB_RAN + enb_of_ran

        PDRLookup.delete(values=[{'value_int':Core},	     # src_iface
                              {'value_int':0},		     # tunnel_ipv4_dst
                              {'value_int':0},               # enb_teid
                              {'value_int':start_ue_ip+i},   # ueaddr ip
                              {'value_int':0},               # inet ip
                              {'value_int':0},               # ue port
                              {'value_int':0},               # inet port
                              {'value_int':0}],              # proto-id
                      masks=[{'value_int':0xFF},	     # src_iface-mask
                              {'value_int':0},		     # tunnel_ipv4_dst-mask
                              {'value_int':0},               # enb_teid-mask
                              {'value_int':0xFFFFFFFF},      # ueaddr ip-mask
                              {'value_int':0},               # inet ip-mask
                              {'value_int':0},               # ue port-mask
                              {'value_int':0},               # inet port-mask
                              {'value_int':0}])              # proto-id-mask

        PDRLookup.delete(values=[{'value_int':Access},	     # src_iface
                              {'value_int':0},		     # tunnel_ipv4_dst
                              {'value_int':start_teid+i},    # enb_teid
                              {'value_int':0},               # inet ip
                              {'value_int':start_ue_ip+i},   # ueaddr ip
                              {'value_int':0},               # inet port
                              {'value_int':0},               # ue port
                              {'value_int':0}],              # proto-id
                      masks=[{'value_int':0xFF},	     # src_iface-mask
                              {'value_int':0},		     # tunnel_ipv4_dst-mask
                              {'value_int':0xFFFFFFFF},      # enb_teid-mask
                              {'value_int':0},               # inet ip-mask
                              {'value_int':0xFFFFFFFF},      # ueaddr ip-mask
                              {'value_int':0},               # inet port-mask
                              {'value_int':0},               # ue port-mask
                              {'value_int':0}])              # proto-id-mask

        FARLookup.delete(fields=[{'value_int':1},                   # far-id
                              {'value_int':start_teid+i}])          # fseid

        FARLookup.delete(fields=[{'value_int':0},                   # far-id
                              {'value_int':start_teid+i}])          # fseid

        PreQoSCounter.remove(ctr_id=start_teid+i)                      # fseid

        PostDLQoSCounter.remove(ctr_id=start_teid+i)                     # fseid

    #bess.resume_all()
    #bess.reset_all()


# ===================================================
#	SIM TEST CALLS
#====================================================

### Uncomment the following lines to test with Source ###
if parser.mode == 'sim':
    # Start the test
    sim_start_test()
    # Wait for 1000 seconds before deleting the session info entries (optional)
    time.sleep(1000)
    sim_end_test()

# Pipeline complete, resume bessd (if it is not "sim")
bess.resume_all()
