# vim: syntax=py
# -*- mode: python -*-
# SPDX-License-Identifier: Apache-2.0
# Copyright(c) 2019 Intel Corporation

from conf.parser import *


# ====================================================
#       Port Helpers
# ====================================================


MAX_GATES = 8192
dpdk_ports = {}


def scan_dpdk_ports():
    idx = 0
    while True:
        try:
            intf = PMDPort(name="Port {}".format(idx), port_id=idx)
            if intf:
                # Need to declare mac so that we don't lose key during destroy_port
                mac = intf.mac_addr
                dpdk_ports[mac] = idx
                bess.destroy_port(intf.name)
        except bess.Error as e:
            if e.code == errno.ENODEV:
                break
            else:
                raise
        idx += 1
        # RTE_MAX_ETHPORTS is 32 and we need 2 for vdevs
        if idx == 30:
          break
    return True if dpdk_ports else False


class Port:
    def __init__(self, name, ext_addrs):
        self.name = name
        self.wid = None
        self.fpi = None
        self.fpo = None
        self.bpf = None
        self.bpfgate = 0
        self.routes_table = None
        self.nat = None
        self.ext_addrs = ext_addrs

    def bpf_gate(self):
        if self.bpfgate < MAX_GATES - 2:
            self.bpfgate += 1
            return self.bpfgate
        else:
            raise Exception('Port {}: Out of BPF gates to allocate'.format(self.name))

    def detect_mode(self):
        try:
            peer_by_interface(self.name)
            parser.mode = 'dpdk'
        except:
            parser.mode = 'linux'
        return parser.mode

    def init_fastpath(self, **kwargs):
        # Initialize PMDPort and RX/TX modules
        name = self.name
        fast = PMDPort(name="{}Fast".format(name), **kwargs)
        self.fpi = __bess_module__("{}FastPI".format(name), 'PortInc', port=fast.name)
        self.fpo = __bess_module__("{}FastPO".format(name), 'PortOut', port=fast.name)

        # Initialize BPF to classify incoming traffic to go to kernel and/or pipeline
        self.bpf = __bess_module__("{}FastBPF".format(name), 'BPF')
        self.bpf.clear()

        # Initialize route module
        self.rtr = __bess_module__("{}Routes".format(name), 'IPLookup')

        # Default route goes to Sink
        self.rtr.add(prefix='0.0.0.0', prefix_len=0, gate=MAX_GATES-1)
        self.rtr:(MAX_GATES-1) -> Sink()

        # Attach fastpath to worker's root TC
        self.fpi.attach_task(wid=self.wid)

    def setup_port(self, idx, conf_workers):
        # Pick the worker handling this port
        self.wid = idx % conf_workers

        name = self.name
        wid = self.wid
        print('Setting up port {} on worker {}'.format(name,wid))

        # Detect the mode of this interface - DPDK/AF_XDP/AF_PACKET
        global parser
        conf_mode = parser.mode
        if conf_mode is None:
            conf_mode = self.detect_mode()

        if conf_mode in ['af_xdp', 'linux']:
            try:
                # Initialize kernel fastpath.
                # AF_XDP requires that num_rx_qs == num_tx_qs
                kwargs = {"vdev" : "net_af_xdp{},iface={},start_queue=0,queue_count={}"
                          .format(idx, name, conf_workers), "num_out_q": conf_workers, "num_inc_q": conf_workers}
                self.init_fastpath(**kwargs)
            except:
                if conf_mode == 'linux':
                    print('Failed to create AF_XDP socket for {}. Retrying with AF_PACKET socket...'.format(name))
                    conf_mode = 'af_packet'
                else:
                    print('Failed to create AF_XDP socket for {}. Exiting...'.format(name))
                    sys.exit()

        if conf_mode == 'af_packet':
            try:
                # Initialize kernel fastpath
                kwargs = {"vdev" : "net_af_packet{},iface={},qpairs={}".format(idx, name, conf_workers), "num_out_q": conf_workers}
                self.init_fastpath(**kwargs)
            except:
                print('Failed to create AF_PACKET socket for {}. Exiting...'.format(name))
                sys.exit()

        elif conf_mode == 'dpdk':
            kwargs = None
            pci = alias_by_interface(name)
            if pci is not None:
                kwargs = {"pci": pci, "num_out_q": conf_workers}
                try:
                    self.init_fastpath(**kwargs)
                except:
                    kwargs = None
                    print('Unable to initialize {} fastpath using alias {},\
                        falling back to scan'.format(name, pci))
            if kwargs is None:
                # Fallback to scanning ports
                # if port list is empty, scan for dpdk_ports first
                if not dpdk_ports and scan_dpdk_ports() == False:
                    print('Registered dpdk ports do not exist.')
                    sys.exit()
                # Initialize DPDK fastpath
                fidx = dpdk_ports.get(mac_by_interface(name))
                if fidx is None:
                    raise Exception(
                        'Registered port for {} not detected!'.format(name))
                kwargs = {"port_id": fidx, "num_out_q": conf_workers}
                self.init_fastpath(**kwargs)

            # Initialize kernel slowpath port and RX/TX modules
            try:
                peer = peer_by_interface(name)
                vdev = "net_af_packet{},iface={}".format(idx, peer)
                slow = PMDPort(name="{}Slow".format(name), vdev=vdev)
                spi = __bess_module__("{}SlowPI".format(name), 'PortInc', port=slow.name)
                spo = __bess_module__("{}SlowPO".format(name), 'PortOut', port=slow.name)
                qspo = __bess_module__("{}QSlowPO".format(name), 'Queue')

                # host_ip_filter: tcpdump -i foo 'dst host 198.19.0.1 or 198.18.0.1' -d
                # Should always be set to lowest priority
                HostGate = MAX_GATES - 1
                ips = ips_by_interface(name)
                host_ip_filter = {"priority": -HostGate, "filter": "dst host "
                                + " or ".join(str(x) for x in ips), "gate": HostGate}

                self.bpf.add(filters=[host_ip_filter])

                # Direct control traffic from DPDK to kernel
                self.bpf:HostGate -> qspo -> spo

                # Direct control traffic from kernel to DPDK
                spi -> self.fpo

                tc = 'slow{}'.format(wid)
                try:
                    bess.add_tc(tc, policy='round_robin', wid=wid)
                except Exception as e:
                    if e.errmsg == "Name '{}' already exists".format(tc):
                        pass
                    else:
                        raise e
                # Limit scheduling slow path RX/TX to 1000 times/second each
                for mod in spi, qspo:
                    bess.add_tc(mod.name,
                            parent=tc,
                            policy='rate_limit',
                            resource='count',
                            limit={'count': 1000})
                    mod.attach_task(mod.name)
            except Exception as e:
                print('Mirror veth interface: {} misconfigured: {}'.format(name, e))
        else:
            raise Exception('Invalid mode selected.')


# ====================================================
#	Read json config file (START HERE)
# ====================================================

Uplink = 1
Downlink = 2
Access = 1
Core = 2
interfaces = ["s1u", "sgi"]
parser = Parser('conf/spgwu.json')
parser.parse(interfaces)


# ====================================================
#       Validate CIDRs
# ====================================================


cidrs = [parser.enb_cidr, parser.ue_cidr]
for cidr in cidrs:
    if validate_cidr(cidr) is False:
        exit(1, 'Invalid {}'.format(cidr))


# ====================================================
#       Core Setup
# ====================================================


# Initialize workers
cores = get_process_affinity()
for wid in xrange(parser.workers):
    bess.add_worker(wid=wid, core=int(cores[wid % len(cores)]))


# ====================================================
#       Port Setup
# ====================================================

ports = {}

# Before constructing the pipeline, pause bessd
bess.pause_all()

for idx, iface in enumerate(interfaces):
    # check if source natting for a given port is required
    try:
        ext_addrs = parser.interfaces[iface]["ip_masquerade"]
    except KeyError:
        ext_addrs = None

    port = Port(parser.interfaces[iface]["ifname"], ext_addrs)
    if port.name in ports:
        continue
    port.setup_port(idx, parser.workers)

    out = port.fpo
    # enable frag module (if enabled) to control port MTU size
    if parser.ip_frag_with_eth_mtu is not None:
        frag = __bess_module__("{}IP4Frag".format(port.name), 'IPFrag', mtu=parser.ip_frag_with_eth_mtu)
        frag:1 -> out
        frag:0 -> Sink()
        out = frag

    # enable telemetrics (if enabled) (how many bytes seen in and out of port)
    if parser.measure:
        port.fpi -> Timestamp(attr_name="{}timestamp".format(port.name)) -> port.bpf -> Sink()
        m = Measure(attr_name="{}timestamp".format(port.name))
        m -> out
        out = m
    else:
        port.fpi -> port.bpf -> Sink()

    # Attach nat module (if enabled)
    if port.ext_addrs is not None:
        # Tokenize the string
        addrs = port.ext_addrs.split(' or ')
        # Make a list of ext_addr
        nat_list = list()
        for addr in addrs:
            nat_dict = dict()
            nat_dict['ext_addr'] = addr
            nat_list.append(nat_dict)

        # Create the NAT module
        port.nat = __bess_module__("{}NAT".format(parser.interfaces[iface]["ifname"]), 'NAT', ext_addrs=nat_list)
        port.nat:1 -> out
        out = port.nat

    # Direct fast path traffic to Merge module
    merge = __bess_module__("{}Merge".format(port.name), 'Merge')
    # Attach Merge module to the 'outlist' of modules
    merge -> out

    # Finally add entry to ports list
    ports[port.name] = port


# ====================================================
# 	Shared Pipeline (DL + UL)
# ====================================================

######################################################
# The following atrributes are created by GtpuParser:
#   - dst_ip
#   - src_ip
#   - dst_port
#   - src_port
#   - teid (fseid)
#   - tunnel_ip4_dst
#   - proto_id

LinkMerge::Merge() \
    -> PktParse::GtpuParser():1 \
    -> PDRLookup::WildcardMatch(fields=[{'attr_name':'src_iface', 'num_bytes':1}, \
                                        {'attr_name':'tunnel_ipv4_dst', 'num_bytes':4}, \
                                        {'attr_name':'teid', 'num_bytes':4}, \
                                        {'attr_name':'dst_ip', 'num_bytes':4}, \
                                        {'attr_name':'src_ip', 'num_bytes':4}, \
                                        {'attr_name':'dst_port', 'num_bytes':2}, \
                                        {'attr_name':'src_port', 'num_bytes':2}, \
                                        {'attr_name':'ip_proto', 'num_bytes':1}], \
                                values=[{'attr_name':'pdr_id', 'num_bytes':4}, \
                                        {'attr_name':'fseid', 'num_bytes':4}, \
                                        {'attr_name':'ctr_id', 'num_bytes':4}, \
                                        {'attr_name':'far_id', 'num_bytes':4}, \
                                        {'attr_name':'needs_gtpu_decap', 'num_bytes':1}]):1 \
    -> PreQoSCounter::Counter(name_id='ctr_id') \
    -> FARLookup::ExactMatch(fields=[{'attr_name':'far_id', 'num_bytes':4}, \
                                     {'attr_name':'fseid', 'num_bytes':4}], \
                             values=[{'attr_name':'needs_tunneling', 'num_bytes':1}, \
                                     {'attr_name':'needs_dropping', 'num_bytes':1}, \
                                     {'attr_name':'notify_cp', 'num_bytes':1}, \
                                     {'attr_name':'tunnel_out_type', 'num_bytes':1}, \
                                     {'attr_name':'tunnel_out_src_ip4addr', 'num_bytes':4}, \
                                     {'attr_name':'tunnel_out_dst_ip4addr', 'num_bytes':4}, \
                                     {'attr_name':'tunnel_out_teid', 'num_bytes':4}, \
                                     {'attr_name':'tunnel_out_udp_port', 'num_bytes':2}]):1 \
    -> ExecuteFAR::ExactMatch(fields=[{'attr_name':'needs_tunneling', 'num_bytes':1}, \
                                      {'attr_name':'needs_dropping', 'num_bytes':1}, \
                                      {'attr_name':'notify_cp', 'num_bytes':1}])

# Drop unknown packets
PktParse:0 -> Sink()
PDRLookup:0 -> Sink()
FARLookup:0 -> Sink()
ExecuteFAR:0 -> FARDrop::Sink()
ExecuteFAR:3 -> FARNotifyCP::Sink()

# Set default gates for relevant modules
PDRLookup.set_default_gate(gate=0)
FARLookup.set_default_gate(gate=0)
ExecuteFAR.set_default_gate(gate=0)

# Add needs_tunneling, needs_dropping & notify_cp rules to ExecuteFAR here
ExecuteFAR.add(fields=[{'value_int':1}, {'value_int':0}, {'value_int':0}], gate=1)
ExecuteFAR.add(fields=[{'value_int':0}, {'value_int':1}, {'value_int':0}], gate=0)
ExecuteFAR.add(fields=[{'value_int':0}, {'value_int':0}, {'value_int':1}], gate=3)
ExecuteFAR.add(fields=[{'value_int':0}, {'value_int':0}, {'value_int':0}], gate=2)


# ====================================================
#       Downlink Pipeline
# ====================================================

# Pick fast-path gate for DL pipeline
sgiFastBPF = ports[parser.sgi_ifname].bpf
UEGate = ports[parser.sgi_ifname].bpf_gate()


# 1. Build initial DL pipeline here
sgiFastBPF:UEGate \
    -> sgiRxIPCksum::IPChecksum(verify=True) \
    -> sgiRxUDPCksum::L4Checksum(verify=True) \
    -> DLMACDstMatch::ExactMatch(fields=[{'offset':0, 'num_bytes':6}])

# Record last module to chain up optional modules
_in = DLMACDstMatch
gate = 0

# Append nat module (if enabled)
if ports[parser.sgi_ifname].nat is not None:
    _in:gate -> 1:ports[parser.sgi_ifname].nat
    _in = ports[parser.sgi_ifname].nat
    gate = 0

# Append sgiIP4Defrag module (if enabled)
if parser.max_ip_defrag_flows is not None:
    _in:gate -> sgiIP4Defrag::IPDefrag(num_flows=parser.max_ip_defrag_flows, numa=0)
    _in = sgiIP4Defrag
    gate = 1
    # Drop pkts that are unable to be fragmented
    sgiIP4Defrag:0 -> Sink()

# 2. Build the remaining first half of the DL pipeline before entering the shared pipeline
_in:gate -> ueLookup::IPLookup() \
    -> SetMetadata(attrs=[{'name':'direction', 'size':1, 'value_int':Downlink}, \
                          {'name':'src_iface', 'size':1, 'value_int':Core}]) \
    -> LinkMerge # Start of the shared pipeline


# 3. Complete the last part of the DL pipeline
ExecuteFAR:1 \
    -> EtherTrim::GenericDecap(bytes=14) \
    -> GTPUEncap::GtpuEncap():1 \
    -> S1UEtherAdd::GenericEncap(fields=[
        {'size': 6, 'value': {'value_int': 0x0}},
        {'size': 6, 'value': {'value_int': mac2hex(mac_by_interface(parser.s1u_ifname))}},
        {'size': 2, 'value': {'value_int': 0x0800}}]) \
    -> PostQoSCounter::Counter(name_id='ctr_id') \
    -> OuterUDPCsum::L4Checksum() \
    -> OuterIPCsum::IPChecksum() \
    -> ports[parser.s1u_ifname].rtr

# Drop unknown packets
GTPUEncap:0 -> Sink()
sgiRxIPCksum:1 -> Sink()
sgiRxUDPCksum:1 -> Sink()
OuterIPCsum:1 -> Sink()
OuterUDPCsum:1 -> Sink()
DLMACDstMatch:1 -> Sink()
ueLookup:MAX_GATES-1 -> Sink()

# Set default gates for relevant modules
DLMACDstMatch.set_default_gate(gate=1)

# Add SGi filter rules, i.e.:
# setting filter to detect ue_filter traffic
# the filter can either be based on the NAT IP addr(s),
# or ue IP addr subnet
if ports[parser.sgi_ifname].nat is not None:
    ue_filter = {"priority": -UEGate,
                 "filter": "ip dst {}".format(ports[parser.sgi_ifname].ext_addrs), "gate": UEGate}
else:
    ue_filter = {"priority": -UEGate,
                 "filter": "ip dst net {}".format(parser.ue_cidr), "gate": UEGate}
sgiFastBPF.add(filters=[ue_filter])

# Verify that destination MAC address matches that with sgi interface
# i.e. insert a rule so that destination MAC address of the interface
# is an 'exact' match
macstr_d = mac_by_interface(parser.sgi_ifname)
DLMACDstMatch.add(fields=[{'value_int': mac2hex(macstr_d)}], gate=0)

# Add ueLookup rules
ueLookup.add(prefix='0.0.0.0', prefix_len=0, gate=MAX_GATES-1)
ueLookup.add(prefix=cidr2netmask(parser.ue_cidr)[0], prefix_len=(int)(parser.ue_cidr.split('/')[1]), gate=0)


# ====================================================
#       Uplink Pipeline
# ====================================================


# Pick fast-path and echo gates for UL pipeline
s1uFastBPF = ports[parser.s1u_ifname].bpf
GTPUEchoGate = ports[parser.s1u_ifname].bpf_gate()
GTPUGate = ports[parser.s1u_ifname].bpf_gate()


# 1. Build initial UL pipeline here
s1uFastBPF:GTPUGate \
    -> s1uRxIPCksum::IPChecksum(verify=True) \
    -> s1uRxUDPCksum::L4Checksum(verify=True) \
    -> ULMACDstMatch::ExactMatch(fields=[{'offset':0, 'num_bytes':6}])

# Record last module to chain up option modules
_in = ULMACDstMatch
gate = 0

# Append s1uIP4Defrag module (if enabled)
if parser.max_ip_defrag_flows is not None:
    _in:gate ->s1uIP4Defrag::IPDefrag(num_flows=parser.max_ip_defrag_flows, numa=0)
    _in = s1uIP4Defrag
    gate = 1
    # Drop pkts that are unable to be fragmented
    s1uIP4Defrag:0 -> Sink()    

# 2. Build the remaining first half of the UL pipeline before entering the shard pipeline
_in:gate -> InetLookup::IPLookup() \
    -> SetMetadata(attrs=[{'name':'direction', 'size':1, 'value_int':Uplink}, \
                          {'name':'src_iface', 'size':1, 'value_int':Access}]) \
    -> LinkMerge # Start of the shared pipeline

# 3. Complete the last part of the UL pipeline
ExecuteFAR:2 \
    -> EtherDecapTrim::GenericDecap(bytes=14) -> GTPUDecap::GtpuDecap() \
    -> SGIEtherAdd::GenericEncap(fields=[
        {'size': 6, 'value': {'value_int': 0x0}},
        {'size': 6, 'value': {'value_int': mac2hex(mac_by_interface(parser.sgi_ifname))}},
        {'size': 2, 'value': {'value_int': 0x0800}}]) \
    -> ports[parser.sgi_ifname].rtr

# 4. GTP Echo response pipeline
s1uFastBPF:GTPUEchoGate \
    	-> gtpRxIPCksum::IPChecksum(verify=True) \
        -> gtpRxUDPCksum::L4Checksum(verify=True) \
	-> GTPUEcho::GtpuEcho(s1u_sgw_ip=ip2long(ips_by_interface(parser.s1u_ifname)[0])):1 \
        -> EthSwap::MACSwap() \
        -> 1:OuterUDPCsum

# Drop unknown packets
GTPUEcho:0 -> Sink()
gtpRxIPCksum:1 -> Sink()
gtpRxUDPCksum:1 -> Sink()
ULMACDstMatch:1 -> Sink()
s1uRxIPCksum:1 -> Sink()
s1uRxUDPCksum:1 -> Sink()

# Set default gates for relevant modules
ULMACDstMatch.set_default_gate(gate=1)

# Add S1u filter rules, i.e.:
# setting filter to detect gtpu traffic
# src net 11.1.1.0 mask 255.255.255.0           # check eNB subnet
# and dst host 11.1.1.1                         # check S/PGWU IP
# and udp dst port 2152                         # check GTPU port
# and (udp[28:4] & 0xffffff00) = 0x10000000     # check UE subnet
check_enb_subnet = "src net {} ".format(parser.enb_cidr)
check_spgwu_ip = " and dst host " + \
    " or ".join(str(x) for x in ips_by_interface(parser.s1u_ifname))
check_gtpu_port = " and udp dst port 2152"
check_ue_subnet = " and (udp[28:4] & 0x{}) = 0x{}".format(
    cidr2mask(parser.ue_cidr), ip2hex(cidr2block(parser.ue_cidr)[0]))
check_gtpu_msg_echo = " and udp[9] = 0x1"

# Echo filter
uplink_echo_filter = {"priority": -GTPUEchoGate, "filter": check_enb_subnet +
                      check_spgwu_ip + check_gtpu_port +
                      check_gtpu_msg_echo, "gate": GTPUEchoGate}
s1uFastBPF.add(filters=[uplink_echo_filter])

# PDU rule
uplink_filter = {"priority": -GTPUGate, "filter": check_enb_subnet +
               check_spgwu_ip + check_gtpu_port, "gate": GTPUGate}
s1uFastBPF.add(filters=[uplink_filter])

# Verify that destination MAC address matches that with s1u interface
# Exact match on desstination MAC address of the interface
macstr_u = mac_by_interface(parser.s1u_ifname)
ULMACDstMatch.add(fields=[{'value_int': mac2hex(macstr_u)}], gate=0)

# Add InetLookup rules
InetLookup.add(prefix='0.0.0.0', prefix_len=0, gate=0)

# Pipeline complete, resume bessd
bess.resume_all()


# ====================================================
#       Route Control
# ====================================================
# Finally send SIGHUP to route_control daemon on reload
# TODO: behavior is unspecified if route_control.py pid is not found
route_control_pid = getpythonpid('route_control.py')
if route_control_pid:
    os.kill(route_control_pid, signal.SIGHUP)
